
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Channel Projection | Research Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --border: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --success: #3fb950;
            --danger: #f85149;
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text-primary);
            font-family: var(--font-ui);
            display: grid;
            grid-template-columns: 1fr 380px;
            height: 100vh;
            overflow: hidden;
        }

        /* LEFT: Visualization Stage */
        #stage {
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
        }

        #header-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: -0.5px; }
        .subtitle { color: var(--text-secondary); font-family: var(--font-mono); font-size: 0.9rem; margin-top: 4px; }

        canvas { width: 100%; height: 100%; display: block; }

        /* RIGHT: Analysis Panel */
        #panel {
            background: var(--panel);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1px; /* Borders between sections */
            background-color: var(--border); 
        }

        .section {
            background: var(--panel);
            padding: 20px;
        }

        .section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: var(--text-secondary);
            margin-bottom: 15px;
            font-weight: 700;
        }

        /* Controls */
        .input-group { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        
        input[type="number"] {
            background: var(--bg);
            border: 1px solid var(--border);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: var(--font-mono);
            width: 80px;
        }

        input[type="range"] { flex-grow: 1; accent-color: var(--accent); }

        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 10px; }
        
        button {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px;
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
        }
        button:hover { border-color: var(--text-secondary); color: white; }
        button.active { background: rgba(88, 166, 255, 0.15); color: var(--accent); border-color: var(--accent); }
        button.primary { background: var(--success); color: white; border: none; font-weight: 600; }
        button.primary:hover { opacity: 0.9; }

        /* Stats Table */
        .data-table { width: 100%; font-size: 0.85rem; border-collapse: collapse; }
        .data-table td { padding: 4px 0; color: var(--text-secondary); }
        .data-table .val { text-align: right; color: var(--text-primary); font-family: var(--font-mono); }

        /* Legend */
        .legend-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 0.85rem; }
        .swatch { width: 12px; height: 12px; border-radius: 2px; }

        /* Export Section */
        .export-box {
            background: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        .export-options { display: flex; gap: 10px; margin-top: 10px; }
        .export-options button { flex: 1; }

        /* Footer */
        .footer {
            margin-top: auto;
            padding: 20px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            text-align: center;
        }

        #tooltip {
            position: absolute;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid var(--border);
            padding: 12px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 0.85rem;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="stage">
        <canvas id="vizCanvas"></canvas>
        <div id="header-overlay">
            <h1 id="disp-title">Modulus Projection</h1>
            <div id="disp-subtitle" class="subtitle">Initialize...</div>
        </div>
        <div id="tooltip"></div>
    </div>

    <div id="panel">
        <div class="section">
            <div class="section-title">Configuration</div>
            <div class="input-group">
                <label>M =</label>
                <input type="number" id="input-m" value="60">
                <input type="range" id="slider-m" min="4" max="2520" value="60">
            </div>
            <div class="btn-grid">
                <button onclick="setM(12)">12</button>
                <button onclick="setM(60)">60</button>
                <button onclick="setM(210)">210</button>
                <button onclick="setM(360)">360</button>
                <button onclick="setM(840)">840</button>
                <button onclick="setM(2310)">2310</button>
                <button onclick="setM(2520)">2520</button>
                <button onclick="setM(5040)">5040</button>
            </div>
            <div style="display: flex; gap:10px; margin-top:15px;">
                <button id="btn-anim" style="flex:1" onclick="toggleAnim()">▶ Sequence</button>
                <button style="flex:1" onclick="toggleView()">Mode: <span id="lbl-view">Projection</span></button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Analysis</div>
            <table class="data-table">
                <tr><td>Euler Totient φ(M)</td><td class="val" id="stat-phi">-</td></tr>
                <tr><td>Active Channels</td><td class="val" id="stat-channels">-</td></tr>
                <tr><td>Prime Factors</td><td class="val" id="stat-factors">-</td></tr>
                <tr><td>Reduction Depth</td><td class="val" id="stat-depth">-</td></tr>
            </table>
        </div>

        <div class="section">
            <div class="section-title">Legend</div>
            <div class="legend-row">
                <div class="swatch" style="background:#58a6ff"></div>
                <div>Irreducible (Coprime)</div>
            </div>
            <div class="legend-row">
                <div class="swatch" style="background:#ff6b6b"></div>
                <div>Reducible Residues</div>
            </div>
            <div class="legend-row">
                <div class="swatch" style="background:#ffd700"></div>
                <div>Center Well (M' = 1)</div>
            </div>
            <div class="legend-row">
                <div class="swatch" style="border: 1px solid #30363d; background: transparent"></div>
                <div>Farey Channel Rings</div>
            </div>
            <div style="margin-top:10px; font-size: 0.75rem; color: #8b949e; line-height: 1.4;">
                <strong>d = gcd(r, M)</strong>: Reduction Factor<br>
                <strong>M' = M/d</strong>: Target Channel<br>
                <strong>Pop = φ(M')</strong>: Channel Capacity
            </div>
        </div>

        <div class="section">
            <div class="section-title">Export Data</div>
            <div class="export-box">
                <div style="margin-bottom:8px; font-weight:600; font-size:0.9rem;">Generate Figure</div>
                <div class="export-options">
                    <button onclick="exportPNG('2k')">PNG 2K</button>
                    <button class="primary" onclick="exportPNG('4k')">PNG 4K</button>
                </div>
                <div style="margin-top:15px; font-weight:600; font-size:0.9rem;">Dataset</div>
                <div class="export-options">
                    <button onclick="exportCSV()">Download CSV</button>
                </div>
            </div>
        </div>

        <div class="footer">
            Tool by Wessen Getachew<br>
            Composite Channel Projection Corollary
        </div>
    </div>

<script>
/**
 * MATHEMATICAL KERNEL
 */
const MathCore = {
    gcd: (a, b) => {
        while (b) { [a, b] = [b, a % b]; }
        return a;
    },

    phi: (n) => {
        let result = n;
        for (let i = 2; i * i <= n; i++) {
            if (n % i === 0) {
                while (n % i === 0) n /= i;
                result -= result / i;
            }
        }
        if (n > 1) result -= result / n;
        return result;
    },

    getFactors: (n) => {
        const f = new Set();
        let d = 2, temp = n;
        while (d * d <= temp) {
            if (temp % d === 0) { f.add(d); temp /= d; } else { d++; }
        }
        if (temp > 1) f.add(temp);
        return Array.from(f).join(" × ");
    }
};

/**
 * STATE MANAGEMENT
 */
const State = {
    M: 60,
    viewMode: 'projection', // 'projection' | 'rings'
    isAnimating: false,
    residues: [],
    channels: [],
    stats: {}
};

/**
 * DATA PROCESSING
 */
function computeData() {
    const M = State.M;
    State.residues = [];
    const channelMap = {};

    // Generate Residues
    for (let r = 0; r < M; r++) {
        // Correct handling for r=0 mapping to r=M effectively in modular rings
        const effectiveR = r === 0 ? M : r;
        const d = MathCore.gcd(effectiveR, M);
        const m_prime = M / d;

        if (!channelMap[m_prime]) {
            channelMap[m_prime] = {
                val: m_prime,
                d: d,
                pop: MathCore.phi(m_prime),
                residues: []
            };
        }

        const res = {
            r: r,
            r_eff: effectiveR,
            d: d,
            m_prime: m_prime,
            angle: (r / M) * Math.PI * 2 - (Math.PI/2),
            isCoprime: d === 1
        };

        State.residues.push(res);
        channelMap[m_prime].residues.push(res);
    }

    // Sort Channels (Center M'=1 to Outer M'=M)
    State.channels = Object.values(channelMap).sort((a,b) => a.val - b.val);

    // Update Text UI
    document.getElementById('disp-title').innerText = `Modulus M = ${M}`;
    document.getElementById('disp-subtitle').innerText = `Prime Factorization: ${MathCore.getFactors(M)}`;
    
    document.getElementById('stat-phi').innerText = MathCore.phi(M);
    document.getElementById('stat-channels').innerText = State.channels.length;
    document.getElementById('stat-factors').innerText = MathCore.getFactors(M);
    document.getElementById('stat-depth').innerText = "Max " + State.channels[0].d;

    // Trigger Render
    requestAnimationFrame(() => renderScreen());
}

/**
 * RENDERING ENGINE (Abstracted)
 * Draws to ANY context (Screen or Export)
 */
function drawScene(ctx, width, height, isExport = false) {
    const cx = width / 2;
    const cy = height / 2;
    // Export needs padding for title/legend, screen is tight
    const size = Math.min(width, height);
    const maxR = isExport ? size * 0.35 : size * 0.42; 
    
    // Background
    ctx.fillStyle = isExport ? '#0d1117' : '#000000'; // Slightly lighter black for print
    ctx.fillRect(0, 0, width, height);

    if (State.channels.length === 0) return;

    // 1. Draw Rings
    State.channels.forEach((ch, i) => {
        // Calculate Radius based on index
        // Ring 0 (M'=1) is center. Ring N (M'=M) is maxR.
        // We use a non-linear scale to separate the inner rings better
        const pct = (i + 1) / (State.channels.length + 1);
        let r = pct * maxR;
        
        // Force M ring to edge, M'=1 ring to center
        if (ch.val === State.M) r = maxR;
        if (ch.val === 1) r = maxR * 0.05;

        ch.renderRadius = r; // Store for point projection

        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.strokeStyle = '#21262d';
        ctx.lineWidth = isExport ? 2 : 1;
        ctx.stroke();

        // Ring Labels (Only on export or if sparse)
        if (isExport || State.channels.length < 15) {
            ctx.fillStyle = '#484f58';
            ctx.font = isExport ? '24px monospace' : '10px monospace';
            ctx.fillText(ch.val, cx + 5, cy - r - 5);
        }
    });

    // 2. Draw Connections & Points
    const opacity = Math.max(0.1, 30 / State.M); // Dynamic opacity
    
    State.residues.forEach(res => {
        // Source Coords (Outer Ring)
        const outerR = maxR;
        const sx = cx + Math.cos(res.angle) * outerR;
        const sy = cy + Math.sin(res.angle) * outerR;

        // Dest Coords (Channel Ring)
        const ch = State.channels.find(c => c.val === res.m_prime);
        const dr = ch.renderRadius;
        const dx = cx + Math.cos(res.angle) * dr;
        const dy = cy + Math.sin(res.angle) * dr;

        // Color Logic
        let color = '#58a6ff'; // Coprime Blue
        if (!res.isCoprime) color = '#ff6b6b'; // Reducible Red
        if (res.m_prime === 1) color = '#ffd700'; // Gold Center

        // Draw Line (Projection Mode only)
        if (State.viewMode === 'projection' && res.d > 1) {
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(dx, dy);
            ctx.strokeStyle = color;
            ctx.globalAlpha = isExport ? opacity * 1.5 : opacity;
            ctx.lineWidth = isExport ? 2 : 1;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        // Draw Point (Destination)
        const pSize = isExport ? (res.isCoprime ? 6 : 8) : (res.isCoprime ? 2 : 3);
        ctx.beginPath();
        ctx.arc(dx, dy, pSize, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        
        // Store hit data if screen render
        if (!isExport) {
            res.hit = {x: dx, y: dy, r: pSize + 2};
        }
    });
}

/**
 * SCREEN RENDERER
 */
const canvas = document.getElementById('vizCanvas');
const ctx = canvas.getContext('2d');

function renderScreen() {
    canvas.width = canvas.parentElement.offsetWidth;
    canvas.height = canvas.parentElement.offsetHeight;
    drawScene(ctx, canvas.width, canvas.height, false);
}

/**
 * EXPORT: PNG GENERATOR (High Res)
 */
function exportPNG(res) {
    const size = res === '4k' ? 4096 : 2048;
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = size;
    exportCanvas.height = size * 0.75; // 4:3 Aspect Ratio for Papers
    const eCtx = exportCanvas.getContext('2d');

    // 1. Draw The Scene
    // We offset the scene to the left to make room for Legend
    const sceneWidth = size * 0.75; 
    
    // Fill Background
    eCtx.fillStyle = '#0d1117';
    eCtx.fillRect(0,0, size, size * 0.75);

    // Render Viz
    drawScene(eCtx, sceneWidth, size * 0.75, true);

    // 2. Draw "Paper" Meta Data
    const margin = size * 0.05;
    const textX = sceneWidth; 
    
    // Title Block
    eCtx.fillStyle = '#f0f6fc';
    eCtx.font = `bold ${size*0.04}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto`;
    eCtx.textAlign = "left";
    eCtx.fillText(`Modulus M = ${State.M}`, textX, margin + (size*0.05));

    eCtx.fillStyle = '#8b949e';
    eCtx.font = `${size*0.02}px monospace`;
    eCtx.fillText(`Prime Factors: ${MathCore.getFactors(State.M)}`, textX, margin + (size*0.08));

    // Stats Block
    let y = margin + (size * 0.15);
    const lineHeight = size * 0.025;
    
    eCtx.fillStyle = '#58a6ff';
    eCtx.font = `bold ${size*0.018}px sans-serif`;
    eCtx.fillText("STATISTICS", textX, y);
    y += lineHeight * 1.5;

    eCtx.fillStyle = '#f0f6fc';
    eCtx.font = `${size*0.018}px monospace`;
    eCtx.fillText(`φ(M) Count: ${MathCore.phi(State.M)}`, textX, y); y += lineHeight;
    eCtx.fillText(`Channels:   ${State.channels.length}`, textX, y); y += lineHeight;
    eCtx.fillText(`Max Depth:  ${State.channels[0].d}`, textX, y);

    // Legend Block
    y += lineHeight * 3;
    eCtx.fillStyle = '#58a6ff';
    eCtx.font = `bold ${size*0.018}px sans-serif`;
    eCtx.fillText("LEGEND", textX, y);
    y += lineHeight * 1.5;

    function drawLegendItem(color, text) {
        eCtx.fillStyle = color;
        eCtx.beginPath();
        eCtx.arc(textX + (size*0.008), y - (size*0.006), size*0.008, 0, Math.PI*2);
        eCtx.fill();
        
        eCtx.fillStyle = '#c9d1d9';
        eCtx.font = `${size*0.018}px sans-serif`;
        eCtx.fillText(text, textX + (size*0.03), y);
        y += lineHeight * 1.5;
    }

    drawLegendItem('#58a6ff', `Irreducible (Coprime)`);
    drawLegendItem('#ff6b6b', `Reducible Residue`);
    drawLegendItem('#ffd700', `Center (M'=1)`);
    
    y += lineHeight;
    eCtx.fillStyle = '#8b949e';
    eCtx.font = `italic ${size*0.015}px sans-serif`;
    eCtx.fillText("Projection logic based on", textX, y); y += lineHeight;
    eCtx.fillText("Composite Channel Corollary.", textX, y);

    // Footer / Signature
    eCtx.fillStyle = '#30363d';
    eCtx.fillRect(textX, size*0.75 - margin - (size*0.04), size*0.2, 2);
    
    eCtx.fillStyle = '#8b949e';
    eCtx.font = `${size*0.018}px sans-serif`;
    eCtx.fillText("Analysis by", textX, size*0.75 - margin);
    eCtx.fillStyle = '#f0f6fc';
    eCtx.font = `bold ${size*0.02}px sans-serif`;
    eCtx.fillText("Wessen Getachew", textX, size*0.75 - margin + (size*0.025));

    // 3. Download
    const link = document.createElement('a');
    link.download = `Projection_M${State.M}_${res}.png`;
    link.href = exportCanvas.toDataURL('image/png');
    link.click();
}

/**
 * EXPORT: CSV DATASET
 */
function exportCSV() {
    let csv = "Residue_r,Modulus_M,GCD_d,Channel_M_Prime,Reduced_Fraction,Angle_Rad,Type\n";
    
    State.residues.forEach(r => {
        const type = r.isCoprime ? "Irreducible" : "Reducible";
        const frac = `${r.r/r.d}/${r.m_prime}`;
        csv += `${r.r},${State.M},${r.d},${r.m_prime},${frac},${r.angle.toFixed(4)},${type}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `Channel_Data_M${State.M}.csv`;
    link.click();
}

/**
 * UI INTERACTION
 */
function setM(val) {
    State.M = parseInt(val);
    document.getElementById('input-m').value = State.M;
    document.getElementById('slider-m').value = State.M;
    computeData();
}

document.getElementById('input-m').addEventListener('change', e => setM(e.target.value));
document.getElementById('slider-m').addEventListener('input', e => setM(e.target.value));

// View Toggle
function toggleView() {
    State.viewMode = State.viewMode === 'projection' ? 'rings' : 'projection';
    document.getElementById('lbl-view').innerText = State.viewMode === 'projection' ? 'Projection' : 'Rings';
    renderScreen();
}

// Animation
let animInterval;
function toggleAnim() {
    const btn = document.getElementById('btn-anim');
    if (State.isAnimating) {
        clearInterval(animInterval);
        State.isAnimating = false;
        btn.innerHTML = "▶ Sequence";
        btn.classList.remove('active');
    } else {
        State.isAnimating = true;
        btn.innerHTML = "⏹ Stop";
        btn.classList.add('active');
        animInterval = setInterval(() => {
            let next = State.M + 1;
            if (next > 2520) next = 4;
            setM(next);
        }, 100);
    }
}

// Tooltip Interaction
canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Find nearest point
    let minD = 1000;
    let target = null;
    
    // Reverse search for layers on top
    for(let i=State.residues.length-1; i>=0; i--) {
        const r = State.residues[i];
        if (!r.hit) continue;
        const dist = Math.sqrt(Math.pow(x - r.hit.x, 2) + Math.pow(y - r.hit.y, 2));
        if (dist < r.hit.r + 2 && dist < minD) {
            minD = dist;
            target = r;
        }
    }

    const tt = document.getElementById('tooltip');
    if (target) {
        tt.style.display = 'block';
        tt.style.left = (e.clientX + 15) + 'px';
        tt.style.top = (e.clientY + 15) + 'px';
        tt.innerHTML = `
            <div style="color:${target.isCoprime?'#58a6ff':'#ff6b6b'}; font-weight:bold; margin-bottom:4px;">
                Residue r = ${target.r}
            </div>
            <div style="font-family:monospace; font-size:0.8em; color:#8b949e">
                Fraction: ${target.r}/${State.M}<br>
                Reduces:  ${target.r/target.d}/${target.m_prime}<br>
                GCD (d):  ${target.d}
            </div>
            <div style="margin-top:4px; border-top:1px solid #30363d; padding-top:4px; color:#f0f6fc">
                Channel M' = ${target.m_prime}
            </div>
        `;
    } else {
        tt.style.display = 'none';
    }
});

// Init
window.addEventListener('resize', renderScreen);
computeData();

</script>
</body>
</html>
