
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Twin Prime Sphere</title>
  <style>body { margin: 0; }</style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.z = 500;

    const N = 5050;
    const radius = 300;

    function isPrime(n) {
      if (n < 2) return false;
      for (let i = 2; i <= Math.sqrt(n); i++) {
        if (n % i === 0) return false;
      }
      return true;
    }

    function isTwinPrime(n) {
      return isPrime(n) && (isPrime(n - 2) || isPrime(n + 2));
    }

    function fibonacciSpherePoints(samples, r) {
      let points = [];
      const goldenAngle = Math.PI * (3 - Math.sqrt(5));
      for (let i = 0; i < samples; i++) {
        const y = 1 - (i / (samples - 1)) * 2;
        const radiusAtY = Math.sqrt(1 - y * y);
        const theta = goldenAngle * i;
        const x = Math.cos(theta) * radiusAtY;
        const z = Math.sin(theta) * radiusAtY;
        points.push(new THREE.Vector3(x * r, y * r, z * r));
      }
      return points;
    }

    const points = fibonacciSpherePoints(N, radius);

    for (let i = 1; i <= N; i++) {
      const point = points[i - 1];
      let color;
      if (isTwinPrime(i)) {
        color = 0xff0000;  // red
      } else if (isPrime(i)) {
        color = 0x00ff00;  // green
      } else {
        color = 0x000000;  // black
      }

      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(2.5, 6, 6),
        new THREE.MeshBasicMaterial({ color })
      );
      sphere.position.copy(point);
      scene.add(sphere);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
