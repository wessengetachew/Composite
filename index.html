
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Reduction Projection Explorer</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --main-color: #0f4c75;
            --accent-color: #3282b8;
            --text-color: #bbe1fa;
            --border-color: #2c394b;
            --highlight-color: #ffd700;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            min-height: 100vh;
            flex-direction: column;
        }

        header {
            background-color: var(--main-color);
            padding: 15px 30px;
            text-align: center;
            border-bottom: 3px solid var(--accent-color);
        }

        h1 {
            margin: 0;
            font-size: 1.8em;
            color: var(--highlight-color);
        }

        h2 {
            margin: 5px 0 0 0;
            font-size: 1.1em;
            color: var(--text-color);
        }

        .container {
            display: flex;
            flex-grow: 1;
        }

        .sidebar {
            width: 320px;
            padding: 20px;
            background-color: var(--border-color);
            overflow-y: auto;
            border-right: 2px solid var(--accent-color);
        }

        .content {
            flex-grow: 1;
            padding: 10px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            border: 5px solid var(--highlight-color);
            background-color: #000;
            border-radius: 10px;
            display: block;
            touch-action: none;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid var(--accent-color);
            border-radius: 5px;
        }

        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--highlight-color);
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: calc(100% - 60px);
        }

        input[type="number"], select {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background-color: var(--bg-color);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            border-radius: 3px;
        }

        .slider-value {
            font-family: monospace;
            color: var(--highlight-color);
            width: 40px;
            text-align: right;
            display: inline-block;
        }

        button {
            padding: 10px 15px;
            background-color: var(--accent-color);
            color: var(--text-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }

        button:hover { background-color: var(--main-color); }
        button:disabled { background-color: #555; cursor: not-allowed; }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background-color: var(--main-color);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.85em;
            text-align: center;
        }

        .stat-box strong {
            display: block;
            font-size: 1.2em;
            color: var(--highlight-color);
            font-family: monospace;
        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.95);
            color: var(--text-color);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 100;
            font-family: monospace;
            font-size: 0.8em;
            border: 1px solid var(--highlight-color);
            display: none;
        }
    </style>
</head>
<body>
    <header>
        <h1 id="disp-title">Modular Reduction Projection: M = 42</h1>
        <h2 id="disp-subtitle">2 √ó 3 √ó 7</h2>
    </header>

    <div class="container">
        <div class="sidebar">
            <div class="control-group">
                <h3>Animation</h3>
                <div class="button-grid">
                    <button id="playButton" onclick="startSequence()">‚ñ∂Ô∏è Play</button>
                    <button id="stopButton" onclick="stopSequence()" disabled>‚è∏Ô∏è Stop</button>
                </div>
                <label>Speed: <span class="slider-value" id="speedValue">500</span>ms</label>
                <input type="range" id="speedSlider" min="50" max="2000" step="50" value="500">
            </div>

            <div class="control-group">
                <h3>Modulus M = <span id="modulusValue">42</span></h3>
                <input type="range" id="modulusSlider" min="2" max="5000" value="42">
                <input type="number" id="modulusInput" value="42" min="2" max="10000">
            </div>

            <div class="control-group">
                <h3>View</h3>
                <label>Zoom: <span class="slider-value" id="zoomValue">1.00</span>x</label>
                <input type="range" id="zoomSlider" min="10" max="1000" step="10" value="100">
                <button onclick="resetView()">Reset View</button>
            </div>

            <div class="control-group">
                <h3>Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box">M: <strong><span id="modulusStat">42</span></strong></div>
                    <div class="stat-box">œÜ(M): <strong><span id="phiValue">12</span></strong></div>
                    <div class="stat-box">Coprime: <strong><span id="irreducibleCount">12</span></strong></div>
                    <div class="stat-box">Non-coprime: <strong><span id="reducibleCount">30</span></strong></div>
                    <div class="stat-box">Channels: <strong><span id="channelCount">8</span></strong></div>
                    <div class="stat-box">Density: <strong><span id="densityValue">28.6%</span></strong></div>
                </div>
            </div>

            <div class="control-group">
                <h3>Appearance</h3>
                <label>Color Scheme</label>
                <select id="colorScheme">
                    <option value="channel-type" selected>Coprime/Non-coprime</option>
                    <option value="rainbow">Rainbow</option>
                </select>
                
                <label>Point Size: <span class="slider-value" id="pointSizeValue">3.00</span></label>
                <input type="range" id="pointSizeSlider" min="1" max="10" step="0.5" value="3">
                
                <label>Opacity: <span class="slider-value" id="opacityValue">1.00</span></label>
                <input type="range" id="opacitySlider" min="0" max="100" step="1" value="100">
            </div>

            <div class="control-group">
                <h3>Visualization</h3>
                <label><input type="checkbox" id="showProjections" checked> Projection Lines</label>
                <label><input type="checkbox" id="showRings" checked> Channel Rings</label>
                <label><input type="checkbox" id="showAllRings" checked> Inner Rings</label>
                
                <label>Ring Spacing: <span class="slider-value" id="spacingValue">1.00</span></label>
                <input type="range" id="spacingSlider" min="0" max="200" step="1" value="100">
            </div>

            <div class="control-group">
                <h3>Export</h3>
                <label>Resolution (px)</label>
                <input type="number" id="exportResolution" value="3000" min="1000" max="8000">
                <button onclick="exportImage()">üñºÔ∏è Export PNG</button>
            </div>
        </div>

        <div class="content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div id="tooltip"></div>
            </div>
        </div>
    </div>

    <script>
        // Math utilities
        function gcd(a, b) { while (b !== 0) { const temp = b; b = a % b; a = temp; } return a; }
        function phi(n) { let result = n; let p = 2; while (p * p <= n) { if (n % p === 0) { while (n % p === 0) n /= p; result -= result / p; } p++; } if (n > 1) result -= result / n; return Math.round(result); }
        function isPrime(n) { if (n < 2) return false; if (n === 2) return true; if (n % 2 === 0) return false; for (let i = 3; i * i <= n; i += 2) { if (n % i === 0) return false; } return true; }
        
        function primeFactorization(n) {
            const factors = [];
            let d = 2;
            while (n > 1) {
                let count = 0;
                while (n % d === 0) { count++; n /= d; }
                if (count > 0) factors.push({ prime: d, power: count });
                d++;
                if (d * d > n && n > 1) { factors.push({ prime: n, power: 1 }); break; }
            }
            return factors;
        }
        
        function formatFactorization(factors) {
            return factors.map(f => {
                if (f.power === 1) return f.prime.toString();
                const superscripts = '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ';
                const powerStr = f.power.toString().split('').map(d => superscripts[parseInt(d)]).join('');
                return `${f.prime}${powerStr}`;
            }).join(' √ó ');
        }
        
        function getDivisors(n) {
            const divisors = new Set();
            for (let i = 1; i * i <= n; i++) {
                if (n % i === 0) {
                    divisors.add(i);
                    divisors.add(n / i);
                }
            }
            return Array.from(divisors).sort((a, b) => a - b);
        }

        // Configuration
        let config = {
            modulus: 42,
            colorScheme: 'channel-type',
            opacity: 1.0,
            pointSize: 3,
            showProjections: true,
            showAllRings: true,
            showRings: true,
            spacingFactor: 1.0,
            zoom: 1.0,
            panX: 0,
            panY: 0,
            animationSpeed: 500
        };

        // State
        let canvas, ctx;
        let points = [];
        let channels = new Map();
        let allRingPoints = new Map();
        let hoveredPoint = null;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        let sequenceInterval = null;

        // Color functions
        function getPointColor(p) {
            if (config.colorScheme === 'rainbow') {
                return `hsl(${(p.r / p.M) * 360}, 70%, 60%)`;
            }
            return p.isOpen ? '#00ffff' : '#ff1493';
        }

        // Data calculation
        function calculatePoints() {
            const M = config.modulus;
            points = [];
            channels = new Map();
            allRingPoints.clear();

            for (let r = 0; r < M; r++) {
                const g = gcd(r, M);
                const isOpen = g === 1;
                const reducedR = r / g;
                const reducedM = M / g;
                const angle = (2 * Math.PI * r) / M;

                points.push({
                    r, M, gcd: g, isOpen, reducedR, reducedM, angle,
                    screenX: 0, screenY: 0
                });

                if (!channels.has(reducedM)) {
                    channels.set(reducedM, {
                        M_prime: reducedM,
                        multiplicity: M / reducedM,
                        residues: [],
                        count: 0
                    });
                }
                channels.get(reducedM).residues.push(r);
                channels.get(reducedM).count++;
            }

            getDivisors(M).forEach(d => {
                const ringPoints = [];
                for (let r = 0; r < d; r++) {
                    const g = gcd(r, d);
                    ringPoints.push({
                        r, M: d, gcd: g, isOpen: g === 1,
                        reducedR: r / g, reducedM: d / g,
                        angle: (2 * Math.PI * r) / d
                    });
                }
                allRingPoints.set(d, ringPoints);
            });

            updateStatistics();
        }

        function updateStatistics() {
            const M = config.modulus;
            const factors = primeFactorization(M);
            const phiM = phi(M);
            const coprime = points.filter(p => p.isOpen).length;
            const nonCoprime = points.filter(p => !p.isOpen).length;
            const density = (phiM / M * 100).toFixed(1);

            document.getElementById('modulusValue').textContent = M;
            document.getElementById('modulusInput').value = M;
            document.getElementById('modulusStat').textContent = M;
            
            document.getElementById('disp-title').textContent = `Modular Reduction Projection: M = ${M}`;
            document.getElementById('disp-subtitle').textContent = formatFactorization(factors);
            
            document.getElementById('phiValue').textContent = phiM;
            document.getElementById('irreducibleCount').textContent = coprime;
            document.getElementById('reducibleCount').textContent = nonCoprime;
            document.getElementById('channelCount').textContent = channels.size;
            document.getElementById('densityValue').textContent = density + '%';
        }

        // Drawing
        function draw() {
            const dpr = window.devicePixelRatio || 1;
            const size = canvas.width / dpr;
            const centerX = size / 2;
            const centerY = size / 2;
            const baseRadius = size * 0.45;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(config.zoom, config.zoom);
            ctx.translate(config.panX, config.panY);
            
            const s = 1 / config.zoom;

            // Projection lines
            if (config.showProjections) {
                ctx.globalAlpha = config.opacity;
                points.forEach(p => {
                    if (!p.isOpen) {
                        const outerX = baseRadius * Math.cos(p.angle - Math.PI / 2);
                        const outerY = baseRadius * Math.sin(p.angle - Math.PI / 2);
                        const channelRadius = baseRadius * Math.pow(p.reducedM / config.modulus, config.spacingFactor);
                        const targetAngle = (2 * Math.PI * p.reducedR) / p.reducedM;
                        const innerX = channelRadius * Math.cos(targetAngle - Math.PI / 2);
                        const innerY = channelRadius * Math.sin(targetAngle - Math.PI / 2);

                        ctx.beginPath();
                        ctx.moveTo(outerX, outerY);
                        ctx.lineTo(innerX, innerY);
                        ctx.strokeStyle = '#ff1493';
                        ctx.lineWidth = 0.5 * s;
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }

            // Channel rings
            if (config.showRings) {
                const divisors = getDivisors(config.modulus).filter(d => channels.has(d));
                divisors.forEach(d => {
                    const radius = baseRadius * Math.pow(d / config.modulus, config.spacingFactor);
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 1 * s;
                    ctx.stroke();
                });
            }

            // Inner ring points
            if (config.showAllRings) {
                const divisors = getDivisors(config.modulus);
                divisors.forEach(d => {
                    if (d === config.modulus) return;
                    const ringPoints = allRingPoints.get(d);
                    if (!ringPoints) return;
                    const radius = baseRadius * Math.pow(d / config.modulus, config.spacingFactor);
                    
                    ringPoints.forEach(p => {
                        if (!p.isOpen) return;
                        const x = radius * Math.cos(p.angle - Math.PI / 2);
                        const y = radius * Math.sin(p.angle - Math.PI / 2);
                        ctx.beginPath();
                        ctx.arc(x, y, config.pointSize * 0.7 * s, 0, 2 * Math.PI);
                        ctx.fillStyle = '#ffd700';
                        ctx.fill();
                    });
                });
            }

            // Outer ring points
            points.forEach(p => {
                const x = baseRadius * Math.cos(p.angle - Math.PI / 2);
                const y = baseRadius * Math.sin(p.angle - Math.PI / 2);
                const color = getPointColor(p);

                ctx.beginPath();
                ctx.arc(x, y, config.pointSize * s, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();

                if (hoveredPoint && hoveredPoint.r === p.r) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2 * s;
                    ctx.stroke();
                }

                p.screenX = x;
                p.screenY = y;
            });

            ctx.restore();
        }

        // Animation
        function handleSequence() {
            let nextModulus = config.modulus + 1;
            if (nextModulus > 5000) nextModulus = 2;
            setModulus(nextModulus);
        }

        function startSequence() {
            if (sequenceInterval === null) {
                sequenceInterval = setInterval(handleSequence, config.animationSpeed);
                document.getElementById('playButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
            }
        }

        function stopSequence() {
            if (sequenceInterval !== null) {
                clearInterval(sequenceInterval);
                sequenceInterval = null;
                document.getElementById('playButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
            }
        }

        function resetView() {
            config.zoom = 1.0;
            config.panX = 0;
            config.panY = 0;
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = '1.00';
            draw();
        }

        function setModulus(m) {
            config.modulus = m;
            document.getElementById('modulusSlider').value = Math.min(m, 5000);
            calculatePoints();
            draw();
        }

        // Event handlers
        function handlePointerMove(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            if (isDragging) {
                config.panX += (x - lastMouse.x) * dpr / config.zoom;
                config.panY += (y - lastMouse.y) * dpr / config.zoom;
                lastMouse = { x, y };
                draw();
                return;
            }
            
            const canvasX = (x - rect.left) * dpr;
            const canvasY = (y - rect.top) * dpr;
            const size = canvas.width / dpr;
            const worldX = (canvasX / dpr - size / 2) / config.zoom - config.panX;
            const worldY = (canvasY / dpr - size / 2) / config.zoom - config.panY;

            let closest = null;
            let minDist = config.pointSize * 3 / config.zoom;

            points.forEach(p => {
                const dist = Math.sqrt((worldX - p.screenX) ** 2 + (worldY - p.screenY) ** 2);
                if (dist < minDist) {
                    minDist = dist;
                    closest = p;
                }
            });

            if (closest !== hoveredPoint) {
                hoveredPoint = closest;
                draw();
                updateTooltip(x, y);
            } else if (hoveredPoint) {
                updateTooltip(x, y);
            } else {
                document.getElementById('tooltip').style.display = 'none';
            }
        }

        function updateTooltip(x, y) {
            const tooltip = document.getElementById('tooltip');
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (x + 15) + 'px';
                tooltip.style.top = (y + 15) + 'px';
                
                const p = hoveredPoint;
                const reduction = p.isOpen ? 'Coprime' : `${p.r}/${p.M} ‚Üí ${p.reducedR}/${p.reducedM}`;
                
                tooltip.innerHTML = `
                    <div><strong>r = ${p.r}</strong></div>
                    <div>M = ${p.M}</div>
                    <div>GCD = ${p.gcd}</div>
                    <div>${reduction}</div>
                    ${!p.isOpen ? `<div>Channel M' = ${p.reducedM}</div>` : ''}
                    <div>Angle: ${((p.angle * 180 / Math.PI) % 360).toFixed(1)}¬∞</div>
                `;
            } else {
                tooltip.style.display = 'none';
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 1.1 : 0.9;
            config.zoom = Math.min(Math.max(config.zoom * delta, 0.1), 10);
            document.getElementById('zoomSlider').value = Math.round(config.zoom * 100);
            document.getElementById('zoomValue').textContent = config.zoom.toFixed(2);
            draw();
        }

        // Export with legend
        function exportImage() {
            const resolution = parseInt(document.getElementById('exportResolution').value);
            const titleH = resolution * 0.1;
            const canvasW = resolution * 0.65;
            const legendW = resolution * 0.35;
            const canvasH = resolution - titleH;
            
            const exportCanvas = document.createElement('canvas');
            const ctx2 = exportCanvas.getContext('2d');
            exportCanvas.width = resolution;
            exportCanvas.height = resolution;
            
            // Background
            ctx2.fillStyle = '#000';
            ctx2.fillRect(0, 0, resolution, resolution);
            
            // Title section
            ctx2.fillStyle = '#0f4c75';
            ctx2.fillRect(0, 0, resolution, titleH);
            ctx2.strokeStyle = '#3282b8';
            ctx2.lineWidth = 4;
            ctx2.strokeRect(0, titleH - 2, resolution, 2);
            
            ctx2.font = `bold ${titleH * 0.3}px Arial`;
            ctx2.fillStyle = '#ffd700';
            ctx2.textAlign = 'center';
            ctx2.fillText('Modular Reduction Projection Explorer', resolution / 2, titleH * 0.15);
            
            ctx2.font = `bold ${titleH * 0.28}px monospace`;
            ctx2.fillStyle = '#fff';
            ctx2.fillText(`M = ${config.modulus}`, resolution / 2, titleH * 0.5);
            
            const factors = primeFactorization(config.modulus);
            ctx2.font = `${titleH * 0.18}px Arial`;
            ctx2.fillStyle = '#bbe1fa';
            ctx2.fillText(formatFactorization(factors), resolution / 2, titleH * 0.8);
            
            // Visualization
            ctx2.save();
            ctx2.translate(canvasW / 2, titleH + canvasH / 2);
            const vizSize = Math.min(canvasW, canvasH);
            const baseRadius = vizSize * 0.42;
            
            // Projection lines
            if (config.showProjections) {
                ctx2.globalAlpha = config.opacity;
                points.forEach(p => {
                    if (!p.isOpen) {
                        const outerX = baseRadius * Math.cos(p.angle - Math.PI / 2);
                        const outerY = baseRadius * Math.sin(p.angle - Math.PI / 2);
                        const channelRadius = baseRadius * Math.pow(p.reducedM / config.modulus, config.spacingFactor);
                        const targetAngle = (2 * Math.PI * p.reducedR) / p.reducedM;
                        const innerX = channelRadius * Math.cos(targetAngle - Math.PI / 2);
                        const innerY = channelRadius * Math.sin(targetAngle - Math.PI / 2);
                        ctx2.beginPath();
                        ctx2.moveTo(outerX, outerY);
                        ctx2.lineTo(innerX, innerY);
                        ctx2.strokeStyle = '#ff1493';
                        ctx2.lineWidth = resolution / 2000;
                        ctx2.stroke();
                    }
                });
                ctx2.globalAlpha = 1.0;
            }
            
            // Rings
            if (config.showRings) {
                getDivisors(config.modulus).filter(d => channels.has(d)).forEach(d => {
                    const radius = baseRadius * Math.pow(d / config.modulus, config.spacingFactor);
                    ctx2.beginPath();
                    ctx2.arc(0, 0, radius, 0, 2 * Math.PI);
                    ctx2.strokeStyle = '#ffd700';
                    ctx2.lineWidth = resolution / 1000;
                    ctx2.stroke();
                });
            }
            
            // Inner rings
            if (config.showAllRings) {
                getDivisors(config.modulus).forEach(d => {
                    if (d === config.modulus) return;
                    const ringPoints = allRingPoints.get(d);
                    if (!ringPoints) return;
                    const radius = baseRadius * Math.pow(d / config.modulus, config.spacingFactor);
                    ringPoints.forEach(p => {
                        if (!p.isOpen) return;
                        const x = radius * Math.cos(p.angle - Math.PI / 2);
                        const y = radius * Math.sin(p.angle - Math.PI / 2);
                        ctx2.beginPath();
                        ctx2.arc(x, y, config.pointSize * resolution / 2000 * 0.7, 0, 2 * Math.PI);
                        ctx2.fillStyle = '#ffd700';
                        ctx2.fill();
                    });
                });
            }
            
            // Outer points
            points.forEach(p => {
                const x = baseRadius * Math.cos(p.angle - Math.PI / 2);
                const y = baseRadius * Math.sin(p.angle - Math.PI / 2);
                ctx2.beginPath();
                ctx2.arc(x, y, config.pointSize * resolution / 2000, 0, 2 * Math.PI);
                ctx2.fillStyle = getPointColor(p);
                ctx2.fill();
            });
            ctx2.restore();
            
            // Legend panel
            const lx = canvasW;
            const ly = titleH;
            ctx2.fillStyle = '#1a1a2e';
            ctx2.fillRect(lx, ly, legendW, canvasH);
            ctx2.strokeStyle = '#3282b8';
            ctx2.lineWidth = 3;
            ctx2.strokeRect(lx, ly, legendW, canvasH);
            
            let yPos = ly + resolution * 0.03;
            const lm = lx + resolution * 0.02;
            const fs = resolution * 0.014;
            const lh = resolution * 0.025;
            
            ctx2.textAlign = 'left';
            ctx2.font = `bold ${fs * 1.3}px Arial`;
            ctx2.fillStyle = '#ffd700';
            ctx2.fillText('Legend & Statistics', lm, yPos);
            yPos += lh * 2;
            
            ctx2.font = `bold ${fs}px Arial`;
            ctx2.fillStyle = '#3282b8';
            ctx2.fillText('Color Scheme:', lm, yPos);
            yPos += lh * 1.2;
            
            ctx2.font = `${fs * 0.9}px Arial`;
            ctx2.fillStyle = '#00ffff';
            ctx2.fillRect(lm, yPos, lh * 0.8, lh * 0.8);
            ctx2.fillStyle = '#bbe1fa';
            ctx2.fillText('Coprime (œÜ)', lm + lh, yPos + lh * 0.2);
            yPos += lh;
            
            ctx2.fillStyle = '#ff1493';
            ctx2.fillRect(lm, yPos, lh * 0.8, lh * 0.8);
            ctx2.fillStyle = '#bbe1fa';
            ctx2.fillText('Non-coprime', lm + lh, yPos + lh * 0.2);
            yPos += lh * 2;
            
            ctx2.font = `bold ${fs}px Arial`;
            ctx2.fillStyle = '#3282b8';
            ctx2.fillText('Statistics:', lm, yPos);
            yPos += lh * 1.2;
            
            ctx2.font = `${fs * 0.85}px monospace`;
            ctx2.fillStyle = '#bbe1fa';
            const stats = [
                `Total Residues: ${config.modulus}`,
                `œÜ(M): ${phi(config.modulus)}`,
                `Coprime: ${points.filter(p => p.isOpen).length}`,
                `Non-coprime: ${points.filter(p => !p.isOpen).length}`,
                `Density: ${(phi(config.modulus) / config.modulus * 100).toFixed(1)}%`,
                `Channels: ${channels.size}`,
                `Divisors: ${getDivisors(config.modulus).length}`,
                `Prime: ${isPrime(config.modulus) ? 'Yes' : 'No'}`
            ];
            stats.forEach(s => {
                ctx2.fillText(s, lm, yPos);
                yPos += lh * 0.95;
            });
            yPos += lh;
            
            ctx2.font = `bold ${fs}px Arial`;
            ctx2.fillStyle = '#3282b8';
            ctx2.fillText('Top Channels:', lm, yPos);
            yPos += lh * 1.2;
            
            ctx2.font = `${fs * 0.8}px monospace`;
            ctx2.fillStyle = '#bbe1fa';
            Array.from(channels.entries())
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 6)
                .forEach(([m, ch]) => {
                    ctx2.fillText(`M'=${m}: ${ch.count} pts (√ó${ch.multiplicity})`, lm + fs * 0.5, yPos);
                    yPos += lh * 0.9;
                });
            
            ctx2.font = `${fs * 0.7}px Arial`;
            ctx2.fillStyle = '#666';
            ctx2.textAlign = 'center';
            ctx2.fillText(`Generated: ${new Date().toLocaleDateString()}`, lx + legendW / 2, resolution - resolution * 0.02);
            
            const link = document.createElement('a');
            link.download = `modular-reduction-M${config.modulus}-${resolution}px.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        // Canvas initialization
        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            new ResizeObserver(() => {
                const size = Math.min(container.clientWidth, container.clientHeight);
                const dpr = window.devicePixelRatio || 1;
                canvas.width = size * dpr;
                canvas.height = size * dpr;
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;
                draw();
            }).observe(container);
            
            canvas.addEventListener('mousedown', e => {
                isDragging = true;
                lastMouse = { x: e.offsetX, y: e.offsetY };
                canvas.style.cursor = 'grabbing';
            });
            canvas.addEventListener('mousemove', e => handlePointerMove(e.offsetX, e.offsetY));
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
                document.getElementById('tooltip').style.display = 'none';
            });
            canvas.addEventListener('wheel', handleWheel);
            canvas.style.cursor = 'grab';
        }

        // Setup listeners
        function setupListeners() {
            document.getElementById('modulusSlider').addEventListener('input', e => setModulus(parseInt(e.target.value)));
            document.getElementById('modulusInput').addEventListener('input', e => {
                const v = parseInt(e.target.value);
                if (v >= 2 && v <= 10000) setModulus(v);
            });
            
            document.getElementById('zoomSlider').addEventListener('input', e => {
                config.zoom = parseInt(e.target.value) / 100;
                document.getElementById('zoomValue').textContent = config.zoom.toFixed(2);
                draw();
            });
            
            document.getElementById('speedSlider').addEventListener('input', e => {
                config.animationSpeed = parseInt(e.target.value);
                document.getElementById('speedValue').textContent = e.target.value;
                if (sequenceInterval) {
                    stopSequence();
                    startSequence();
                }
            });
            
            document.getElementById('colorScheme').addEventListener('change', e => {
                config.colorScheme = e.target.value;
                draw();
            });
            
            document.getElementById('pointSizeSlider').addEventListener('input', e => {
                config.pointSize = parseFloat(e.target.value);
                document.getElementById('pointSizeValue').textContent = config.pointSize.toFixed(2);
                draw();
            });
            
            document.getElementById('opacitySlider').addEventListener('input', e => {
                config.opacity = parseInt(e.target.value) / 100;
                document.getElementById('opacityValue').textContent = config.opacity.toFixed(2);
                draw();
            });
            
            document.getElementById('spacingSlider').addEventListener('input', e => {
                config.spacingFactor = parseInt(e.target.value) / 100;
                document.getElementById('spacingValue').textContent = config.spacingFactor.toFixed(2);
                calculatePoints();
                draw();
            });
            
            document.getElementById('showProjections').addEventListener('change', e => {
                config.showProjections = e.target.checked;
                draw();
            });
            
            document.getElementById('showRings').addEventListener('change', e => {
                config.showRings = e.target.checked;
                draw();
            });
            
            document.getElementById('showAllRings').addEventListener('change', e => {
                config.showAllRings = e.target.checked;
                draw();
            });
        }

        // Initialize
        initCanvas();
        setupListeners();
        calculatePoints();
        draw();
    </script>
</body>
</html>
