
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Channel Projection Corollary - Research Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #app {
            display: flex;
            height: 100vh;
        }
        
        #controls {
            width: 320px;
            background: #151515;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 20px;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .section {
            margin-bottom: 24px;
        }
        
        .section-title {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group {
            margin-bottom: 16px;
        }
        
        label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #333;
            color: #e0e0e0;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }
        
        button {
            padding: 8px;
            background: #222;
            border: 1px solid #333;
            color: #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s;
        }
        
        button:hover {
            background: #2a2a2a;
            border-color: #4a9eff;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .value-display {
            display: inline-block;
            float: right;
            color: #4a9eff;
            font-weight: 600;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 16px;
            font-size: 12px;
            line-height: 1.6;
            min-width: 220px;
        }
        
        #stats-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #4a9eff;
            font-weight: 500;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #4a9eff;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 250px;
        }
        
        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            font-size: 11px;
            max-width: 300px;
            display: none;
        }
        
        .point-info {
            line-height: 1.6;
            color: #e0e0e0;
        }
        
        .reduction-path {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
            color: #4a9eff;
            font-family: 'Courier New', monospace;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #151515;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
        
        .filter-section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin-top: 12px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="controls">
            <div class="section">
                <div class="section-title">Modulus Configuration</div>
                <div class="control-group">
                    <label>Modulus M: <span class="value-display" id="modulus-value">60</span></label>
                    <input type="range" id="modulus-slider" min="4" max="2000" value="60">
                </div>
                <div class="control-group">
                    <label>Custom Input (2-5000)</label>
                    <input type="number" id="modulus-input" min="2" max="5000" value="60">
                </div>
                <div class="preset-buttons">
                    <button onclick="setModulus(6)">6</button>
                    <button onclick="setModulus(12)">12</button>
                    <button onclick="setModulus(30)">30</button>
                    <button onclick="setModulus(60)">60</button>
                    <button onclick="setModulus(210)">210</button>
                    <button onclick="setModulus(2310)">2310</button>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">Visualization Mode</div>
                <div class="checkbox-group">
                    <input type="checkbox" id="show-projections" checked>
                    <label for="show-projections">Projection Lines</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="show-rings" checked>
                    <label for="show-rings">Ring View</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="show-labels">
                    <label for="show-labels">Channel Labels</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="show-multiplicity">
                    <label for="show-multiplicity">Multiplicity Annotations</label>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">Color Scheme</div>
                <select id="color-scheme">
                    <option value="channel-type">Channel Type</option>
                    <option value="spf">Smallest Prime Factor</option>
                    <option value="lpf">Largest Prime Factor</option>
                    <option value="gcd">GCD Value</option>
                    <option value="depth">Channel Depth</option>
                </select>
            </div>
            
            <div class="section">
                <div class="section-title">Display Parameters</div>
                <div class="control-group">
                    <label>Line Opacity: <span class="value-display" id="opacity-value">0.15</span></label>
                    <input type="range" id="line-opacity" min="5" max="100" value="15">
                </div>
                <div class="control-group">
                    <label>Point Size: <span class="value-display" id="size-value">5</span></label>
                    <input type="range" id="point-size" min="3" max="12" value="5">
                </div>
                <div class="control-group">
                    <label>Zoom: <span class="value-display" id="zoom-value">1.0x</span></label>
                    <input type="range" id="zoom-slider" min="50" max="1000" value="100">
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">Filters</div>
                <div class="filter-section">
                    <div class="control-group">
                        <label>Min GCD: <span class="value-display" id="min-gcd-value">1</span></label>
                        <input type="range" id="min-gcd" min="1" max="20" value="1">
                    </div>
                    <div class="control-group">
                        <label>Max GCD: <span class="value-display" id="max-gcd-value">100</span></label>
                        <input type="range" id="max-gcd" min="1" max="100" value="100">
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="show-coprime" checked>
                        <label for="show-coprime">Show Coprime (gcd=1)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="show-composite" checked>
                        <label for="show-composite">Show Composite (gcd>1)</label>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">Export</div>
                <div class="export-buttons">
                    <button onclick="exportPNG('2k')">PNG 2K</button>
                    <button onclick="exportPNG('4k')">PNG 4K</button>
                    <button onclick="exportPNG('8k')">PNG 8K</button>
                    <button onclick="exportCSV()">CSV Data</button>
                </div>
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="stats">
                <div id="stats-title">Statistics</div>
                <div class="stat-row">
                    <span class="stat-label">Modulus M:</span>
                    <span class="stat-value" id="stat-m">60</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">φ(M):</span>
                    <span class="stat-value" id="stat-phi">16</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Coprime:</span>
                    <span class="stat-value" id="stat-coprime">16</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Composite:</span>
                    <span class="stat-value" id="stat-composite">44</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Channels:</span>
                    <span class="stat-value" id="stat-channels">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Max Mult:</span>
                    <span class="stat-value" id="stat-max-mult">60</span>
                </div>
            </div>
            <div id="tooltip"></div>
            <div id="info-panel"></div>
        </div>
    </div>

    <script>
        // Mathematical utilities
        function gcd(a, b) {
            while (b) [a, b] = [b, a % b];
            return a;
        }
        
        function phi(n) {
            let result = n;
            for (let p = 2; p * p <= n; p++) {
                if (n % p === 0) {
                    while (n % p === 0) n /= p;
                    result -= result / p;
                }
            }
            if (n > 1) result -= result / n;
            return result;
        }
        
        function primeFactorization(n) {
            const factors = [];
            for (let d = 2; d * d <= n; d++) {
                while (n % d === 0) {
                    factors.push(d);
                    n /= d;
                }
            }
            if (n > 1) factors.push(n);
            return factors;
        }
        
        function smallestPrimeFactor(n) {
            if (n < 2) return 0;
            for (let i = 2; i * i <= n; i++) {
                if (n % i === 0) return i;
            }
            return n;
        }
        
        function largestPrimeFactor(n) {
            if (n < 2) return 0;
            let largest = n;
            for (let i = 2; i * i <= n; i++) {
                while (n % i === 0) {
                    largest = i;
                    n /= i;
                }
            }
            return n > 1 ? n : largest;
        }
        
        // State management
        const state = {
            M: 60,
            points: [],
            channels: new Map(),
            zoom: 1.0,
            panX: 0,
            panY: 0,
            hoveredPoint: null,
            selectedPoint: null
        };
        
        const config = {
            showProjections: true,
            showRings: true,
            showLabels: false,
            showMultiplicity: false,
            lineOpacity: 0.15,
            pointSize: 5,
            colorScheme: 'channel-type',
            minGcd: 1,
            maxGcd: 100,
            showCoprime: true,
            showComposite: true
        };
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Compute projection data
        function computeProjection() {
            const M = state.M;
            state.points = [];
            state.channels.clear();
            
            for (let r = 0; r < M; r++) {
                const g = gcd(r, M);
                const isOpen = g === 1;
                const reducedR = r / g;
                const reducedM = M / g;
                const angle = (r / M) * 2 * Math.PI;
                const spf = g > 1 ? smallestPrimeFactor(g) : (r > 1 ? smallestPrimeFactor(r) : 0);
                const lpf = g > 1 ? largestPrimeFactor(g) : (r > 1 ? largestPrimeFactor(r) : 0);
                
                const point = {
                    r, M, gcd: g, isOpen,
                    reducedR, reducedM,
                    angle, spf, lpf,
                    multiplicity: M / reducedM
                };
                
                state.points.push(point);
                
                if (!state.channels.has(reducedM)) {
                    state.channels.set(reducedM, {
                        M_prime: reducedM,
                        multiplicity: M / reducedM,
                        residues: [],
                        phi: phi(reducedM)
                    });
                }
                state.channels.get(reducedM).residues.push(r);
            }
            
            updateStatistics();
        }
        
        function updateStatistics() {
            const M = state.M;
            const phiM = phi(M);
            const coprime = state.points.filter(p => p.isOpen).length;
            const composite = M - coprime;
            const channels = state.channels.size;
            const maxMult = Math.max(...Array.from(state.channels.values()).map(c => c.multiplicity));
            
            document.getElementById('stat-m').textContent = M;
            document.getElementById('stat-phi').textContent = phiM;
            document.getElementById('stat-coprime').textContent = coprime;
            document.getElementById('stat-composite').textContent = composite;
            document.getElementById('stat-channels').textContent = channels;
            document.getElementById('stat-max-mult').textContent = maxMult;
        }
        
        // Color schemes
        function getColor(point) {
            const scheme = config.colorScheme;
            
            if (scheme === 'channel-type') {
                if (point.isOpen) return '#00ffff';
                if (point.reducedM === 1) return '#ff0000';
                return '#ffd700';
            }
            
            if (scheme === 'spf') {
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
                const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3', '#ff1493', '#00ffff', '#ff00ff'];
                const idx = primes.indexOf(point.spf);
                return idx >= 0 ? colors[idx] : '#888888';
            }
            
            if (scheme === 'lpf') {
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
                const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3', '#ff1493', '#00ffff', '#ff00ff'];
                const idx = primes.indexOf(point.lpf);
                return idx >= 0 ? colors[idx] : '#888888';
            }
            
            if (scheme === 'gcd') {
                const hue = (point.gcd * 30) % 360;
                return `hsl(${hue}, 70%, 60%)`;
            }
            
            if (scheme === 'depth') {
                const depth = Math.log(point.reducedM + 1) / Math.log(state.M + 1);
                const hue = 240 - depth * 240;
                return `hsl(${hue}, 80%, 60%)`;
            }
            
            return '#ffffff';
        }
        
        // Rendering
        function render() {
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const baseRadius = Math.min(w, h) * 0.4 * state.zoom;
            
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);
            
            // Draw projection lines
            if (config.showProjections) {
                ctx.globalAlpha = config.lineOpacity;
                for (const point of state.points) {
                    if (!shouldDisplayPoint(point)) continue;
                    if (point.isOpen) continue;
                    
                    const outerX = cx + Math.cos(point.angle - Math.PI / 2) * baseRadius;
                    const outerY = cy + Math.sin(point.angle - Math.PI / 2) * baseRadius;
                    
                    const channelRadius = baseRadius * (point.reducedM / state.M);
                    const innerAngle = (point.reducedR / point.reducedM) * 2 * Math.PI;
                    const innerX = cx + Math.cos(innerAngle - Math.PI / 2) * channelRadius;
                    const innerY = cy + Math.sin(innerAngle - Math.PI / 2) * channelRadius;
                    
                    ctx.strokeStyle = getColor(point);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(outerX, outerY);
                    ctx.lineTo(innerX, innerY);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Draw rings
            if (config.showRings) {
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                const sortedChannels = Array.from(state.channels.keys()).sort((a, b) => b - a);
                for (const M_prime of sortedChannels) {
                    const r = baseRadius * (M_prime / state.M);
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    if (config.showLabels && M_prime !== state.M) {
                        ctx.fillStyle = '#666666';
                        ctx.font = '10px monospace';
                        ctx.fillText(M_prime.toString(), cx + r + 5, cy);
                    }
                }
            }
            
            // Draw points
            for (const point of state.points) {
                if (!shouldDisplayPoint(point)) continue;
                
                const radius = point.isOpen ? baseRadius : baseRadius * (point.reducedM / state.M);
                const angle = point.isOpen ? point.angle : (point.reducedR / point.reducedM) * 2 * Math.PI;
                const x = cx + Math.cos(angle - Math.PI / 2) * radius;
                const y = cy + Math.sin(angle - Math.PI / 2) * radius;
                
                point.screenX = x;
                point.screenY = y;
                
                ctx.fillStyle = getColor(point);
                ctx.beginPath();
                ctx.arc(x, y, config.pointSize, 0, 2 * Math.PI);
                ctx.fill();
                
                if (state.hoveredPoint === point) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (state.selectedPoint === point) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, config.pointSize + 3, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
            
            // Draw multiplicity annotations
            if (config.showMultiplicity) {
                ctx.fillStyle = '#aaaaaa';
                ctx.font = '11px monospace';
                for (const [M_prime, channel] of state.channels) {
                    if (M_prime === state.M) continue;
                    const r = baseRadius * (M_prime / state.M);
                    const text = `×${channel.multiplicity}`;
                    ctx.fillText(text, cx + r + 5, cy + 15);
                }
            }
        }
        
        function shouldDisplayPoint(point) {
            if (point.gcd < config.minGcd || point.gcd > config.maxGcd) return false;
            if (point.isOpen && !config.showCoprime) return false;
            if (!point.isOpen && !config.showComposite) return false;
            return true;
        }
        
        // Interaction
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            let closestPoint = null;
            let minDist = config.pointSize + 3;
            
            for (const point of state.points) {
                if (!shouldDisplayPoint(point)) continue;
                const dx = point.screenX - x;
                const dy = point.screenY - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = point;
                }
            }
            
            if (closestPoint !== state.hoveredPoint) {
                state.hoveredPoint = closestPoint;
                render();
                
                if (closestPoint) {
                    showTooltip(closestPoint, e.clientX, e.clientY);
                } else {
                    hideTooltip();
                }
            }
        });
        
        canvas.addEventListener('click', (e) => {
            if (state.hoveredPoint) {
                state.selectedPoint = state.selectedPoint === state.hoveredPoint ? null : state.hoveredPoint;
                render();
                
                if (state.selectedPoint) {
                    showInfoPanel(state.selectedPoint);
                } else {
                    hideInfoPanel();
                }
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            state.zoom = Math.max(0.5, Math.min(10, state.zoom * delta));
            document.getElementById('zoom-slider').value = state.zoom * 100;
            document.getElementById('zoom-value').textContent = state.zoom.toFixed(1) + 'x';
            render();
        });
        
        function showTooltip(point, x, y) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div><strong>r = ${point.r}</strong></div>
                <div>gcd(${point.r}, ${point.M}) = ${point.gcd}</div>
                <div>${point.r}/${point.M} = ${point.reducedR}/${point.reducedM}</div>
                <div>Channel M' = ${point.reducedM}</div>
                <div>Multiplicity: ${point.multiplicity}</div>
            `;
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function showInfoPanel(point) {
            const panel = document.getElementById('info-panel');
            let html = `<div class="point-info">`;
            html += `<strong>Residue ${point.r} of M = ${point.M}</strong><br>`;
            html += `Status: ${point.isOpen ? 'Coprime (Open)' : 'Composite (Closed)'}<br>`;
            html += `gcd(${point.r}, ${point.M}) = ${point.gcd}<br>`;
            html += `Smallest Prime Factor: ${point.spf || 'N/A'}<br>`;
            html += `Largest Prime Factor: ${point.lpf || 'N/A'}<br>`;
            html += `</div>`;
            
            if (!point.isOpen) {
                html += `<div class="reduction-path">`;
                html += `${point.r}/${point.M} → ${point.reducedR}/${point.reducedM}<br>`;
                html += `Channel M' = ${point.reducedM}<br>`;
                html += `Multiplicity d = ${point.multiplicity}<br>`;
                html += `φ(${point.reducedM}) = ${state.channels.get(point.reducedM).phi}`;
                html += `</div>`;
            }
            
            panel.innerHTML = html;
            panel.style.display = 'block';
        }
        
        function hideInfoPanel() {
            document.getElementById('info-panel').style.display = 'none';
        }
        
        // Controls
        function setModulus(m) {
            state.M = m;
            document.getElementById('modulus-slider').value = m;
            document.getElementById('modulus-input').value = m;
            document.getElementById('modulus-value').textContent = m;
            computeProjection();
            render();
        }
        
        document.getElementById('modulus-slider').addEventListener('input', (e) => {
            setModulus(parseInt(e.target.value));
        });
        
        document.getElementById('modulus-input').addEventListener('change', (e) => {
            const val = Math.max(2, Math.min(5000, parseInt(e.target.value) || 60));
            setModulus(val);
        });
        
        document.getElementById('show-projections').addEventListener('change', (e) => {
            config.showProjections = e.target.checked;
            render();
        });
        
        document.getElementById('show-rings').addEventListener('change', (e) => {
            config.showRings = e.target.checked;
            render();
        });
        
        document.getElementById('show-labels').addEventListener('change', (e) => {
            config.showLabels = e.target.checked;
            render();
        });
        
        document.getElementById('show-multiplicity').addEventListener('change', (e) => {
            config.showMultiplicity = e.target.checked;
            render();
        });
        
        document.getElementById('color-scheme').addEventListener('change', (e) => {
            config.colorScheme = e.target.value;
            render();
        });
        
        document.getElementById('line-opacity').addEventListener('input', (e) => {
            config.lineOpacity = e.target.value / 100;
            document.getElementById('opacity-value').textContent = config.lineOpacity.toFixed(2);
            render();
        });
        
        document.getElementById('point-size').addEventListener('input', (e) => {
            config.pointSize = parseInt(e.target.value);
            document.getElementById('size-value').textContent = config.pointSize;
            render();
        });
        
        document.getElementById('zoom-slider').addEventListener('input', (e) => {
            state.zoom = e.target.value / 100;
            document.getElementById('zoom-value').textContent = state.zoom.toFixed(1) + 'x';
            render();
        });
        
        document.getElementById('min-gcd').addEventListener('input', (e) => {
            config.minGcd = parseInt(e.target.value);
            document.getElementById('min-gcd-value').textContent = config.minGcd;
            render();
        });
        
        document.getElementById('max-gcd').addEventListener('input', (e) => {
            config.maxGcd = parseInt(e.target.value);
            document.getElementById('max-gcd-value').textContent = config.maxGcd;
            render();
        });
        
        document.getElementById('show-coprime').addEventListener('change', (e) => {
            config.showCoprime = e.target.checked;
            render();
        });
        
        document.getElementById('show-composite').addEventListener('change', (e) => {
            config.showComposite = e.target.checked;
            render();
        });
        
        // Export functions
        function exportPNG(resolution) {
            const scales = { '2k': 2, '4k': 4, '8k': 8 };
            const scale = scales[resolution];
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width * scale;
            exportCanvas.height = canvas.height * scale;
            const exportCtx = exportCanvas.getContext('2d');
            
            exportCtx.scale(scale, scale);
            
            const originalCtx = ctx;
            window.ctx = exportCtx;
            render();
            window.ctx = originalCtx;
            
            exportCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `composite_channel_M${state.M}_${resolution}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            render();
        }
        
        function exportCSV() {
            let csv = `# Composite Channel Projection - Full Dataset\n`;
            csv += `# M = ${state.M}\n`;
            csv += `# φ(${state.M}) = ${phi(state.M)}\n`;
            csv += `# Channels: ${state.channels.size}\n#\n`;
            csv += `Residue,Modulus,GCD,Status,Reduced_Num,Reduced_Den,Channel,Multiplicity,Angle_Deg,SPF,LPF\n`;
            
            for (const point of state.points) {
                csv += `${point.r},${point.M},${point.gcd},${point.isOpen ? 'Open' : 'Closed'},`;
                csv += `${point.reducedR},${point.reducedM},${point.reducedM},${point.multiplicity},`;
                csv += `${(point.angle * 180 / Math.PI).toFixed(3)},${point.spf},${point.lpf}\n`;
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `composite_channel_M${state.M}_data.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize
        computeProjection();
        render();
    </script>
</body>
</html>
