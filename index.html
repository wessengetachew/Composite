
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Composite Channel Projection | Research Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --control-bar: #161b22;
            --border: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --accent-dim: rgba(88, 166, 255, 0.15);
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text-primary);
            font-family: var(--font-ui);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- TOP CONTROL BAR --- */
        #top-controls {
            flex-shrink: 0;
            padding: 10px 15px;
            background: var(--control-bar);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 50;
        }
        
        .control-group { display: flex; align-items: center; gap: 8px; }
        
        .view-switcher { display: flex; gap: 5px; }
        .view-btn {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 6px 10px; font-size: 0.7rem;
            border-radius: 4px; cursor: pointer; text-align: center;
        }
        .view-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

        input[type="number"], select {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-primary); padding: 4px 6px; border-radius: 4px;
            font-family: var(--font-mono); font-size: 0.8rem; width: 70px;
        }
        
        /* Zoom Slider Styling */
        #zoom-slider-group { width: 150px; }
        #slider-zoom { width: 100%; accent-color: var(--accent); margin: 0; height: 10px; }
        #zoom-value { font-family: var(--font-mono); font-size: 0.75rem; color: var(--accent); }

        .btn-pill {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 4px 10px; font-size: 0.7rem;
            border-radius: 4px; cursor: pointer; 
        }
        .btn-pill.primary { background: #238636; border-color: #238636; color: white; }

        /* --- STAGE (Visualization Area) --- */
        #stage {
            flex-grow: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        canvas {
            background: #050505;
            box-shadow: 0 0 0 1px var(--border);
            display: block;
        }

        /* Centered Title Overlay */
        #overlay-header {
            position: absolute; top: 20px; width: 100%; text-align: center;
            pointer-events: none;
            text-shadow: 0 2px 4px #000; z-index: 10;
        }
        h1 { margin: 0; font-size: 1.6rem; letter-spacing: -0.5px; }
        .subtitle { color: var(--text-secondary); font-family: var(--font-mono); font-size: 0.9rem; margin-top: 4px; }

        #tooltip {
            position: absolute; pointer-events: none;
            background: rgba(22, 27, 34, 0.95); border: 1px solid var(--accent);
            padding: 10px; border-radius: 6px; font-size: 0.8rem; display: none; z-index: 50;
        }
        
        /* --- BOTTOM DATA BAR (NEW LEGEND) --- */
        #bottom-data {
            flex-shrink: 0;
            padding: 10px 15px;
            background: var(--control-bar);
            border-top: 1px solid var(--border);
            z-index: 50;
            overflow-x: auto;
            white-space: nowrap;
        }

        .stat-group {
            display: inline-flex;
            gap: 20px;
            align-items: flex-start;
        }

        .channel-stats-item {
            display: inline-flex;
            flex-direction: column;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg);
            margin-right: 10px;
            min-width: 120px;
        }
        .channel-header {
            font-size: 0.75rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 3px;
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        .channel-value { font-family: var(--font-mono); font-size: 1rem; color: var(--text-primary); }
        .channel-detail { font-size: 0.65rem; color: var(--text-secondary); }

        /* Mobile specific adjustments */
        @media (max-width: 768px) {
            #top-controls { flex-wrap: wrap; justify-content: center; }
            .control-group:first-child { order: 1; width: 100%; justify-content: center; margin-bottom: 5px; }
            .control-group:nth-child(2) { order: 2; }
            .control-group:nth-child(3) { order: 3; }
            #zoom-slider-group { width: 100%; order: 4; }
            
            #bottom-data { padding: 8px 10px; }
            .stat-group { flex-wrap: nowrap; padding-bottom: 5px; }
            .channel-stats-item { min-width: 100px; padding: 5px 8px; }
        }
    </style>
</head>
<body>

<div id="intro-modal" style="display:none;">
    <div class="modal-content" id="modal-step-1">
        <h2>Composite Channel Projection</h2>
        <p>Welcome to the research visualization suite. This tool explores the geometric structure of modular arithmetic by projecting number residues onto "Farey Channels."</p>
        <p><strong>Goal:</strong> Visualize how fractions $r/M$ reduce to their simplest forms.</p>
        <button class="btn-pill primary" style="width:100%" onclick="nextStep(2)">Next: How to Use</button>
    </div>
    
    <div class="modal-content" id="modal-step-2" style="display:none">
        <h2>How to Navigate</h2>
        <p><strong>1. Main View:</strong> The visualization now fills the screen.<br>
           <strong>2. Top Bar:</strong> Contains M, View Mode, and Zoom controls.<br>
           <strong>3. Bottom Bar:</strong> Displays the **Channel Statistics** (M' and Residue Count).</p>
        <button class="btn-pill primary" style="width:100%" onclick="closeModal()">Start Exploration</button>
    </div>
</div>

<div id="top-controls">
    
    <div class="control-group">
        <label>M:</label>
        <input type="number" id="input-m" value="60" min="2" max="5000" onchange="setM(this.value)">
        <button class="btn-pill" onclick="toggleAnim()" id="btn-anim">▶ Anim</button>
    </div>

    <div class="control-group view-switcher">
        <button class="view-btn active" onclick="setView('projection')" id="btn-v-projection">Radial</button>
        <button class="view-btn" onclick="setView('rings')" id="btn-v-rings">Rings</button>
        <button class="view-btn" onclick="setView('ford')" id="btn-v-ford">Ford</button>
        <button class="view-btn" onclick="setView('lattice')" id="btn-v-lattice">Lattice</button>
    </div>
    
    <div class="control-group">
        <label>Color:</label>
        <select id="sel-color" onchange="updateConfig()">
            <option value="spectral">Spectral</option>
            <option value="type">Type</option>
            <option value="gcd">GCD</option>
        </select>
    </div>

    <div class="control-group" id="zoom-slider-group">
        <label>Zoom (<span id="zoom-value">100%</span>):</label>
        <input type="range" id="slider-zoom" min="0.1" max="10" step="0.1" value="1" oninput="setZoom(this.value)">
        <button class="btn-pill" onclick="resetView()">⟲</button>
    </div>
</div>

<div id="stage">
    <canvas id="vizCanvas"></canvas>
    
    <div id="overlay-header">
        <h1 id="disp-title">Composite Modulus M = 60</h1>
        <div id="disp-subtitle" class="subtitle">2² × 3 × 5</div>
    </div>

    <div id="tooltip"></div>
</div>

<div id="bottom-data">
    <div class="stat-group" id="channel-stats-dynamic">
        </div>
</div>

<script>
/** * UI LOGIC 
 */
function nextStep(step) {
    document.getElementById('modal-step-1').style.display = 'none';
    document.getElementById('modal-step-2').style.display = 'block';
}

function closeModal() {
    document.getElementById('intro-modal').style.display = 'none';
    resize();
}

/** * MATHEMATICAL CORE 
 */
const MathCore = {
    gcd: (a, b) => { while (b) [a, b] = [b, a % b]; return a; },
    phi: (n) => {
        let result = n;
        for (let i = 2; i * i <= n; i++) {
            if (n % i === 0) {
                while (n % i === 0) n /= i;
                result -= result / i;
            }
        }
        if (n > 1) result -= result / n;
        return result;
    },
    getFactors: (n) => {
        const f = new Set();
        let d = 2, temp = n;
        while (d * d <= temp) {
            if (temp % d === 0) { f.add(d); temp /= d; } else { d++; }
        }
        if (temp > 1) f.add(temp);
        return Array.from(f).join(" × ");
    }
};

/** * APP STATE 
 */
const State = {
    M: 60,
    residues: [],
    channels: [],
    viewMode: 'projection',
    colorMode: 'spectral',
    opacity: 0.5,
    zoom: 1.0,
    panX: 0,
    panY: 0,
    isDragging: false,
    lastMouse: {x:0, y:0},
    isAnimating: false,
    animTimer: null,
    size: 0 // Will hold the calculated square canvas size
};

/** * DATA ENGINE 
 */
function computeData() {
    const M = State.M;
    State.residues = [];
    const channelMap = {};

    for (let r = 0; r <= M; r++) {
        const effectiveR = r === 0 ? M : r;
        const d = MathCore.gcd(effectiveR, M);
        const m_prime = M / d;
        const r_prime = effectiveR / d;

        if (!channelMap[m_prime]) channelMap[m_prime] = { val: m_prime, d: d, count: 0, color: null };
        
        // Count residues from 1 to M-1
        if (r > 0 && r < M) { 
             channelMap[m_prime].count++;
        }

        State.residues.push({
            r: r, d: d, m_prime: m_prime, r_prime: r_prime,
            angle: (r / M) * Math.PI * 2 - (Math.PI / 2),
            type: d === 1 ? 'coprime' : 'reducible'
        });
    }

    State.channels = Object.values(channelMap).sort((a,b) => b.val - a.val); // Sort M' descending

    State.channels.forEach((ch, index) => {
        // Golden Ratio Color Assignment (0.618)
        const hue = ((index * 0.618033988749895) % 1) * 360;
        ch.color = `hsl(${hue}, 75%, 60%)`;
    });

    render();
    updateChannelStats();
}

/** * RENDERER (SQUARE ENGINE) 
 */
const canvas = document.getElementById('vizCanvas');
const ctx = canvas.getContext('2d');

function resize() {
    const stage = document.getElementById('stage');
    // Calculate largest possible square that fits within the stage boundaries
    const size = Math.min(stage.clientWidth, stage.clientHeight);
    
    const dpr = window.devicePixelRatio || 1;
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    
    ctx.scale(dpr, dpr);
    
    State.size = size;
    render();
}
window.addEventListener('resize', resize);

function getPointColor(res) {
    if (State.colorMode === 'type') {
        if (res.d === 1) return '#58a6ff';
        if (res.m_prime === 1) return '#ffd700';
        return '#ff6b6b';
    }
    if (State.colorMode === 'gcd') {
        if (res.d === 1) return '#58a6ff';
        return `hsl(${(res.d * 15) % 360}, 70%, 60%)`;
    }
    const ch = State.channels.find(c => c.val === res.m_prime);
    return ch ? ch.color : '#fff';
}

function render() {
    const size = State.size || 500;
    
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, size, size);

    ctx.save();
    ctx.translate(size/2 + State.panX, size/2 + State.panY);
    ctx.scale(State.zoom, State.zoom);

    if (State.viewMode === 'ford') renderFord(ctx, size);
    else if (State.viewMode === 'lattice') renderLattice(ctx, size);
    else renderRadial(ctx, size);

    ctx.restore();
    
    // UI Updates
    document.getElementById('disp-title').innerText = `Composite Modulus M = ${State.M}`;
    document.getElementById('disp-subtitle').innerText = MathCore.getFactors(State.M);
}

// MODE: RADIAL (Projection & Rings)
function renderRadial(ctx, size) {
    const baseRadius = size * 0.45 / State.zoom;

    State.channels.forEach((ch, i) => {
        const pct = (i + 1) / (State.channels.length + 1);
        let r = pct * baseRadius * State.zoom; // Scale radius based on original size
        if (ch.val === State.M) r = baseRadius * State.zoom;
        if (ch.val === 1) r = baseRadius * 0.05 * State.zoom;
        ch.renderR = r; 

        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.strokeStyle = '#30363d';
        ctx.lineWidth = 1/State.zoom;
        ctx.stroke();
    });

    State.residues.forEach(res => {
        if (res.r === 0 || res.r === State.M) return; 

        const color = getPointColor(res);
        const ch = State.channels.find(c => c.val === res.m_prime);
        const x2 = Math.cos(res.angle) * ch.renderR;
        const y2 = Math.sin(res.angle) * ch.renderR;

        if (State.viewMode === 'projection' && res.d > 1) {
            const x1 = Math.cos(res.angle) * baseRadius * State.zoom;
            const y1 = Math.sin(res.angle) * baseRadius * State.zoom;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            ctx.strokeStyle = color; ctx.lineWidth = 1/State.zoom;
            ctx.globalAlpha = State.opacity; ctx.stroke(); ctx.globalAlpha = 1.0;
        }

        ctx.beginPath(); ctx.arc(x2, y2, 3/State.zoom, 0, Math.PI*2);
        ctx.fillStyle = color; ctx.fill();
        res.hit = { x: x2, y: y2, r: 5/State.zoom };
    });
}

// MODE: FORD HORIZON 
function renderFord(ctx, size) {
    const scale = size * 0.9 / State.zoom;
    const groundY = size * 0.3 / State.zoom;
    const offsetX = -size * 0.45 / State.zoom;
    
    ctx.beginPath(); ctx.moveTo(-size/State.zoom, groundY); ctx.lineTo(size/State.zoom, groundY);
    ctx.strokeStyle = '#8b949e'; ctx.lineWidth = 2/State.zoom; ctx.stroke();

    const drawn = new Set();
    State.residues.forEach(res => {
        if (res.r === 0 || res.r === State.M) return; 

        const key = `${res.r_prime}/${res.m_prime}`;
        if (drawn.has(key)) return;
        drawn.add(key);

        const q = res.m_prime;
        const p = res.r_prime;
        const radius = (1 / (2 * q * q)) * scale * 1.5; 
        
        const x = offsetX + (p/q) * scale;
        const y = groundY - radius;

        if (radius * State.zoom < 0.5) return;

        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2);
        const ch = State.channels.find(c => c.val === q);
        ctx.fillStyle = ch.color + '80';
        ctx.fill();
        ctx.strokeStyle = ch.color;
        ctx.lineWidth = 1/State.zoom;
        ctx.stroke();
        
        res.hit = { x: x, y: y, r: radius };
    });
}

// MODE: LATTICE
function renderLattice(ctx, size) {
    const plotW = size * 0.8 / State.zoom;
    const plotH = size * 0.8 / State.zoom;
    const startX = -plotW/2;
    const startY = plotH/2;

    ctx.beginPath();
    ctx.moveTo(startX, startY); ctx.lineTo(startX+plotW, startY);
    ctx.moveTo(startX, startY); ctx.lineTo(startX, startY-plotH);
    ctx.strokeStyle = '#30363d'; ctx.lineWidth = 2/State.zoom; ctx.stroke();

    const maxPossibleGCD = State.M; 
    State.residues.forEach(res => {
        if (res.r === 0) return;

        const x = startX + (res.r / State.M) * plotW;
        const y = startY - (res.d / maxPossibleGCD) * plotH;
        const color = getPointColor(res);

        ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, y);
        ctx.strokeStyle = color; ctx.globalAlpha = 0.3; ctx.lineWidth = Math.max(1, plotW/State.M)/State.zoom;
        ctx.stroke(); ctx.globalAlpha = 1.0;

        ctx.beginPath(); ctx.arc(x, y, 3/State.zoom, 0, Math.PI*2);
        ctx.fillStyle = color; ctx.fill();
        res.hit = { x: x, y: y, r: 5/State.zoom };
    });
}

/** * INPUT HANDLERS 
 */
function setZoom(val) {
    State.zoom = parseFloat(val);
    document.getElementById('zoom-value').innerText = `${(State.zoom*100).toFixed(0)}%`;
    render();
}

function resetView() { 
    State.zoom=1.0; 
    State.panX=0; 
    State.panY=0; 
    document.getElementById('slider-zoom').value = 1.0;
    document.getElementById('zoom-value').innerText = '100%';
    render(); 
}

function setM(val) {
    State.M = parseInt(val);
    document.getElementById('input-m').value = State.M;
    // Update the slider range if necessary, but keep it centered
    computeData();
}

function setView(mode) {
    State.viewMode = mode;
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-v-${mode}`).classList.add('active');
    render();
}

function updateConfig() {
    State.colorMode = document.getElementById('sel-color').value;
    State.opacity = 0.5; // Opacity setting removed from UI, kept constant
    render();
    updateChannelStats();
}

function toggleAnim() {
    const btn = document.getElementById('btn-anim');
    if(State.isAnimating) { 
        clearInterval(State.animTimer); 
        State.isAnimating=false; 
        btn.innerHTML = '▶ Anim'; 
        btn.classList.remove('primary');
    }
    else { 
        State.isAnimating=true; 
        btn.innerHTML = '⏸ Anim';
        btn.classList.add('primary');
        State.animTimer = setInterval(() => {
            let n = State.M+1; 
            if(n>2520) n=4; 
            setM(n);
        }, 100); 
    }
}

function updateChannelStats() {
    const container = document.getElementById('channel-stats-dynamic');
    container.innerHTML = ''; 

    // Add summary stats first (M, Phi, etc.)
    let statsHTML = `
        <div class="channel-stats-item">
            <div class="channel-header" style="color:var(--accent);">M=${State.M}</div>
            <div class="channel-value">${MathCore.phi(State.M)}</div>
            <div class="channel-detail">φ(M)</div>
        </div>
        <div class="channel-stats-item">
            <div class="channel-header" style="color:var(--accent);">Channels</div>
            <div class="channel-value">${State.channels.length}</div>
            <div class="channel-detail">Count</div>
        </div>
    `;

    // Add detailed channel listing (M', Count, GCD)
    State.channels.forEach(ch => {
        // Only display channels with actual residues (Count > 0)
        if (ch.count > 0) { 
            statsHTML += `
                <div class="channel-stats-item">
                    <div class="channel-header">
                        <div class="dot" style="background:${ch.color};"></div>
                        M' = ${ch.val}
                    </div>
                    <div class="channel-value">${ch.count}</div>
                    <div class="channel-detail">GCD=${ch.d}</div>
                </div>
            `;
        }
    });
    container.innerHTML = statsHTML;
}

// Mouse/Touch Interaction
function handlePointerStart(x, y) {
    State.isDragging = true;
    State.lastMouse = { x, y };
}
function handlePointerMove(x, y) {
    if (State.isDragging) {
        // Pan amounts are relative to the screen, then inverted/scaled by zoom for canvas translation
        State.panX += (x - State.lastMouse.x);
        State.panY += (y - State.lastMouse.y);
        State.lastMouse = { x, y };
        render();
    }
    
    // Hover Test (Simplified for clarity)
    const size = State.size;
    const cx = size/2 + State.panX;
    const cy = size/2 + State.panY;
    
    // Convert screen coordinates to canvas coordinates (reverse transform)
    const mx = (x - cx) / State.zoom;
    const my = (y - cy) / State.zoom;
    
    let target = null;
    let minD = 10 / State.zoom;

    State.residues.forEach(res => {
        if (!res.hit || res.r === 0 || res.r === State.M) return;
        const dist = Math.sqrt((mx-res.hit.x)**2 + (my-res.hit.y)**2);
        const limit = Math.max(minD, res.hit.r);
        if (dist < limit) { minD = dist; target = res; }
    });

    const tip = document.getElementById('tooltip');
    if (target) {
        const rect = canvas.getBoundingClientRect();
        tip.style.display = 'block';
        tip.style.left = (rect.left + x + 10) + 'px';
        tip.style.top = (rect.top + y + 10) + 'px';
        tip.innerHTML = `r=${target.r} <span style="color:#aaa">(M'=${target.m_prime}, d=${target.d})</span>`;
    } else {
        tip.style.display = 'none';
    }
}

function handlePointerEnd() {
    State.isDragging = false;
}

// Event Listeners (Mouse + Touch)
canvas.addEventListener('mousedown', e => handlePointerStart(e.offsetX, e.offsetY));
window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    if(e.target === canvas || State.isDragging) {
        handlePointerMove(e.clientX - rect.left, e.clientY - rect.top);
    }
});
window.addEventListener('mouseup', handlePointerEnd);

// Wheel Zoom (Mouse)
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY < 0 ? 0.2 : -0.2;
    // Smoothly update slider and state
    const newZoom = Math.max(0.1, Math.min(10, State.zoom + delta));
    document.getElementById('slider-zoom').value = newZoom;
    setZoom(newZoom);
});

// Touch Support (Panning only)
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        e.preventDefault();
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        handlePointerStart(t.clientX - rect.left, t.clientY - rect.top);
    }
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && State.isDragging) {
        e.preventDefault();
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        handlePointerMove(t.clientX - rect.left, t.clientY - rect.top);
    }
}, {passive: false});

canvas.addEventListener('touchend', handlePointerEnd);

// Init
setM(State.M); // Initial data calculation
resize(); // Set initial canvas size
</script>
</body>
</html>
