
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Channel Projection | Master Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --border: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --accent-dim: rgba(88, 166, 255, 0.15);
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text-primary);
            font-family: var(--font-ui);
            display: grid;
            grid-template-columns: 1fr 360px;
            height: 100vh;
            overflow: hidden;
        }

        /* LEFT: STAGE */
        #stage {
            position: relative;
            background: #050505;
            overflow: hidden;
            cursor: default; /* Changed from crosshair */
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* Overlay UI */
        #overlay-header {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            text-shadow: 0 2px 4px #000;
        }
        h1 { margin: 0; font-size: 1.4rem; letter-spacing: -0.5px; }
        .subtitle { color: var(--text-secondary); font-family: var(--font-mono); font-size: 0.85rem; margin-top: 4px; }

        #zoom-controls {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; gap: 5px; background: rgba(22, 27, 34, 0.8);
            padding: 5px; border-radius: 6px; border: 1px solid var(--border);
        }

        .icon-btn {
            background: transparent; border: none; color: var(--text-primary);
            width: 28px; height: 28px; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.2rem;
        }
        .icon-btn:hover { background: var(--border); }

        /* RIGHT: PANEL */
        #panel {
            background: var(--panel);
            border-left: 1px solid var(--border);
            display: flex; flex-direction: column;
            overflow-y: auto;
        }

        .section { padding: 15px 20px; border-bottom: 1px solid var(--border); }
        .section-title {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--text-secondary); margin-bottom: 12px; font-weight: 700;
        }

        /* Controls */
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .control-row label { font-size: 0.85rem; color: var(--text-secondary); }
        
        select, input[type="number"] {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-primary); padding: 4px 8px; border-radius: 4px;
            font-family: var(--font-mono); font-size: 0.85rem;
        }
        
        input[type="range"] { width: 100%; accent-color: var(--accent); margin: 10px 0; }

        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 8px; }
        .btn-pill {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 6px; font-size: 0.75rem;
            border-radius: 4px; cursor: pointer; transition: 0.1s;
        }
        .btn-pill:hover { border-color: var(--text-primary); color: var(--text-primary); }
        .btn-pill.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }

        /* View Mode Switcher */
        .view-switcher {
            display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 15px;
        }
        .view-btn {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 8px; font-size: 0.75rem;
            border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 6px;
        }
        .view-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
        .view-btn svg { width: 14px; height: 14px; fill: currentColor; }

        .action-btn {
            width: 100%; background: var(--bg); border: 1px solid var(--border);
            color: var(--text-primary); padding: 8px; border-radius: 4px;
            cursor: pointer; margin-bottom: 8px; font-size: 0.85rem;
        }
        .action-btn:hover { background: var(--border); }
        .action-btn.primary { background: #238636; border-color: #238636; color: white; font-weight: 600; }

        .stat-row { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 6px; }
        .stat-val { font-family: var(--font-mono); color: var(--accent); }

        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; margin-bottom: 6px; color: var(--text-secondary); }
        .dot { width: 8px; height: 8px; border-radius: 50%; }

        #tooltip {
            position: absolute; pointer-events: none;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid var(--accent);
            padding: 8px 12px; border-radius: 4px;
            font-size: 0.8rem; display: none; z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<div id="stage">
    <canvas id="vizCanvas"></canvas>
    
    <div id="overlay-header">
        <h1 id="disp-title">M = 60</h1>
        <div id="disp-subtitle" class="subtitle">2² × 3 × 5</div>
        <div id="disp-zoom" class="subtitle" style="color:var(--accent); margin-top:2px;">Zoom: 100%</div>
    </div>

    <div id="zoom-controls">
        <button class="icon-btn" onclick="adjustZoom(-0.1)">-</button>
        <button class="icon-btn" onclick="resetView()">⟲</button>
        <button class="icon-btn" onclick="adjustZoom(0.1)">+</button>
    </div>

    <div id="tooltip"></div>
</div>

<div id="panel">
    <div class="section">
        <div class="section-title">Modulus Configuration</div>
        <div class="control-row">
            <input type="number" id="input-m" value="60" min="2" max="5000">
            <button class="btn-pill" style="width:auto; padding:4px 12px;" onclick="toggleAnim()" id="btn-anim">▶ Play Sequence</button>
        </div>
        <input type="range" id="slider-m" min="4" max="2520" value="60">
        <div class="btn-grid">
            <button class="btn-pill" onclick="setM(12)">12</button>
            <button class="btn-pill" onclick="setM(60)">60</button>
            <button class="btn-pill" onclick="setM(210)">210</button>
            <button class="btn-pill" onclick="setM(2520)">2520</button>
        </div>
    </div>

    <div class="section">
        <div class="section-title">Projection Mode</div>
        
        <div class="view-switcher">
            <button class="view-btn active" onclick="setView('projection')" id="btn-v-projection">
                <span>Projection</span>
            </button>
            <button class="view-btn" onclick="setView('rings')" id="btn-v-rings">
                <span>Ring Channels</span>
            </button>
            <button class="view-btn" onclick="setView('ford')" id="btn-v-ford">
                <span>Ford Horizon</span>
            </button>
            <button class="view-btn" onclick="setView('lattice')" id="btn-v-lattice">
                <span>Lattice Map</span>
            </button>
        </div>

        <div class="control-row">
            <label>Color</label>
            <select id="sel-color" onchange="updateConfig()">
                <option value="spectral">Spectral Channels</option>
                <option value="type">Residue Type</option>
                <option value="gcd">Gradient by GCD</option>
            </select>
        </div>

        <div class="control-row">
            <label>Labels</label>
            <select id="sel-label" onchange="updateConfig()">
                <option value="none">None</option>
                <option value="gcd">Integer (GCD)</option>
                <option value="frac">Fraction (r/M)</option>
            </select>
        </div>

        <div class="control-row">
            <label>Opacity</label>
            <input type="range" style="width:80px" min="0.1" max="1" step="0.1" value="0.5" id="rng-opacity" oninput="updateConfig()">
        </div>
    </div>

    <div class="section">
        <div class="section-title">Channel Analytics</div>
        <div class="stat-row"><span>Euler Totient φ(M)</span><span class="stat-val" id="val-phi">-</span></div>
        <div class="stat-row"><span>Active Channels</span><span class="stat-val" id="val-channels">-</span></div>
        <div class="stat-row"><span>Max Depth (GCD)</span><span class="stat-val" id="val-depth">-</span></div>
    </div>

    <div class="section">
        <div class="section-title">Legend</div>
        <div id="legend-dynamic"></div>
    </div>

    <div class="section" style="border-bottom:none">
        <div class="section-title">Export Research Data</div>
        <div style="display:flex; gap:5px;">
            <button class="action-btn" onclick="exportPNG('2k')">PNG 2K</button>
            <button class="action-btn primary" onclick="exportPNG('4k')">PNG 4K</button>
        </div>
        <button class="action-btn" onclick="exportCSV()">Download Dataset (CSV)</button>
    </div>

    <div style="margin-top:auto; padding:20px; text-align:center; font-size:0.7rem; color:var(--text-secondary); border-top:1px solid var(--border);">
        <strong>Composite Channel Projection</strong><br>
        Analysis Tool by Wessen Getachew
    </div>
</div>

<script>
/** CORE LOGIC **/
const MathCore = {
    gcd: (a, b) => { while (b) [a, b] = [b, a % b]; return a; },
    phi: (n) => {
        let result = n;
        for (let i = 2; i * i <= n; i++) {
            if (n % i === 0) {
                while (n % i === 0) n /= i;
                result -= result / i;
            }
        }
        if (n > 1) result -= result / n;
        return result;
    },
    getFactors: (n) => {
        const f = new Set();
        let d = 2, temp = n;
        while (d * d <= temp) {
            if (temp % d === 0) { f.add(d); temp /= d; } else { d++; }
        }
        if (temp > 1) f.add(temp);
        return Array.from(f).join(" × ");
    }
};

/** APP STATE **/
const State = {
    M: 60,
    residues: [],
    channels: [],
    viewMode: 'projection', // projection, rings, ford, lattice
    colorMode: 'spectral',
    labelMode: 'none',
    opacity: 0.5,
    zoom: 1,
    panX: 0,
    panY: 0,
    isDragging: false,
    lastMouse: {x:0, y:0},
    isolatedChannel: null,
    isAnimating: false,
    animTimer: null
};

/** DATA ENGINE **/
function computeData() {
    const M = State.M;
    State.residues = [];
    const channelMap = {};

    for (let r = 0; r <= M; r++) { // Include 0 and M for Ford Circles
        const effectiveR = r === 0 ? M : r;
        const d = MathCore.gcd(effectiveR, M);
        const m_prime = M / d;
        const r_prime = effectiveR / d;

        if (r > 0 && r < M) { // Stats only count 1 to M-1 typically for analysis
            if (!channelMap[m_prime]) {
                channelMap[m_prime] = { val: m_prime, d: d, count: 0, color: null };
            }
            channelMap[m_prime].count++;
        }
        
        // Ensure channel exists even if only edges hit it (rare)
        if (!channelMap[m_prime]) channelMap[m_prime] = { val: m_prime, d: d, count: 0, color: null };

        State.residues.push({
            r: r,
            d: d,
            m_prime: m_prime,
            r_prime: r_prime,
            angle: (r / M) * Math.PI * 2 - (Math.PI / 2),
            type: d === 1 ? 'coprime' : 'reducible'
        });
    }

    State.channels = Object.values(channelMap).sort((a,b) => a.val - b.val);

    // Golden Ratio Color Assignment
    State.channels.forEach((ch, index) => {
        const hue = ((index * 0.618033988749895) % 1) * 360;
        ch.color = `hsl(${hue}, 75%, 60%)`;
    });

    updateStats();
    render();
}

/** RENDERER **/
const canvas = document.getElementById('vizCanvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = document.getElementById('stage').clientWidth;
    canvas.height = document.getElementById('stage').clientHeight;
    render();
}
window.addEventListener('resize', resize);

function getPointColor(res) {
    if (State.colorMode === 'type') {
        if (res.d === 1) return '#58a6ff';
        if (res.m_prime === 1) return '#ffd700';
        return '#ff6b6b';
    }
    if (State.colorMode === 'gcd') {
        if (res.d === 1) return '#58a6ff';
        return `hsl(${(res.d * 15) % 360}, 70%, 60%)`;
    }
    const ch = State.channels.find(c => c.val === res.m_prime);
    return ch ? ch.color : '#fff';
}

function render(exportCtx = null, exportSize = null) {
    const context = exportCtx || ctx;
    const width = exportSize ? exportSize.w : canvas.width;
    const height = exportSize ? exportSize.h : canvas.height;
    
    // Clear
    context.fillStyle = exportCtx ? '#0d1117' : '#050505';
    context.fillRect(0, 0, width, height);

    const zoom = exportCtx ? 1 : State.zoom;
    const panX = exportCtx ? 0 : State.panX;
    const panY = exportCtx ? 0 : State.panY;

    context.save();
    context.translate(width/2 + panX, height/2 + panY);
    context.scale(zoom, zoom);
    
    // Dispatch Render Mode
    if (State.viewMode === 'ford') renderFord(context, width, height, zoom, !!exportCtx);
    else if (State.viewMode === 'lattice') renderLattice(context, width, height, zoom, !!exportCtx);
    else renderRadial(context, width, height, zoom, !!exportCtx); // Projection or Rings

    context.restore();
}

// MODE 1 & 2: Radial (Projection / Rings)
function renderRadial(ctx, w, h, zoom, isExport) {
    const minDim = Math.min(w, h) / (isExport ? 1 : zoom); // Cancel zoom for base calc
    const baseRadius = minDim * (isExport ? 0.35 : 0.4);
    
    // Draw Rings
    State.channels.forEach((ch, i) => {
        if (State.isolatedChannel && State.isolatedChannel !== ch.val) return;
        const pct = (i + 1) / (State.channels.length + 1);
        let r = pct * baseRadius;
        if (ch.val === State.M) r = baseRadius;
        if (ch.val === 1) r = baseRadius * 0.05;
        ch.renderR = r; 

        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.strokeStyle = State.isolatedChannel ? ch.color : '#30363d';
        ctx.lineWidth = isExport ? 2 : 1/zoom;
        ctx.stroke();
    });

    // Draw Points
    State.residues.forEach(res => {
        if (res.r === 0 || res.r === State.M) return; // Skip 0/M for radial
        if (State.isolatedChannel && State.isolatedChannel !== res.m_prime) return;

        const color = getPointColor(res);
        const ch = State.channels.find(c => c.val === res.m_prime);
        const x2 = Math.cos(res.angle) * ch.renderR;
        const y2 = Math.sin(res.angle) * ch.renderR;

        // Projection Lines
        if (State.viewMode === 'projection' && res.d > 1) {
            const x1 = Math.cos(res.angle) * baseRadius;
            const y1 = Math.sin(res.angle) * baseRadius;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = isExport ? 1.5 : 1/zoom;
            ctx.globalAlpha = State.opacity;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        ctx.beginPath();
        ctx.arc(x2, y2, (isExport?5:3)/Math.sqrt(zoom), 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
        
        // Hit data
        if (!isExport) res.hit = { x: x2, y: y2, r: 5/zoom };
    });
}

// MODE 3: Ford Horizon (Geometric Number Theory)
function renderFord(ctx, w, h, zoom, isExport) {
    const scale = w * 0.8; 
    const offsetX = -w * 0.4;
    const groundY = h * 0.3; // Lower third

    // Draw Ground
    ctx.beginPath();
    ctx.moveTo(-w, groundY);
    ctx.lineTo(w, groundY);
    ctx.strokeStyle = '#8b949e';
    ctx.lineWidth = 2/zoom;
    ctx.stroke();

    const drawnFractions = new Set(); // Avoid overdraw

    State.residues.forEach(res => {
        if (State.isolatedChannel && State.isolatedChannel !== res.m_prime) return;

        const key = `${res.r_prime}/${res.m_prime}`;
        if (drawnFractions.has(key)) return;
        drawnFractions.add(key);

        const q = res.m_prime;
        const p = res.r_prime;

        // Ford Radius Formula: R = 1 / (2 * q^2)
        // Scaled up for visibility
        const radius = (1 / (2 * q * q)) * scale;
        
        // Position: x = p/q
        const x = offsetX + (p/q) * scale;
        const y = groundY - radius;

        if (radius * zoom < 0.5) return; // Culling

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        
        const ch = State.channels.find(c => c.val === q);
        ctx.fillStyle = ch.color + '80'; // Add transparency
        ctx.fill();
        ctx.strokeStyle = ch.color;
        ctx.lineWidth = 1/zoom;
        ctx.stroke();

        if (!isExport) res.hit = { x: x, y: y, r: radius };
    });
}

// MODE 4: Lattice Map (Divisor Skyline)
function renderLattice(ctx, w, h, zoom, isExport) {
    const margin = 40/zoom;
    const plotW = w * 0.8;
    const plotH = h * 0.6;
    const startX = -plotW/2;
    const startY = plotH/2;

    // Grid Axes
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(startX + plotW, startY); // X Axis
    ctx.moveTo(startX, startY);
    ctx.lineTo(startX, startY - plotH); // Y Axis
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 2/zoom;
    ctx.stroke();

    State.residues.forEach(res => {
        if (res.r === 0) return;
        if (State.isolatedChannel && State.isolatedChannel !== res.m_prime) return;

        // X = Residue Index, Y = GCD Value
        const x = startX + (res.r / State.M) * plotW;
        const normY = res.d / State.M; // GCD relative to M
        // Logarithmic scale for Y usually looks better, but Linear shows the towers better
        const y = startY - (res.d / State.channels[State.channels.length-1].d) * plotH;

        const color = getPointColor(res);

        // Draw Stick (Skyline)
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, y);
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = Math.max(1, (plotW/State.M))/zoom;
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        // Draw Dot
        ctx.beginPath();
        ctx.arc(x, y, (isExport?4:2)/Math.sqrt(zoom), 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();

        if (!isExport) res.hit = { x: x, y: y, r: 5/zoom };
    });
}

/** INTERACTION **/
// Mouse & Zoom Logic (Identical to Pro Suite, updated for hit detection offset)
const stage = document.getElementById('stage');
stage.addEventListener('wheel', e => { e.preventDefault(); adjustZoom(e.deltaY>0?-0.1:0.1); });

function adjustZoom(amt) {
    State.zoom = Math.max(0.1, Math.min(10, State.zoom + amt*State.zoom));
    document.getElementById('disp-zoom').innerText = `Zoom: ${(State.zoom*100).toFixed(0)}%`;
    render();
}
function resetView() { State.zoom=1; State.panX=0; State.panY=0; render(); }

canvas.addEventListener('mousedown', e => { State.isDragging=true; State.lastMouse={x:e.clientX, y:e.clientY}; });
window.addEventListener('mouseup', () => State.isDragging=false);
window.addEventListener('mousemove', e => {
    if(State.isDragging) {
        State.panX += e.clientX - State.lastMouse.x;
        State.panY += e.clientY - State.lastMouse.y;
        State.lastMouse = {x:e.clientX, y:e.clientY};
        render();
    }
    handleHover(e);
});

function handleHover(e) {
    const rect = canvas.getBoundingClientRect();
    // Transform mouse into context coordinates
    const cx = rect.width/2 + State.panX;
    const cy = rect.height/2 + State.panY;
    const mx = (e.clientX - rect.left - cx) / State.zoom;
    const my = (e.clientY - rect.top - cy) / State.zoom;

    let minD = 10 / State.zoom;
    let target = null;

    // Check residues
    State.residues.forEach(res => {
        if (!res.hit) return;
        const dx = mx - res.hit.x;
        const dy = my - res.hit.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        // Hit radius check depends on mode
        const hitR = res.hit.r || 5/State.zoom;
        if (dist < Math.max(minD, hitR)) {
            minD = dist;
            target = res;
        }
    });

    const tip = document.getElementById('tooltip');
    if (target) {
        tip.style.display = 'block';
        tip.style.left = (e.clientX+15)+'px';
        tip.style.top = (e.clientY+15)+'px';
        const color = getPointColor(target);
        tip.innerHTML = `
            <strong style="color:${color}">Residue ${target.r}</strong><br>
            <small style="color:#aaa">M'=${target.m_prime} | GCD=${target.d}</small>
        `;
    } else {
        tip.style.display = 'none';
    }
}

/** CONTROL HANDLERS **/
function setM(m) {
    State.M = parseInt(m);
    document.getElementById('input-m').value = State.M;
    document.getElementById('slider-m').value = State.M;
    document.getElementById('disp-title').innerText = `M = ${State.M}`;
    document.getElementById('disp-subtitle').innerText = MathCore.getFactors(State.M);
    computeData();
    updateLegend();
}
function setView(mode) {
    State.viewMode = mode;
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-v-${mode}`).classList.add('active');
    render();
}
function updateConfig() {
    State.colorMode = document.getElementById('sel-color').value;
    State.labelMode = document.getElementById('sel-label').value;
    State.opacity = parseFloat(document.getElementById('rng-opacity').value);
    render();
    updateLegend();
}
function updateStats() {
    document.getElementById('val-phi').innerText = MathCore.phi(State.M);
    document.getElementById('val-channels').innerText = State.channels.length;
    document.getElementById('val-depth').innerText = State.channels[0] ? State.channels[State.channels.length-1].d : 0;
}
function updateLegend() {
    const el = document.getElementById('legend-dynamic');
    el.innerHTML = '';
    if (State.colorMode === 'spectral') {
        el.innerHTML = '<div style="font-style:italic; font-size:0.75rem; margin-bottom:5px">Distinct Farey Channels</div>';
        State.channels.slice(0, 5).forEach(ch => {
            el.innerHTML += `<div class="legend-item"><div class="dot" style="background:${ch.color}"></div>M' = ${ch.val}</div>`;
        });
        if(State.channels.length > 5) el.innerHTML += `<div class="legend-item" style="opacity:0.5">... ${State.channels.length-5} more</div>`;
    }
}
function toggleAnim() {
    if(State.isAnimating) { clearInterval(State.animTimer); State.isAnimating=false; }
    else { State.isAnimating=true; State.animTimer = setInterval(() => {
        let n = State.M+1; if(n>2520) n=4; setM(n);
    }, 100); }
}

// Export logic remains mostly same, just pass context
function exportPNG(res) {
    const size = res==='4k'?4096:2048;
    const cvs = document.createElement('canvas');
    cvs.width = size; cvs.height = size*0.75;
    const ctx = cvs.getContext('2d');
    
    // Draw Background
    ctx.fillStyle = '#0d1117'; ctx.fillRect(0,0,size,size*0.75);
    
    // Render Scene (Left 75%)
    render(ctx, {w:size*0.75, h:size*0.75});
    
    // Sidebar
    const margin = size*0.03; const sx = size*0.75;
    ctx.fillStyle = '#0d1117'; ctx.fillRect(sx,0,size*0.25,size*0.75);
    ctx.fillStyle = '#f0f6fc'; ctx.font = `bold ${size*0.025}px sans-serif`;
    ctx.fillText(`M = ${State.M}`, sx+margin, margin+size*0.05);
    ctx.font = `${size*0.012}px monospace`; ctx.fillStyle = '#8b949e';
    ctx.fillText(MathCore.getFactors(State.M), sx+margin, margin+size*0.08, size*0.22);
    
    // Signature
    const by = size*0.75 - margin;
    ctx.fillStyle = '#f0f6fc'; ctx.font=`bold ${size*0.015}px sans-serif`;
    ctx.fillText("Wessen Getachew", sx+margin, by);
    ctx.fillStyle = '#8b949e'; ctx.font=`${size*0.012}px sans-serif`;
    ctx.fillText("Composite Channel Projection", sx+margin, by+size*0.02);

    const l = document.createElement('a');
    l.download = `Analysis_M${State.M}_${State.viewMode}.png`;
    l.href = cvs.toDataURL(); l.click();
}

function exportCSV() {
    let csv = "Residue,Modulus,GCD,Channel,Fraction,Angle\n";
    State.residues.forEach(r => csv+=`${r.r},${State.M},${r.d},${r.m_prime},${r.r_prime}/${r.m_prime},${r.angle}\n`);
    const blob = new Blob([csv],{type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const l = document.createElement('a'); l.href=url; l.download=`Data_M${State.M}.csv`; l.click();
}

// Start
document.getElementById('input-m').addEventListener('change', e=>setM(e.target.value));
document.getElementById('slider-m').addEventListener('input', e=>setM(e.target.value));
computeData();
</script>
</body>
</html>

