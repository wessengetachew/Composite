
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Channel Projection Corollary - Advanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #000000;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 2560px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 15px 0;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #333;
        }
        
        h1 {
            font-size: 2em;
            margin-bottom: 5px;
            color: #ffffff;
        }
        
        .controls {
            background: #111111;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #333;
        }
        
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .section-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: 600;
            font-size: 0.9em;
            color: #cccccc;
        }
        
        input[type="number"], select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222222;
            color: #ffffff;
            font-size: 0.95em;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            outline: none;
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 18px;
            border: none;
            border-radius: 4px;
            background: linear-gradient(135deg, #00ffff 0%, #0088ff 100%);
            color: #000;
            font-size: 0.95em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .canvas-container {
            background: #000000;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            border: 1px solid #333;
            position: relative;
        }
        
        canvas {
            border: 2px solid #333333;
            border-radius: 4px;
            background: #000000;
            cursor: crosshair;
        }
        
        .info-panel {
            background: #111111;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .stat-box {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #333;
        }
        
        .stat-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ffff;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px;
            border-radius: 6px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 350px;
            font-size: 0.9em;
            line-height: 1.5;
            border: 1px solid #00ffff;
        }
        
        .selected-info {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            border: 1px solid #00ffff;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid white;
        }
        
        .slider-value {
            display: inline-block;
            min-width: 40px;
            text-align: center;
            color: #00ffff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Composite Channel Projection Corollary</h1>
        </header>
        
        <div class="controls">
            <div class="control-section">
                <div class="section-title">Basic Configuration</div>
                <div class="control-grid">
                    <div class="control-group">
                        <label for="modulus">Modulus (M):</label>
                        <input type="number" id="modulus" min="2" max="500" value="30">
                    </div>
                    
                    <div class="control-group">
                        <label for="displayMode">Display Mode:</label>
                        <select id="displayMode">
                            <option value="projection">Projection Lines</option>
                            <option value="all">All Points Only</option>
                            <option value="reducible">Reducible Only</option>
                            <option value="irreducible">Irreducible Only</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="colorScheme">Color Scheme:</label>
                        <select id="colorScheme">
                            <option value="channel">By Channel Type</option>
                            <option value="gcd">By GCD Value</option>
                            <option value="denominator">By Denominator</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">Visual Controls</div>
                <div class="control-grid">
                    <div class="control-group">
                        <label>Point Size: <span class="slider-value" id="pointSizeValue">8</span></label>
                        <input type="range" id="pointSize" min="3" max="20" value="8">
                    </div>
                    
                    <div class="control-group">
                        <label>Zoom: <span class="slider-value" id="zoomValue">100%</span></label>
                        <input type="range" id="zoom" min="50" max="300" value="100">
                    </div>
                    
                    <div class="control-group">
                        <label>Ring Spacing: <span class="slider-value" id="spacingValue">1.0</span></label>
                        <input type="range" id="spacing" min="50" max="200" value="100">
                    </div>
                    
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="showLabels" checked>
                        <label for="showLabels">Show r Labels</label>
                    </div>
                    
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="showGcdLabels" checked>
                        <label for="showGcdLabels">Show GCD Labels</label>
                    </div>
                    
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="showModLabels">
                        <label for="showModLabels">Show M' Labels</label>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">Animation Controls</div>
                <div class="control-grid">
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="animateRotation">
                        <label for="animateRotation">Enable Rotation</label>
                    </div>
                    
                    <div class="control-group">
                        <label for="rotationMode">Rotation Mode:</label>
                        <select id="rotationMode">
                            <option value="uniform">Uniform</option>
                            <option value="innerToOuter">Inner → Outer</option>
                            <option value="outerToInner">Outer → Inner</option>
                            <option value="individual">Individual Mods</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Speed: <span class="slider-value" id="speedValue">1.0</span></label>
                        <input type="range" id="rotationSpeed" min="10" max="200" value="100">
                    </div>
                    
                    <div class="control-group">
                        <label for="trackPoint">Track Point (r):</label>
                        <input type="number" id="trackPoint" min="0" max="500" value="" placeholder="None">
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">Export & Actions</div>
                <div class="button-group">
                    <button onclick="updateVisualization()">Update</button>
                    <button onclick="exportPNG()">Export PNG (1080p)</button>
                    <button onclick="exportPNG4K()">Export PNG (4K)</button>
                    <button onclick="exportCSV()">Export CSV Data</button>
                    <button onclick="randomModulus()">Random M</button>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="mainCanvas" width="1920" height="1080"></canvas>
        </div>
        
        <div class="info-panel">
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Modulus M</div>
                    <div class="stat-value" id="currentM">30</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Prime Factorization</div>
                    <div class="stat-value" id="factorization">2×3×5</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">φ(M) - Irreducible</div>
                    <div class="stat-value" id="phiM">8</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Reducible Residues</div>
                    <div class="stat-value" id="reducibleCount">22</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Reducibility Ratio</div>
                    <div class="stat-value" id="reducibilityRatio">73.3%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Farey Channels</div>
                    <div class="stat-value" id="channelCount">7</div>
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ffff;"></div>
                    <span>Cyan = Irreducible (gcd=1)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0066;"></div>
                    <span>Red = Reducible (gcd>1)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd700;"></div>
                    <span>Gold = Farey Channels</span>
                </div>
            </div>
            
            <div class="selected-info" id="selectedInfo" style="display:none;">
                <div id="selectedContent"></div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        
        let currentData = null;
        let animationFrame = null;
        let rotationAngle = 0;
        let trackedPoint = null;
        
        function gcd(a, b) {
            while (b !== 0) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        
        function eulerPhi(n) {
            let result = n;
            let p = 2;
            let temp = n;
            while (p * p <= temp) {
                if (temp % p === 0) {
                    while (temp % p === 0) temp /= p;
                    result -= result / p;
                }
                p++;
            }
            if (temp > 1) result -= result / temp;
            return Math.floor(result);
        }
        
        function primeFactorization(n) {
            const factors = {};
            let temp = n;
            for (let i = 2; i * i <= temp; i++) {
                while (temp % i === 0) {
                    factors[i] = (factors[i] || 0) + 1;
                    temp /= i;
                }
            }
            if (temp > 1) factors[temp] = 1;
            
            return Object.entries(factors)
                .map(([p, e]) => e > 1 ? `${p}^${e}` : p)
                .join('×') || n.toString();
        }
        
        function lowestTerms(r, m) {
            if (r === 0) return [0, 1];
            const d = gcd(r, m);
            return [r / d, m / d];
        }
        
        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }
        
        function computeModulusData(M) {
            const data = {
                M: M,
                isPrime: isPrime(M),
                phi: eulerPhi(M),
                factorization: primeFactorization(M),
                residues: [],
                channels: new Map(),
                gcdGroups: new Map(),
                irreducible: [],
                reducible: []
            };
            
            for (let r = 0; r < M; r++) {
                const [rRed, mRed] = lowestTerms(r, M);
                const d = gcd(r, M);
                const isIrreducible = (d === 1);
                
                const point = {
                    r: r,
                    rRed: rRed,
                    mRed: mRed,
                    d: d,
                    isIrreducible: isIrreducible,
                    channel: `${rRed}/${mRed}`,
                    theta: (2 * Math.PI * r) / M
                };
                
                data.residues.push(point);
                
                if (isIrreducible) {
                    data.irreducible.push(point);
                } else {
                    data.reducible.push(point);
                }
                
                const channelKey = point.channel;
                if (!data.channels.has(channelKey)) {
                    data.channels.set(channelKey, []);
                }
                data.channels.get(channelKey).push(point);
                
                if (!data.gcdGroups.has(d)) {
                    data.gcdGroups.set(d, []);
                }
                data.gcdGroups.get(d).push(point);
            }
            
            return data;
        }
        
        function getColorForPoint(pt, colorScheme, data) {
            if (colorScheme === 'channel') {
                return pt.isIrreducible ? '#00ffff' : '#ff0066';
            } else if (colorScheme === 'gcd') {
                const gcdColors = ['#00ffff', '#ff0066', '#00ff00', '#ffff00', '#ff00ff', '#ff8800', '#0088ff', '#88ff00'];
                return gcdColors[pt.d % gcdColors.length];
            } else if (colorScheme === 'denominator') {
                const hue = (pt.mRed * 137.5) % 360;
                return `hsl(${hue}, 100%, 50%)`;
            }
            return '#00ffff';
        }
        
        function drawVisualization() {
            if (!currentData) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const zoom = parseFloat(document.getElementById('zoom').value) / 100;
            const spacing = parseFloat(document.getElementById('spacing').value) / 100;
            const baseRadius = Math.min(canvas.width, canvas.height) * 0.35 * zoom;
            
            const M = currentData.M;
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const showLabels = document.getElementById('showLabels').checked;
            const showGcdLabels = document.getElementById('showGcdLabels').checked;
            const showModLabels = document.getElementById('showModLabels').checked;
            const displayMode = document.getElementById('displayMode').value;
            const colorScheme = document.getElementById('colorScheme').value;
            const animateRotation = document.getElementById('animateRotation').checked;
            const rotationMode = document.getElementById('rotationMode').value;
            const trackPointValue = parseInt(document.getElementById('trackPoint').value);
            
            // Get unique divisors for ring layout
            const divisors = new Set();
            currentData.residues.forEach(pt => divisors.add(pt.mRed));
            const sortedDivisors = Array.from(divisors).sort((a, b) => b - a);
            const divisorToRadius = new Map();
            sortedDivisors.forEach((d, idx) => {
                divisorToRadius.set(d, baseRadius * (1 - idx * 0.08 * spacing));
            });
            
            // Draw projection lines
            if (displayMode === 'projection') {
                ctx.globalAlpha = 0.3;
                currentData.channels.forEach((points, channel) => {
                    if (points.length > 1 && channel !== '0/1') {
                        const firstPt = points[0];
                        const radius = divisorToRadius.get(firstPt.mRed);
                        
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        
                        points.forEach((pt, idx) => {
                            let angle = pt.theta;
                            if (animateRotation) {
                                if (rotationMode === 'individual') {
                                    angle += rotationAngle / pt.mRed;
                                } else if (rotationMode === 'innerToOuter') {
                                    angle += rotationAngle * (1 / pt.mRed);
                                } else if (rotationMode === 'outerToInner') {
                                    angle += rotationAngle * pt.mRed;
                                } else {
                                    angle += rotationAngle;
                                }
                            }
                            angle -= Math.PI / 2;
                            
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY + radius * Math.sin(angle);
                            
                            if (idx === 0) {
                                ctx.moveTo(centerX, centerY);
                            }
                            ctx.lineTo(x, y);
                        });
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw rings for each divisor
            sortedDivisors.forEach(d => {
                if (d === 1) return;
                const radius = divisorToRadius.get(d);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                if (showModLabels) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(`M'=${d}`, centerX + radius + 5, centerY);
                }
            });
            
            // Draw outer circle
            const outerRadius = divisorToRadius.get(M) || baseRadius;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw points
            currentData.residues.forEach(pt => {
                let shouldDraw = true;
                if (displayMode === 'reducible' && pt.isIrreducible) shouldDraw = false;
                if (displayMode === 'irreducible' && !pt.isIrreducible) shouldDraw = false;
                
                if (!shouldDraw) return;
                
                const radius = divisorToRadius.get(pt.mRed) || outerRadius;
                let angle = pt.theta;
                
                if (animateRotation) {
                    if (rotationMode === 'individual') {
                        angle += rotationAngle / pt.mRed;
                    } else if (rotationMode === 'innerToOuter') {
                        angle += rotationAngle * (1 / pt.mRed);
                    } else if (rotationMode === 'outerToInner') {
                        angle += rotationAngle * pt.mRed;
                    } else {
                        angle += rotationAngle;
                    }
                }
                angle -= Math.PI / 2;
                
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const color = getColorForPoint(pt, colorScheme, currentData);
                
                // Highlight tracked point
                let size = pointSize;
                if (!isNaN(trackPointValue) && pt.r === trackPointValue) {
                    size *= 1.8;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, size + 4, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Labels
                if (showLabels && M <= 100) {
                    ctx.fillStyle = 'white';
                    ctx.font = '9px monospace';
                    ctx.textAlign = 'center';
                    const labelRadius = radius + 15;
                    const labelX = centerX + labelRadius * Math.cos(angle);
                    const labelY = centerY + labelRadius * Math.sin(angle);
                    ctx.fillText(`${pt.r}`, labelX, labelY);
                }
                
                if (showGcdLabels && !pt.isIrreducible && M <= 80) {
                    ctx.fillStyle = '#ff0066';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`d=${pt.d}`, x, y - size - 6);
                }
            });
            
            // Center info
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`M = ${M}`, centerX, centerY - 20);
            
            ctx.font = '14px sans-serif';
            ctx.fillText(`φ(M) = ${currentData.phi}`, centerX, centerY + 5);
            ctx.fillText(currentData.isPrime ? 'PRIME' : 'COMPOSITE', centerX, centerY + 25);
        }
        
        function updateVisualization() {
            const M = parseInt(document.getElementById('modulus').value);
            currentData = computeModulusData(M);
            
            // Update stats
            document.getElementById('currentM').textContent = M;
            document.getElementById('factorization').textContent = currentData.factorization;
            document.getElementById('phiM').textContent = currentData.phi;
            document.getElementById('reducibleCount').textContent = M - currentData.phi;
            document.getElementById('reducibilityRatio').textContent = 
                ((M - currentData.phi) / M * 100).toFixed(1) + '%';
            document.getElementById('channelCount').textContent = currentData.channels.size - 1; // exclude 0/1
            
            // Update track point max
            document.getElementById('trackPoint').max = M - 1;
            
            drawVisualization();
        }
        
        function animate() {
            if (document.getElementById('animateRotation').checked) {
                const speed = parseFloat(document.getElementById('rotationSpeed').value) / 1000;
                rotationAngle += speed;
                drawVisualization();
                animationFrame = requestAnimationFrame(animate);
            }
        }
        
        function exportPNG() {
            exportCanvas(1920, 1080, '1080p');
        }
        
        function exportPNG4K() {
            exportCanvas(3840, 2160, '4K');
        }
        
        function exportCanvas(width, height, label) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            const scale = width / canvas.width;
            tempCtx.scale(scale, scale);
            tempCtx.drawImage(canvas, 0, 0);
            
            // Add title
            tempCtx.setTransform(1, 0, 0, 1, 0, 0);
            tempCtx.fillStyle = 'white';
            tempCtx.font = 'bold 40px Arial';
            tempCtx.textAlign = 'center';
            tempCtx.fillText('Composite Channel Projection Corollary', width / 2, 50);
            
            tempCtx.font = '24px Arial';
            tempCtx.fillText(`M = ${currentData.M} | φ(M) = ${currentData.phi} | Generated: ${new Date().toLocaleString()}`, 
                width / 2, 90);
            
            const link = document.createElement('a');
            link.download = `composite_projection_M${currentData.M}_${label}_${Date.now()}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
        }
        
        function exportCSV() {
            if (!currentData) return;
            
            let csv = 'r,theta,rRed,mRed,d,channel,isIrreducible\n';
            currentData.residues.forEach(pt => {
                csv += `${pt.r},${pt.theta.toFixed(6)},${pt.rRed},${pt.mRed},${pt.d},"${pt.channel}",${pt.isIrreducible}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `composite_channel_data_M${currentData.M}.csv`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function randomModulus() {
            const M = Math.floor(Math.random() * 499) + 2;
            document.getElementById('modulus').value = M;
            updateVisualization();
        }
        
        // Event listeners
        document.getElementById('modulus').addEventListener('input', updateVisualization);
        document.getElementById('displayMode').addEventListener('change', drawVisualization);
        document.getElementById('colorScheme').addEventListener('change', drawVisualization);
        document.getElementById('showLabels').addEventListener('change', drawVisualization);
        document.getElementById('showGcdLabels').addEventListener('change', drawVisualization);
        document.getElementById('showModLabels').addEventListener('change', drawVisualization);
        document.getElementById('trackPoint').addEventListener('input', drawVisualization);
        
        document.getElementById('pointSize').addEventListener('input', (e) => {
            document.getElementById('pointSizeValue').textContent = e.target.value;
            drawVisualization();
        });
        
        document.getElementById('zoom').addEventListener('input', (e) => {
            document.getElementById('zoomValue').textContent = e.target.value + '%';
            drawVisualization();
        });
        
        document.getElementById('spacing').addEventListener('input', (e) => {
            document.getElementById('spacingValue').textContent = (e.target.value / 100).toFixed(1);
            drawVisualization();
        });
        
        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = (e.target.value / 100).toFixed(1);
        });
        
        document.getElementById('animateRotation').addEventListener('change', (e) => {
            if (e.target.checked) {
                rotationAngle = 0;
                animate();
            } else {
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
                drawVisualization();
            }
        });
        
        document.getElementById('rotationMode').addEventListener('change', drawVisualization);
        
        // Mouse events
        canvas.addEventListener('mousemove', (e) => {
            if (!currentData) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const zoom = parseFloat(document.getElementById('zoom').value) / 100;
            const baseRadius = Math.min(canvas.width, canvas.height) * 0.35 * zoom;
            
            let hoveredPoint = null;
            let minDist = Infinity;
            
            currentData.residues.forEach(pt => {
                const divisors = new Set();
                currentData.residues.forEach(p => divisors.add(p.mRed));
                const sortedDivisors = Array.from(divisors).sort((a, b) => b - a);
                const spacing = parseFloat(document.getElementById('spacing').value) / 100;
                
                let radius = baseRadius;
                const idx = sortedDivisors.indexOf(pt.mRed);
                if (idx >= 0) {
                    radius = baseRadius * (1 - idx * 0.08 * spacing);
                }
                
                let angle = pt.theta - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                if (dist < minDist && dist < 15) {
                    minDist = dist;
                    hoveredPoint = pt;
                }
            });
            
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
                tooltip.innerHTML = `
                    <strong>r = ${hoveredPoint.r}</strong><br>
                    θ = ${hoveredPoint.theta.toFixed(4)} rad<br>
                    Fraction: ${hoveredPoint.r}/${currentData.M}<br>
                    Reduces to: <strong>${hoveredPoint.rRed}/${hoveredPoint.mRed}</strong><br>
                    gcd(${hoveredPoint.r}, ${currentData.M}) = ${hoveredPoint.d}<br>
                    Status: ${hoveredPoint.isIrreducible ? '<span style="color:#00ffff">Irreducible</span>' : '<span style="color:#ff0066">Reducible</span>'}<br>
                    Channel: ${hoveredPoint.channel}
                `;
            } else {
                tooltip.style.display = 'none';
            }
        });
        
        canvas.addEventListener('click', (e) => {
            if (!currentData) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const zoom = parseFloat(document.getElementById('zoom').value) / 100;
            const baseRadius = Math.min(canvas.width, canvas.height) * 0.35 * zoom;
            
            let clickedPoint = null;
            let minDist = Infinity;
            
            currentData.residues.forEach(pt => {
                const divisors = new Set();
                currentData.residues.forEach(p => divisors.add(p.mRed));
                const sortedDivisors = Array.from(divisors).sort((a, b) => b - a);
                const spacing = parseFloat(document.getElementById('spacing').value) / 100;
                
                let radius = baseRadius;
                const idx = sortedDivisors.indexOf(pt.mRed);
                if (idx >= 0) {
                    radius = baseRadius * (1 - idx * 0.08 * spacing);
                }
                
                let angle = pt.theta - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                if (dist < minDist && dist < 15) {
                    minDist = dist;
                    clickedPoint = pt;
                }
            });
            
            if (clickedPoint) {
                const channelPoints = currentData.channels.get(clickedPoint.channel);
                const channelInfo = channelPoints.map(p => p.r).join(', ');
                
                document.getElementById('selectedInfo').style.display = 'block';
                document.getElementById('selectedContent').innerHTML = `
                    <h3 style="color:#00ffff; margin-bottom:10px">Selected Point: r = ${clickedPoint.r}</h3>
                    <p><strong>Original Fraction:</strong> ${clickedPoint.r}/${currentData.M}</p>
                    <p><strong>Reduced Fraction:</strong> ${clickedPoint.rRed}/${clickedPoint.mRed}</p>
                    <p><strong>GCD:</strong> gcd(${clickedPoint.r}, ${currentData.M}) = ${clickedPoint.d}</p>
                    <p><strong>Theta:</strong> ${clickedPoint.theta.toFixed(6)} radians</p>
                    <p><strong>Status:</strong> ${clickedPoint.isIrreducible ? '<span style="color:#00ffff">Irreducible</span>' : '<span style="color:#ff0066">Reducible</span>'}</p>
                    <p><strong>Channel ${clickedPoint.channel}:</strong> Contains ${channelPoints.length} point(s)</p>
                    <p><strong>Channel Members:</strong> {${channelInfo}}</p>
                `;
            }
        });
        
        // Initialize
        updateVisualization();
    </script>
</body>
</html>
