
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Reduction Projection Explorer - Enhanced</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --main-color: #0f4c75;
            --accent-color: #3282b8;
            --text-color: #bbe1fa;
            --border-color: #2c394b;
            --highlight-color: #ffd700;
            --success-color: #00ff88;
            --warning-color: #ff6b6b;
            --font-mono: 'Fira Code', 'Monospace', monospace;
            --font-sans: 'Roboto', 'Arial', sans-serif;
        }

        * { box-sizing: border-box; }

        body {
            font-family: var(--font-sans);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            min-height: 100vh;
            overflow-x: hidden;
            flex-direction: column;
        }

        header {
            background-color: var(--main-color);
            padding: 15px 30px;
            text-align: center;
            border-bottom: 3px solid var(--accent-color);
            position: relative;
        }

        h1 {
            margin: 0;
            font-size: 1.8em;
            color: var(--highlight-color);
        }

        h2 {
            margin: 5px 0 0 0;
            font-size: 1.1em;
            color: var(--text-color);
        }

        .keyboard-hint {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: #999;
        }

        .container {
            display: flex;
            flex-grow: 1;
        }

        .sidebar {
            width: 320px;
            padding: 20px;
            background-color: var(--border-color);
            overflow-y: auto;
            border-right: 2px solid var(--accent-color);
            flex-shrink: 0;
        }

        .content {
            flex-grow: 1;
            padding: 10px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }

        canvas {
            border: 5px solid var(--highlight-color);
            background-color: #000;
            border-radius: 10px;
            display: block;
            touch-action: none;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid var(--accent-color);
            border-radius: 5px;
        }

        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--highlight-color);
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: calc(100% - 60px);
            vertical-align: middle;
        }

        input[type="number"], select, input[type="text"] {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background-color: var(--bg-color);
            border: 1px solid var(--accent-color);
            color: var(--text-color);
            border-radius: 3px;
            box-sizing: border-box;
        }

        .slider-value {
            font-family: var(--font-mono);
            color: var(--highlight-color);
            width: 40px;
            text-align: right;
            display: inline-block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background-color: var(--main-color);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.85em;
            text-align: center;
        }

        .stat-box strong {
            display: block;
            font-size: 1.2em;
            color: var(--highlight-color);
            font-family: var(--font-mono);
        }

        button {
            padding: 10px 15px;
            background-color: var(--accent-color);
            color: var(--text-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 10px;
            width: 100%;
            font-size: 0.9em;
        }

        button:hover {
            background-color: var(--main-color);
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .button-grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 5px;
            font-size: 0.8em;
            margin: 0;
        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.95);
            color: var(--text-color);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 100;
            font-family: var(--font-mono);
            font-size: 0.8em;
            border: 1px solid var(--highlight-color);
            display: none;
            max-width: 300px;
        }
        
        .tooltip-line {
            line-height: 1.4;
        }

        .analysis-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(26, 26, 46, 0.95);
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            padding: 15px;
            max-width: 350px;
            z-index: 50;
            display: none;
        }

        .analysis-panel h4 {
            margin: 0 0 10px 0;
            color: var(--highlight-color);
        }

        .analysis-panel.visible {
            display: block;
        }

        .analysis-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .analysis-row:last-child {
            border-bottom: none;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .color-swatch {
            width: 100%;
            height: 30px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .color-swatch:hover {
            border-color: var(--highlight-color);
        }

        .info-badge {
            display: inline-block;
            background-color: var(--accent-color);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75em;
            margin-left: 5px;
        }

        .prime-badge {
            background-color: var(--success-color);
            color: #000;
        }

        .composite-badge {
            background-color: var(--warning-color);
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: auto;
                border-right: none;
                border-bottom: 2px solid var(--accent-color);
                order: 2;
            }

            .content {
                order: 1;
            }

            .keyboard-hint {
                display: none;
            }
        }

        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-header::after {
            content: '‚ñº';
            font-size: 0.8em;
        }

        .collapsible-header.collapsed::after {
            content: '‚ñ∂';
        }

        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        .recording-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--warning-color);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .recording-indicator.active {
            display: block;
        }
    </style>
</head>
<body>

    <header>
        <h1 id="disp-title">Modular Reduction Projection: M = 42</h1>
        <h2 id="disp-subtitle">2 √ó 3 √ó 7</h2>
        <div class="keyboard-hint">Press ? for shortcuts</div>
    </header>

    <div class="container">
        <div class="sidebar">

            <div class="control-group">
                <h3>Animation Controls</h3>
                <div class="button-grid">
                    <button id="playButton" onclick="startSequence()">‚ñ∂Ô∏è Play</button>
                    <button id="stopButton" onclick="stopSequence()" disabled>‚è∏Ô∏è Stop</button>
                </div>
                <label for="speedSlider" style="margin-top: 10px;">Speed (<span id="speedValue">500</span>ms)</label>
                <input type="range" id="speedSlider" min="50" max="2000" step="50" value="500">
                
                <label style="margin-top: 10px;"><input type="checkbox" id="autoLoop" checked> Loop Animation</label>
                <label><input type="checkbox" id="recordFrames"> Record Frames</label>
            </div>

            <div class="control-group">
                <h3>Modulus M (<span id="modulusValue">42</span>)</h3>
                <input type="range" id="modulusSlider" min="2" max="5000" value="42">
                <input type="number" id="modulusInput" value="42" min="2" max="10000">
                
                <div class="preset-grid">
                    <button class="preset-btn" onclick="setModulus(12)">12</button>
                    <button class="preset-btn" onclick="setModulus(30)">30</button>
                    <button class="preset-btn" onclick="setModulus(60)">60</button>
                    <button class="preset-btn" onclick="setModulus(210)">210</button>
                    <button class="preset-btn" onclick="setModulus(420)">420</button>
                    <button class="preset-btn" onclick="setModulus(2310)">2310</button>
                    <button class="preset-btn" onclick="setModulus(17)">17 (P)</button>
                    <button class="preset-btn" onclick="setModulus(101)">101 (P)</button>
                    <button class="preset-btn" onclick="setModulus(1024)">1024 (2¬π‚Å∞)</button>
                </div>
            </div>

            <div class="control-group">
                <h3>View Controls</h3>
                <label for="zoomSlider">Zoom (<span id="zoomValue">1.00</span>x)</label>
                <input type="range" id="zoomSlider" min="10" max="1000" step="10" value="100">
                <button onclick="resetView()">Reset View (R)</button>
                <button onclick="toggleAnalysisPanel()">Toggle Analysis (A)</button>
            </div>

            <div class="control-group">
                <h3 class="collapsible-header" onclick="toggleCollapse(this)">Statistics</h3>
                <div class="collapsible-content">
                    <div class="stats-grid">
                        <div class="stat-box">M: <strong><span id="modulusStat">42</span></strong></div>
                        <div class="stat-box">œÜ(M): <strong><span id="phiValue">12</span></strong></div>
                        <div class="stat-box">Irreducible: <strong><span id="irreducibleCount">12</span></strong></div>
                        <div class="stat-box">Reducible: <strong><span id="reducibleCount">30</span></strong></div>
                        <div class="stat-box">Channels: <strong><span id="channelCount">8</span></strong></div>
                        <div class="stat-box">œâ(M): <strong><span id="omegaValue">3</span></strong></div>
                        <div class="stat-box">Divisors: <strong><span id="divisorCount">8</span></strong></div>
                        <div class="stat-box">Density: <strong><span id="densityValue">28.6%</span></strong></div>
                        <div class="stat-box" style="grid-column: 1 / -1;">
                            Factorization: <strong id="factorization">2 √ó 3 √ó 7</strong>
                            <span id="primeStatus" class="info-badge composite-badge">Composite</span>
                        </div>
                    </div>
                    
                    <h4 style="margin: 15px 0 5px 0; color: var(--highlight-color);">Prime Constellations</h4>
                    <div class="stats-grid">
                        <div class="stat-box">Twin (2): <strong><span id="twinCount">3</span></strong></div>
                        <div class="stat-box">Cousin (4): <strong><span id="cousinCount">2</span></strong></div>
                        <div class="stat-box">Sexy (6): <strong><span id="sexyCount">3</span></strong></div>
                        <div class="stat-box">Gap 8: <strong><span id="gap8Count">1</span></strong></div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="collapsible-header" onclick="toggleCollapse(this)">Appearance</h3>
                <div class="collapsible-content">
                    <label for="colorScheme">Color Scheme</label>
                    <select id="colorScheme">
                        <option value="channel-type" selected>Reduction Type</option>
                        <option value="spf">Smallest Prime Factor</option>
                        <option value="lpf">Largest Prime Factor</option>
                        <option value="gcd">GCD Value</option>
                        <option value="depth">Channel Depth</option>
                        <option value="rainbow">Rainbow (by r)</option>
                    </select>

                    <label for="pointDisplayMode" style="margin-top: 10px;">Point Display</label>
                    <select id="pointDisplayMode">
                        <option value="dots" selected>Dots</option>
                        <option value="integer">Residue (r)</option>
                        <option value="fraction">Fraction (r/M)</option>
                        <option value="theta_deg">Angle (¬∞)</option>
                    </select>
                    
                    <label for="pointSizeSlider" style="margin-top: 10px;">Point Size (<span id="pointSizeValue">3.00</span>)</label>
                    <input type="range" id="pointSizeSlider" min="1" max="10" step="0.5" value="3">
                    
                    <label for="textSizeSlider" style="margin-top: 10px;">Text Size (<span id="textSizeValue">10</span>)</label>
                    <input type="range" id="textSizeSlider" min="6" max="20" step="1" value="10">

                    <label for="opacitySlider" style="margin-top: 10px;">Projection Opacity (<span id="opacityValue">1.00</span>)</label>
                    <input type="range" id="opacitySlider" min="0" max="100" step="1" value="100">

                    <label style="margin-top: 10px;"><input type="checkbox" id="showBackground"> Show Background Grid</label>
                    <label><input type="checkbox" id="antiAlias" checked> Anti-Aliasing</label>
                </div>
            </div>

            <div class="control-group">
                <h3 class="collapsible-header" onclick="toggleCollapse(this)">Ring Spacing</h3>
                <div class="collapsible-content">
                    <label for="spacingSlider">Inner Ring Spacing (<span id="spacingValue">1.00</span>)</label>
                    <input type="range" id="spacingSlider" min="0" max="200" step="1" value="100">
                    <small style="color: #999;">Adjusts radial distribution of channel rings</small>
                </div>
            </div>

            <div class="control-group">
                <h3 class="collapsible-header" onclick="toggleCollapse(this)">Visualization</h3>
                <div class="collapsible-content">
                    <label><input type="checkbox" id="showProjections" checked> Projection Lines</label>
                    <label><input type="checkbox" id="showRings" checked> Channel Rings</label>
                    <label><input type="checkbox" id="showAngles"> Angle Guides</label>

                    <label for="labelType" style="margin-top: 10px;">Ring Labels</label>
                    <select id="labelType">
                        <option value="none">None</option>
                        <option value="farey">Channel M'</option>
                        <option value="gcd">GCD Divisor (d)</option>
                        <option value="both">Both</option>
                    </select>
                    
                    <label for="gapType" style="margin-top: 10px;">Constellation Highlight</label>
                    <select id="gapType">
                        <option value="none" selected>None</option>
                        <option value="2">Twin (Gap 2)</option>
                        <option value="4">Cousin (Gap 4)</option>
                        <option value="6">Sexy (Gap 6)</option>
                        <option value="8">Gap 8</option>
                        <option value="10">Gap 10</option>
                        <option value="12">Gap 12</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="collapsible-header" onclick="toggleCollapse(this)">Inner Rings</h3>
                <div class="collapsible-content">
                    <label><input type="checkbox" id="showAllRings" checked> Show Inner Rings</label>
                    <label><input type="checkbox" id="colorAllRings"> Color Inner Points</label>
                    <label><input type="checkbox" id="highlightCoprime"> Highlight Coprime Only</label>
                    
                    <label for="selectedRings" style="margin-top: 10px;">Filter by M'</label>
                    <input type="text" id="selectedRings" placeholder="All">
                    
                    <label for="minRing" style="margin-top: 10px;">Min M': <span id="minRingValue">1</span></label>
                    <input type="range" id="minRing" min="1" max="100" value="1">
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="collapsible-header" onclick="toggleCollapse(this)">Data Export</h3>
                <div class="collapsible-content">
                    <label for="exportResolution">Resolution (px)</label>
                    <input type="number" id="exportResolution" value="2000" min="500" max="8000">
                    
                    <div class="button-grid-3">
                        <button onclick="exportImage()">üñºÔ∏è PNG</button>
                        <button onclick="exportCSV()">üìú CSV</button>
                        <button onclick="exportJSON()">üíª JSON</button>
                    </div>
                    
                    <button onclick="exportFrameSequence()">üé¨ Frame Sequence</button>
                    <button onclick="copyToClipboard()">üìã Copy Data</button>
                </div>
            </div>

        </div>

        <div class="content">
            <div class="recording-indicator" id="recordingIndicator">‚óè Recording</div>
            
            <div class="analysis-panel" id="analysisPanel">
                <h4>Channel Analysis</h4>
                <div id="analysisContent"></div>
            </div>
            
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div id="tooltip"></div>
            </div>
        </div>
    </div>

    <script>
        // Math utilities
        function gcd(a, b) { while (b !== 0) { const temp = b; b = a % b; a = temp; } return a; }
        function phi(n) { let result = n; let p = 2; while (p * p <= n) { if (n % p === 0) { while (n % p === 0) n /= p; result -= result / p; } p++; } if (n > 1) result -= result / n; return Math.round(result); }
        function isPrime(n) { if (n < 2) return false; if (n === 2) return true; if (n % 2 === 0) return false; for (let i = 3; i * i <= n; i += 2) { if (n % i === 0) return false; } return true; }
        function omega(n) { let count = 0; let p = 2; while (p * p <= n) { if (n % p === 0) { count++; while (n % p === 0) n /= p; } p++; } if (n > 1) count++; return count; }
        
        function primeFactorization(n) {
            const factors = [];
            let d = 2;
            while (n > 1) {
                let count = 0;
                while (n % d === 0) { count++; n /= d; }
                if (count > 0) factors.push({ prime: d, power: count });
                d++;
                if (d * d > n && n > 1) { factors.push({ prime: n, power: 1 }); break; }
            }
            return factors;
        }
        
        function formatFactorization(factors) {
            return factors.map(f => {
                if (f.power === 1) return f.prime.toString();
                const superscripts = '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ';
                const powerStr = f.power.toString().split('').map(d => superscripts[parseInt(d)]).join('');
                return `${f.prime}${powerStr}`;
            }).join(' √ó ');
        }
        
        function getDivisors(n) {
            const divisors = new Set();
            for (let i = 1; i * i <= n; i++) {
                if (n % i === 0) {
                    divisors.add(i);
                    divisors.add(n / i);
                }
            }
            return Array.from(divisors).sort((a, b) => a - b);
        }
        
        function smallestPrimeFactor(n) {
            if (n <= 1) return 1;
            if (n % 2 === 0) return 2;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return i;
            }
            return n;
        }
        
        function largestPrimeFactor(n) {
            let largest = -1;
            let temp = n;
            while (temp % 2 === 0) { largest = 2; temp /= 2; }
            for (let i = 3; i * i <= temp; i += 2) {
                while (temp % i === 0) { largest = i; temp /= i; }
            }
            if (temp > 2) largest = temp;
            return largest;
        }

        // Configuration
        let config = {
            modulus: 42,
            colorScheme: 'channel-type',
            opacity: 1.0,
            pointSize: 3,
            labelType: 'none',
            pointDisplayMode: 'dots',
            textSize: 10,
            showProjections: true,
            showAllRings: true,
            showRings: true,
            showAngles: false,
            showBackground: false,
            colorAllRings: false,
            highlightCoprime: false,
            selectedRings: null,
            gapType: 'none',
            spacingFactor: 1.0,
            zoom: 1.0,
            panX: 0,
            panY: 0,
            animationSpeed: 500,
            autoLoop: true,
            recordFrames: false,
            antiAlias: true,
            minRing: 1
        };

        // State
        let canvas, ctx;
        let points = [];
        let channels = new Map();
        let allRingPoints = new Map();
        let gapPairs = { '2': [], '4': [], '6': [], '8': [], '10': [], '12': [] };
        let hoveredPoint = null;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        let sequenceInterval = null;
        let recordedFrames = [];

        // Color schemes
        const colorSchemes = {
            'channel-type': (p) => p.isOpen ? '#00ffff' : '#ff1493',
            'spf': (p) => p.isOpen ? '#00ffff' : colorMap(p.spf, 6),
            'lpf': (p) => p.isOpen ? '#00ffff' : colorMap(p.lpf, 5),
            'gcd': (p) => colorGradient(p.gcd, config.modulus, '#8250df', '#ff1493'),
            'depth': (p) => colorHue(p.reducedM, config.modulus),
            'rainbow': (p) => `hsl(${(p.r / p.M) * 360}, 70%, 60%)`
        };
        
        function colorMap(val, count) {
            const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
            const primeIndex = primes.indexOf(val) % count;
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
            return colors[primeIndex] || '#ffffff';
        }
        
        function colorGradient(val, max, colorA, colorB) {
            const pct = val / max;
            const rA = parseInt(colorA.slice(1, 3), 16), gA = parseInt(colorA.slice(3, 5), 16), bA = parseInt(colorA.slice(5, 7), 16);
            const rB = parseInt(colorB.slice(1, 3), 16), gB = parseInt(colorB.slice(3, 5), 16), bB = parseInt(colorB.slice(5, 7), 16);
            const r = Math.round(rA + (rB - rA) * pct);
            const g = Math.round(gA + (gB - gA) * pct);
            const b = Math.round(bA + (bB - bA) * pct);
            return `rgb(${r},${g},${b})`;
        }
        
        function colorHue(val, max) { return `hsl(${(val / max) * 360}, 70%, 60%)`; }

        // Animation functions
        function handleSequence() {
            let nextModulus = config.modulus + 1;
            const max = parseInt(document.getElementById('modulusSlider').max);
            
            if (nextModulus > max) {
                if (config.autoLoop) {
                    nextModulus = 2;
                } else {
                    stopSequence();
                    return;
                }
            }
            
            setModulus(nextModulus);
            
            if (config.recordFrames) {
                recordFrame();
            }
        }

        function startSequence() {
            if (sequenceInterval === null) {
                sequenceInterval = setInterval(handleSequence, config.animationSpeed);
                document.getElementById('playButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                
                if (config.recordFrames) {
                    recordedFrames = [];
                    document.getElementById('recordingIndicator').classList.add('active');
                }
            }
        }

        function stopSequence() {
            if (sequenceInterval !== null) {
                clearInterval(sequenceInterval);
                sequenceInterval = null;
                document.getElementById('playButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
                document.getElementById('recordingIndicator').classList.remove('active');
                
                if (config.recordFrames && recordedFrames.length > 0) {
                    console.log(`Recorded ${recordedFrames.length} frames`);
                }
            }
        }

        function recordFrame() {
            const dataURL = canvas.toDataURL('image/png');
            recordedFrames.push({ modulus: config.modulus, dataURL });
        }

        function resetView() {
            config.zoom = 1.0;
            config.panX = 0;
            config.panY = 0;
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = '1.00';
            draw();
        }

        function toggleAnalysisPanel() {
            const panel = document.getElementById('analysisPanel');
            panel.classList.toggle('visible');
            if (panel.classList.contains('visible')) {
                updateAnalysisPanel();
            }
        }

        function updateAnalysisPanel() {
            const content = document.getElementById('analysisContent');
            const channelArray = Array.from(channels.entries()).sort((a, b) => a[0] - b[0]);
            
            let html = '';
            channelArray.forEach(([m_prime, ch]) => {
                html += `
                    <div class="analysis-row">
                        <span>M' = ${m_prime}</span>
                        <span>${ch.count} points (√ó${ch.multiplicity})</span>
                    </div>
                `;
            });
            
            content.innerHTML = html;
        }

        function toggleCollapse(header) {
            header.classList.toggle('collapsed');
            const content = header.nextElementSibling;
            content.classList.toggle('collapsed');
        }

        // Data calculation
        function calculatePoints() {
            const M = config.modulus;
            points = [];
            channels = new Map();
            allRingPoints.clear();
            
            Object.keys(gapPairs).forEach(key => gapPairs[key] = []);

            const coprimeSet = new Set();
            for (let r = 0; r < M; r++) {
                const g = gcd(r, M);
                const isOpen = g === 1;
                const reducedR = r / g;
                const reducedM = M / g;
                const angle = (2 * Math.PI * r) / M;
                const spf = smallestPrimeFactor(g === 1 ? M : g);
                const lpf = largestPrimeFactor(g === 1 ? M : g);

                if (isOpen) coprimeSet.add(r);

                points.push({
                    r, M, gcd: g, isOpen, reducedR, reducedM, angle, spf, lpf,
                    screenX: 0, screenY: 0, hitR: config.pointSize
                });

                if (!channels.has(reducedM)) {
                    channels.set(reducedM, {
                        M_prime: reducedM,
                        multiplicity: M / reducedM,
                        residues: [],
                        count: 0
                    });
                }
                channels.get(reducedM).residues.push(r);
                channels.get(reducedM).count++;
            }

            getDivisors(M).forEach(d => {
                if (d < config.minRing) return;
                
                const ringPoints = [];
                for (let r = 0; r < d; r++) {
                    const g = gcd(r, d);
                    ringPoints.push({
                        r, M: d, gcd: g, isOpen: g === 1,
                        reducedR: r / g, reducedM: d / g,
                        angle: (2 * Math.PI * r) / d,
                        spf: smallestPrimeFactor(g === 1 ? d : g),
                        lpf: largestPrimeFactor(g === 1 ? d : g)
                    });
                }
                allRingPoints.set(d, ringPoints);
            });

            for (let gap = 2; gap <= 12; gap += 2) {
                const addedPairKeys = new Set();
                for (let r = 0; r < M; r++) {
                    const r2 = (r + gap) % M;
                    if (coprimeSet.has(r) && coprimeSet.has(r2)) {
                        const key = [r, r2].sort((a, b) => a - b).join('-');
                        if (!addedPairKeys.has(key)) {
                            addedPairKeys.add(key);
                            gapPairs[gap].push([r, r2]);
                        }
                    }
                }
            }

            updateStatistics();
        }

        function updateStatistics() {
            const M = config.modulus;
            const factors = primeFactorization(M);
            const phiM = phi(M);
            const omegaM = omega(M);
            const irreducible = points.filter(p => p.isOpen).length;
            const reducible = points.filter(p => !p.isOpen).length;
            const divisors = getDivisors(M);
            const density = (phiM / M * 100).toFixed(1);
            const prime = isPrime(M);

            document.getElementById('modulusValue').textContent = M;
            document.getElementById('modulusInput').value = M;
            document.getElementById('modulusStat').textContent = M;
            
            document.getElementById('disp-title').textContent = `Modular Reduction Projection: M = ${M}`;
            document.getElementById('disp-subtitle').textContent = formatFactorization(factors);
            
            document.getElementById('phiValue').textContent = phiM;
            document.getElementById('omegaValue').textContent = omegaM;
            document.getElementById('irreducibleCount').textContent = irreducible;
            document.getElementById('reducibleCount').textContent = reducible;
            document.getElementById('channelCount').textContent = channels.size;
            document.getElementById('divisorCount').textContent = divisors.length;
            document.getElementById('densityValue').textContent = density + '%';
            document.getElementById('factorization').textContent = formatFactorization(factors);
            
            const primeStatus = document.getElementById('primeStatus');
            if (prime) {
                primeStatus.textContent = 'Prime';
                primeStatus.className = 'info-badge prime-badge';
            } else {
                primeStatus.textContent = 'Composite';
                primeStatus.className = 'info-badge composite-badge';
            }
            
            document.getElementById('twinCount').textContent = gapPairs[2].length;
            document.getElementById('cousinCount').textContent = gapPairs[4].length;
            document.getElementById('sexyCount').textContent = gapPairs[6].length;
            document.getElementById('gap8Count').textContent = gapPairs[8].length;
            
            if (document.getElementById('analysisPanel').classList.contains('visible')) {
                updateAnalysisPanel();
            }
        }

        // Drawing functions
        function drawPointAsText(ctx, x, y, text, color, fontSize) {
            ctx.fillStyle = color;
            ctx.font = `${fontSize}px var(--font-mono)`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x, y);
        }

        function getPointDisplayText(point) {
            switch (config.pointDisplayMode) {
                case 'integer': return point.r.toString();
                case 'fraction': return `${point.r}/${point.M}`;
                case 'theta_deg': return ((point.angle * 180 / Math.PI) % 360).toFixed(0) + '¬∞';
                default: return null;
            }
        }

        function getPointColor(p) {
            const scheme = colorSchemes[config.colorScheme];
            if (typeof scheme === 'function') {
                return scheme(p);
            }
            return p.isOpen ? '#00ffff' : '#ff1493';
        }

        function draw(exportCtx = null, exportScale = 1) {
            const isInteractive = exportCtx === null;
            const drawCtx = exportCtx || ctx;
            const dpr = window.devicePixelRatio || 1;
            
            const canvasWidth = isInteractive ? canvas.width : canvas.width / dpr * exportScale;
            const canvasHeight = isInteractive ? canvas.height : canvas.height / dpr * exportScale;
            const size = canvasWidth / (isInteractive ? dpr : 1);
            const centerX = size / 2;
            const centerY = size / 2;
            const baseRadius = size * 0.45;

            drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            if (isInteractive) {
                drawCtx.fillStyle = '#000';
                drawCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
            
            drawCtx.save();
            
            const currentZoom = isInteractive ? config.zoom : 1;
            const panX = isInteractive ? config.panX : 0;
            const panY = isInteractive ? config.panY : 0;
            const scaleFactor = isInteractive ? 1 : exportScale;

            drawCtx.translate(centerX * scaleFactor, centerY * scaleFactor);
            drawCtx.scale(currentZoom * scaleFactor, currentZoom * scaleFactor);
            drawCtx.translate(panX, panY);
            
            if (config.antiAlias) {
                drawCtx.imageSmoothingEnabled = true;
                drawCtx.imageSmoothingQuality = 'high';
            }
            
            const scaledLineWidth = 1 / currentZoom;
            const scaledPointSize = config.pointSize / currentZoom;
            const scaledTextSize = config.textSize / currentZoom;
            const labelSpacing = 5 / currentZoom;
            const labelLineHeight = 6 / currentZoom;

            // Background grid
            if (config.showBackground && isInteractive) {
                drawCtx.strokeStyle = '#222';
                drawCtx.lineWidth = 0.5 * scaledLineWidth;
                for (let i = -10; i <= 10; i++) {
                    drawCtx.beginPath();
                    drawCtx.moveTo(i * baseRadius / 5, -baseRadius);
                    drawCtx.lineTo(i * baseRadius / 5, baseRadius);
                    drawCtx.stroke();
                    
                    drawCtx.beginPath();
                    drawCtx.moveTo(-baseRadius, i * baseRadius / 5);
                    drawCtx.lineTo(baseRadius, i * baseRadius / 5);
                    drawCtx.stroke();
                }
            }

            // Angle guides
            if (config.showAngles) {
                drawCtx.strokeStyle = '#333';
                drawCtx.lineWidth = 0.5 * scaledLineWidth;
                const angleCount = config.modulus <= 60 ? config.modulus : 12;
                for (let i = 0; i < angleCount; i++) {
                    const angle = (2 * Math.PI * i) / angleCount - Math.PI / 2;
                    const x = baseRadius * 1.1 * Math.cos(angle);
                    const y = baseRadius * 1.1 * Math.sin(angle);
                    drawCtx.beginPath();
                    drawCtx.moveTo(0, 0);
                    drawCtx.lineTo(x, y);
                    drawCtx.stroke();
                }
            }

            // Constellation gaps
            if (config.gapType !== 'none') {
                const gap = parseInt(config.gapType);
                const pairs = gapPairs[gap] || [];
                drawCtx.globalAlpha = 0.5;
                pairs.forEach(([r1, r2]) => {
                    const p1 = points[r1];
                    const p2 = points[r2];
                    const x1 = baseRadius * Math.cos(p1.angle - Math.PI / 2);
                    const y1 = baseRadius * Math.sin(p1.angle - Math.PI / 2);
                    const x2 = baseRadius * Math.cos(p2.angle - Math.PI / 2);
                    const y2 = baseRadius * Math.sin(p2.angle - Math.PI / 2);
                    
                    drawCtx.beginPath();
                    drawCtx.moveTo(x1, y1);
                    drawCtx.lineTo(x2, y2);
                    drawCtx.strokeStyle = '#ffcc00';
                    drawCtx.lineWidth = 2 * scaledLineWidth;
                    drawCtx.stroke();
                });
                drawCtx.globalAlpha = 1.0;
            }

            // Projection lines
            if (config.showProjections) {
                drawCtx.globalAlpha = config.opacity;
                points.forEach(p => {
                    if (!p.isOpen) {
                        const outerX = baseRadius * Math.cos(p.angle - Math.PI / 2);
                        const outerY = baseRadius * Math.sin(p.angle - Math.PI / 2);
                        
                        const channelRadius = baseRadius * Math.pow(p.reducedM / config.modulus, config.spacingFactor);
                        const targetAngle = (2 * Math.PI * p.reducedR) / p.reducedM;
                        const innerX = channelRadius * Math.cos(targetAngle - Math.PI / 2);
                        const innerY = channelRadius * Math.sin(targetAngle - Math.PI / 2);

                        drawCtx.beginPath();
                        drawCtx.moveTo(outerX, outerY);
                        drawCtx.lineTo(innerX, innerY);
                        drawCtx.strokeStyle = '#ff1493';
                        drawCtx.lineWidth = 0.5 * scaledLineWidth;
                        drawCtx.stroke();
                    }
                });
                drawCtx.globalAlpha = 1.0;
            }

            // Channel rings
            if (config.showRings) {
                const divisors = getDivisors(config.modulus).filter(d => channels.has(d) && d >= config.minRing);
                divisors.forEach(d => {
                    const radius = baseRadius * Math.pow(d / config.modulus, config.spacingFactor);
                    
                    drawCtx.beginPath();
                    drawCtx.arc(0, 0, radius, 0, 2 * Math.PI);
                    drawCtx.strokeStyle = '#ffd700';
                    drawCtx.lineWidth = 1 * scaledLineWidth;
                    drawCtx.stroke();

                    if (config.labelType !== 'none' && d > 1) {
                        const labelX = radius + labelSpacing;
                        const labelY = 0;
                        const mult = channels.get(d).multiplicity;
                        const fontSize = 11 * scaledLineWidth;
                        
                        drawCtx.font = `${fontSize}px var(--font-mono)`;
                        drawCtx.textAlign = 'left';
                        
                        if (config.labelType === 'farey') {
                            drawCtx.fillStyle = '#ffd700';
                            drawCtx.fillText(`M' = ${d}`, labelX, labelY);
                        } else if (config.labelType === 'gcd') {
                            drawCtx.fillStyle = '#aaa';
                            drawCtx.fillText(`d = ${mult}`, labelX, labelY);
                        } else if (config.labelType === 'both') {
                            drawCtx.fillStyle = '#ffd700';
                            drawCtx.fillText(`M' = ${d}`, labelX, labelY - labelLineHeight);
                            drawCtx.fillStyle = '#aaa';
                            drawCtx.fillText(`d = ${mult}`, labelX, labelY + labelLineHeight);
                        }
                    }
                });
            }

            // Inner ring points
            if (config.showAllRings) {
                const selectedRingsSet = config.selectedRings ? 
                    new Set(config.selectedRings.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n))) : 
                    null;

                const divisors = getDivisors(config.modulus).filter(d => d >= config.minRing);
                divisors.forEach(d => {
                    if (d === config.modulus) return;
                    if (selectedRingsSet && !selectedRingsSet.has(d)) return;
                    
                    const ringPoints = allRingPoints.get(d);
                    if (!ringPoints) return;
                    
                    const radius = baseRadius * Math.pow(d / config.modulus, config.spacingFactor);
                    
                    ringPoints.forEach(p => {
                        if (config.highlightCoprime && !p.isOpen) return;
                        if (!p.isOpen && !config.colorAllRings && !config.highlightCoprime) return;
                        
                        const x = radius * Math.cos(p.angle - Math.PI / 2);
                        const y = radius * Math.sin(p.angle - Math.PI / 2);

                        let color = '#ffd700';
                        if (config.colorAllRings) color = getPointColor(p);

                        if (config.pointDisplayMode === 'dots') {
                            drawCtx.beginPath();
                            drawCtx.arc(x, y, scaledPointSize * 0.7, 0, 2 * Math.PI);
                            drawCtx.fillStyle = color;
                            drawCtx.fill();
                        } else {
                            const text = getPointDisplayText(p);
                            if (text) drawPointAsText(drawCtx, x, y, text, color, scaledTextSize * 0.8);
                        }
                    });
                });
            }

            // Outer ring points
            points.forEach(p => {
                const x = baseRadius * Math.cos(p.angle - Math.PI / 2);
                const y = baseRadius * Math.sin(p.angle - Math.PI / 2);

                const color = getPointColor(p);
                const hitR = scaledPointSize;

                if (config.pointDisplayMode === 'dots') {
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, hitR, 0, 2 * Math.PI);
                    drawCtx.fillStyle = color;
                    drawCtx.fill();

                    if (isInteractive && hoveredPoint && hoveredPoint.r === p.r) {
                        drawCtx.strokeStyle = '#fff';
                        drawCtx.lineWidth = 2 * scaledLineWidth;
                        drawCtx.stroke();
                    }
                } else {
                    const text = getPointDisplayText(p);
                    if (text) {
                        drawPointAsText(drawCtx, x, y, text, color, scaledTextSize);
                        
                        if (isInteractive && hoveredPoint && hoveredPoint.r === p.r) {
                            drawCtx.strokeStyle = '#fff';
                            drawCtx.lineWidth = 1 * scaledLineWidth;
                            drawCtx.strokeText(text, x, y);
                        }
                    }
                }

                if (isInteractive) {
                    p.screenX = x;
                    p.screenY = y;
                    p.hitR = hitR;
                }
            });

            drawCtx.restore();
        }

        // Modulus control
        function setModulus(m) {
            config.modulus = m;
            const slider = document.getElementById('modulusSlider');
            const input = document.getElementById('modulusInput');
            slider.value = Math.min(m, parseInt(slider.max));
            input.value = m;
            calculatePoints();
            draw();
        }

        function updateConfig(property, value, displayId) {
            if (property === 'modulus' && sequenceInterval !== null) {
                stopSequence();
            }

            config[property] = value;
            if (displayId) {
                const el = document.getElementById(displayId);
                if (el) el.textContent = typeof value === 'number' ? value.toFixed(2) : value;
            }
            
            if (property === 'modulus' || property === 'spacingFactor' || property === 'gapType' || property === 'minRing') {
                calculatePoints();
            }
            draw();
        }

        // Interaction handlers
        function handlePointerStart(x, y) {
            isDragging = true;
            lastMouse = { x, y };
            canvas.style.cursor = 'grabbing';
            stopSequence();
        }

        function handlePointerMove(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            if (isDragging) {
                config.panX += (x - lastMouse.x) * dpr / config.zoom;
                config.panY += (y - lastMouse.y) * dpr / config.zoom;
                lastMouse = { x, y };
                draw();
            }
            
            const canvasX = (x - rect.left) * dpr;
            const canvasY = (y - rect.top) * dpr;
            
            const inverseZoom = 1 / config.zoom;
            const size = canvas.width / dpr;
            const centerX = size / 2;
            const centerY = size / 2;

            const worldX = (canvasX / dpr - centerX) * inverseZoom - config.panX;
            const worldY = (canvasY / dpr - centerY) * inverseZoom - config.panY;

            let closest = null;
            let minDistSq = (config.pointSize * 2 * inverseZoom) ** 2;

            points.forEach(p => {
                const dx = worldX - p.screenX;
                const dy = worldY - p.screenY;
                const distSq = dx * dx + dy * dy;
                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closest = p;
                }
            });

            if (closest !== hoveredPoint) {
                hoveredPoint = closest;
                draw();
                updateTooltip(x, y);
            } else if (hoveredPoint) {
                updateTooltip(x, y);
            } else if (!isDragging) {
                document.getElementById('tooltip').style.display = 'none';
            }
        }

        function handlePointerEnd() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }
        
        function updateTooltip(x, y) {
            const tooltip = document.getElementById('tooltip');
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (x + 15) + 'px';
                tooltip.style.top = (y + 15) + 'px';
                
                const p = hoveredPoint;
                const reduction = p.isOpen ? 'Irreducible' : `${p.r}/${p.M} ‚Üí ${p.reducedR}/${p.reducedM}`;
                
                const gaps = [];
                Object.keys(gapPairs).forEach(gap => {
                    if (gapPairs[gap].some(([r1, r2]) => r1 === p.r || r2 === p.r)) {
                        const gapName = gap === '2' ? 'Twin' : gap === '4' ? 'Cousin' : gap === '6' ? 'Sexy' : `Gap ${gap}`;
                        if (!gaps.includes(gapName)) {
                            gaps.push(gapName);
                        }
                    }
                });
                
                tooltip.innerHTML = `
                    <div class="tooltip-line"><strong>r = ${p.r}</strong></div>
                    <div class="tooltip-line">M = ${p.M}</div>
                    <div class="tooltip-line">GCD = ${p.gcd}</div>
                    <div class="tooltip-line">${reduction}</div>
                    ${!p.isOpen ? `<div class="tooltip-line">M' = ${p.reducedM}</div>` : ''}
                    <div class="tooltip-line">${((p.angle * 180 / Math.PI) % 360).toFixed(1)}¬∞</div>
                    ${p.spf > 1 ? `<div class="tooltip-line">SPF = ${p.spf}, LPF = ${p.lpf}</div>` : ''}
                    ${gaps.length > 0 ? `<div class="tooltip-line" style="color: #0f0;">${gaps.join(', ')}</div>` : ''}
                `;
            } else {
                tooltip.style.display = 'none';
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            stopSequence();
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const delta = e.deltaY < 0 ? 1.1 : 0.9;
            const newZoom = config.zoom * delta;
            
            config.zoom = Math.min(Math.max(newZoom, 0.1), 10);
            
            document.getElementById('zoomSlider').value = Math.round(config.zoom * 100);
            document.getElementById('zoomValue').textContent = config.zoom.toFixed(2);
            
            const scaleChange = 1 - (config.zoom / newZoom);
            
            const canvasMouseX = mouseX * dpr;
            const canvasMouseY = mouseY * dpr;
            
            const size = canvas.width;
            const relX = canvasMouseX - size / 2;
            const relY = canvasMouseY - size / 2;
            
            config.panX += (relX * scaleChange) / config.zoom;
            config.panY += (relY * scaleChange) / config.zoom;

            draw();
        }

        // Keyboard shortcuts
        function handleKeyPress(e) {
            if (e.target.tagName === 'INPUT') return;
            
            switch(e.key.toLowerCase()) {
                case 'r':
                    resetView();
                    break;
                case 'a':
                    toggleAnalysisPanel();
                    break;
                case ' ':
                    e.preventDefault();
                    if (sequenceInterval) stopSequence();
                    else startSequence();
                    break;
                case 'arrowleft':
                    setModulus(Math.max(2, config.modulus - 1));
                    break;
                case 'arrowright':
                    setModulus(Math.min(5000, config.modulus + 1));
                    break;
                case '?':
                    showKeyboardHelp();
                    break;
            }
        }

        function showKeyboardHelp() {
            alert(`Keyboard Shortcuts:
            
Space - Play/Pause animation
‚Üê ‚Üí - Decrease/Increase modulus
R - Reset view
A - Toggle analysis panel
? - Show this help`);
        }

        // Export functions
        function exportImage() {
            const resolution = parseInt(document.getElementById('exportResolution').value);
            
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            exportCanvas.width = resolution;
            exportCanvas.height = resolution;
            
            exportCtx.fillStyle = '#000';
            exportCtx.fillRect(0, 0, resolution, resolution);
            
            const dpr = window.devicePixelRatio || 1;
            const currentSize = canvas.width / dpr;
            const exportScale = resolution / currentSize;

            draw(exportCtx, exportScale);
            
            exportCtx.save();
            exportCtx.font = `${resolution / 50}px var(--font-mono)`;
            exportCtx.fillStyle = '#999';
            exportCtx.textAlign = 'right';
            exportCtx.fillText(`M = ${config.modulus} | ${new Date().toLocaleDateString()}`, resolution - 20, resolution - 20);
            exportCtx.restore();

            const link = document.createElement('a');
            link.download = `modular-reduction-M${config.modulus}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        function exportCSV() {
            const M = config.modulus;
            const factors = primeFactorization(M);
            
            let csv = `# Modular Reduction Projection Data\n`;
            csv += `# M = ${M}\n`;
            csv += `# Factorization: ${formatFactorization(factors)}\n`;
            csv += `Residue,Modulus,GCD,Status,Reduced_Num,Reduced_Denom,Channel,Angle_Rad,SPF,LPF\n`;
            
            points.forEach(p => {
                csv += `${p.r},${p.M},${p.gcd},${p.isOpen ? 'Irreducible' : 'Reducible'},`;
                csv += `${p.reducedR},${p.reducedM},${p.reducedM},${p.angle.toFixed(6)},${p.spf},${p.lpf}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `modular-reduction-M${M}.csv`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportJSON() {
            const M = config.modulus;
            const factors = primeFactorization(M);
            
            const data = {
                metadata: {
                    modulus: M,
                    factorization: factors,
                    phi_M: phi(M),
                    omega_M: omega(M),
                    irreducible: points.filter(p => p.isOpen).length,
                    channels: channels.size,
                    is_prime: isPrime(M),
                    export_date: new Date().toISOString(),
                    config: config
                },
                residues: points.map(p => ({
                    r: p.r,
                    gcd: p.gcd,
                    coprime: p.isOpen,
                    reduced_num: p.reducedR,
                    reduced_denom: p.reducedM,
                    channel: p.reducedM,
                    angle: p.angle,
                    spf: p.spf,
                    lpf: p.lpf
                })),
                channels: Array.from(channels.entries()).map(([m, ch]) => ({
                    M_prime: m,
                    multiplicity: ch.multiplicity,
                    count: ch.count
                })),
                constellations: {
                    twin: gapPairs[2].length,
                    cousin: gapPairs[4].length,
                    sexy: gapPairs[6].length
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `modular-reduction-M${M}.json`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportFrameSequence() {
            if (recordedFrames.length === 0) {
                alert('No frames recorded. Enable "Record Frames" and play the animation.');
                return;
            }
            
            recordedFrames.forEach((frame, i) => {
                const link = document.createElement('a');
                link.download = `frame_${String(i).padStart(4, '0')}_M${frame.modulus}.png`;
                link.href = frame.dataURL;
                link.click();
            });
        }

        function copyToClipboard() {
            const data = JSON.stringify({
                modulus: config.modulus,
                phi: phi(config.modulus),
                channels: channels.size,
                irreducible: points.filter(p => p.isOpen).length
            }, null, 2);
            
            navigator.clipboard.writeText(data).then(() => {
                alert('Data copied to clipboard!');
            });
        }

        // Canvas initialization
        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            new ResizeObserver(resizeCanvas).observe(container);
            
            canvas.addEventListener('mousedown', e => handlePointerStart(e.offsetX, e.offsetY));
            canvas.addEventListener('mousemove', e => handlePointerMove(e.offsetX, e.offsetY));
            canvas.addEventListener('mouseup', handlePointerEnd);
            canvas.addEventListener('mouseleave', handlePointerEnd);
            canvas.addEventListener('wheel', handleWheel);
            
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                handlePointerStart(touch.clientX - canvas.getBoundingClientRect().left, touch.clientY - canvas.getBoundingClientRect().top);
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const touch = e.touches[0];
                handlePointerMove(touch.clientX - canvas.getBoundingClientRect().left, touch.clientY - canvas.getBoundingClientRect().top);
            });
            canvas.addEventListener('touchend', handlePointerEnd);
            
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            
            canvas.style.cursor = 'grab';
            
            document.addEventListener('keydown', handleKeyPress);
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Use the full container size (corner to corner)
            const size = Math.min(containerWidth, containerHeight);
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = `${size}px`;
            canvas.style.height = `${size}px`;
            
            draw();
        }

        // Event listeners setup
        function setupListeners() {
            document.getElementById('modulusSlider').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                setModulus(value);
            });
            document.getElementById('modulusInput').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value >= 2 && value <= 10000) setModulus(value);
            });

            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                config.zoom = parseInt(e.target.value) / 100;
                document.getElementById('zoomValue').textContent = config.zoom.toFixed(2);
                draw();
            });

            document.getElementById('speedSlider').addEventListener('input', (e) => {
                config.animationSpeed = parseInt(e.target.value);
                document.getElementById('speedValue').textContent = e.target.value;
                if (sequenceInterval) {
                    stopSequence();
                    startSequence();
                }
            });

            document.getElementById('colorScheme').addEventListener('change', (e) => updateConfig('colorScheme', e.target.value));
            document.getElementById('pointDisplayMode').addEventListener('change', (e) => updateConfig('pointDisplayMode', e.target.value));
            document.getElementById('labelType').addEventListener('change', (e) => updateConfig('labelType', e.target.value));
            document.getElementById('gapType').addEventListener('change', (e) => updateConfig('gapType', e.target.value));
            
            document.getElementById('opacitySlider').addEventListener('input', (e) => updateConfig('opacity', parseInt(e.target.value) / 100, 'opacityValue'));
            document.getElementById('pointSizeSlider').addEventListener('input', (e) => updateConfig('pointSize', parseFloat(e.target.value), 'pointSizeValue'));
            document.getElementById('textSizeSlider').addEventListener('input', (e) => updateConfig('textSize', parseInt(e.target.value), 'textSizeValue'));
            document.getElementById('spacingSlider').addEventListener('input', (e) => updateConfig('spacingFactor', parseInt(e.target.value) / 100, 'spacingValue'));
            document.getElementById('minRing').addEventListener('input', (e) => {
                config.minRing = parseInt(e.target.value);
                document.getElementById('minRingValue').textContent = e.target.value;
                updateConfig('minRing', parseInt(e.target.value));
            });
            
            document.getElementById('showProjections').addEventListener('change', (e) => updateConfig('showProjections', e.target.checked));
            document.getElementById('showAllRings').addEventListener('change', (e) => updateConfig('showAllRings', e.target.checked));
            document.getElementById('showRings').addEventListener('change', (e) => updateConfig('showRings', e.target.checked));
            document.getElementById('showAngles').addEventListener('change', (e) => updateConfig('showAngles', e.target.checked));
            document.getElementById('showBackground').addEventListener('change', (e) => updateConfig('showBackground', e.target.checked));
            document.getElementById('colorAllRings').addEventListener('change', (e) => updateConfig('colorAllRings', e.target.checked));
            document.getElementById('highlightCoprime').addEventListener('change', (e) => updateConfig('highlightCoprime', e.target.checked));
            document.getElementById('antiAlias').addEventListener('change', (e) => updateConfig('antiAlias', e.target.checked));
            
            document.getElementById('autoLoop').addEventListener('change', (e) => { config.autoLoop = e.target.checked; });
            document.getElementById('recordFrames').addEventListener('change', (e) => { config.recordFrames = e.target.checked; });
            
            document.getElementById('selectedRings').addEventListener('input', (e) => updateConfig('selectedRings', e.target.value || null));
        }

        // Initialize
        initCanvas();
        setupListeners();
        setModulus(config.modulus);
    </script>
</body>
</html>
