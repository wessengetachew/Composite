
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Composite Channel Projection | Research Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --border: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --accent-dim: rgba(88, 166, 255, 0.15);
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text-primary);
            font-family: var(--font-ui);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: row; /* Desktop Default */
        }

        /* --- STAGE (LEFT/TOP) --- */
        #stage {
            flex-grow: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* Enforce Square Canvas */
        canvas {
            background: #050505;
            box-shadow: 0 0 0 1px var(--border);
            display: block;
        }

        #overlay-header {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            text-shadow: 0 2px 4px #000; z-index: 10;
        }
        h1 { margin: 0; font-size: 1.2rem; letter-spacing: -0.5px; }
        .subtitle { color: var(--text-secondary); font-family: var(--font-mono); font-size: 0.8rem; margin-top: 4px; }

        #zoom-controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 20;
            display: flex; gap: 8px;
        }

        .icon-btn {
            background: rgba(22, 27, 34, 0.9); border: 1px solid var(--border);
            color: var(--text-primary); width: 40px; height: 40px; 
            border-radius: 8px; cursor: pointer; display: flex; 
            align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.4rem; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .icon-btn:active { background: var(--accent); border-color: var(--accent); }

        /* --- PANEL (RIGHT/BOTTOM) --- */
        #panel {
            width: 360px;
            background: var(--panel);
            border-left: 1px solid var(--border);
            display: flex; flex-direction: column;
            overflow-y: auto;
            z-index: 30;
            transition: transform 0.3s ease;
        }

        /* Mobile Toggle Handle */
        #mobile-handle {
            display: none; /* Hidden on desktop */
            padding: 10px; background: var(--panel);
            border-top: 1px solid var(--accent);
            text-align: center; color: var(--accent);
            font-size: 0.8rem; font-weight: bold; cursor: pointer;
        }

        .section { padding: 15px; border-bottom: 1px solid var(--border); }
        .section-title {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--text-secondary); margin-bottom: 10px; font-weight: 700;
        }

        /* --- CONTROLS --- */
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        label { font-size: 0.85rem; color: var(--text-secondary); }
        
        select, input[type="number"] {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-primary); padding: 6px 8px; border-radius: 4px;
            font-family: var(--font-mono); font-size: 0.9rem;
        }
        
        input[type="range"] { width: 100%; accent-color: var(--accent); margin: 10px 0; height: 20px; }

        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 8px; }
        .btn-pill {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 8px; font-size: 0.8rem;
            border-radius: 4px; cursor: pointer; text-align: center;
        }
        .btn-pill:active, .btn-pill.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }

        .view-switcher { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 10px; }
        .view-btn {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 10px; font-size: 0.75rem;
            border-radius: 4px; cursor: pointer; text-align: center;
        }
        .view-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

        .action-btn {
            width: 100%; background: var(--bg); border: 1px solid var(--border);
            color: var(--text-primary); padding: 12px; border-radius: 4px;
            cursor: pointer; font-weight: 600; font-size: 0.9rem; margin-top: 5px;
        }
        .action-btn.primary { background: #238636; border-color: #238636; color: white; }

        /* --- MODAL (INTRO) --- */
        #intro-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: var(--panel); border: 1px solid var(--border);
            width: 90%; max-width: 500px; padding: 25px; border-radius: 12px;
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .modal-content h2 { margin-top: 0; color: var(--accent); }
        .modal-content p { color: var(--text-secondary); line-height: 1.5; font-size: 0.95rem; margin-bottom: 20px; }
        .step-dots { display: flex; justify-content: center; gap: 5px; margin-bottom: 20px; }
        .step-dot { width: 8px; height: 8px; background: var(--border); border-radius: 50%; }
        .step-dot.active { background: var(--accent); }

        /* --- TOOLTIP --- */
        #tooltip {
            position: absolute; pointer-events: none;
            background: rgba(22, 27, 34, 0.95); border: 1px solid var(--accent);
            padding: 10px; border-radius: 6px; font-size: 0.8rem; display: none; z-index: 50;
        }

        /* --- RESPONSIVE MOBILE CSS --- */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #stage { width: 100%; height: 100%; } /* Canvas takes full space initially */
            
            #panel {
                position: fixed; bottom: 0; left: 0; width: 100%;
                height: 70vh; border-left: none; border-top: 1px solid var(--border);
                transform: translateY(calc(100% - 45px)); /* Only handle visible */
            }
            #panel.open { transform: translateY(0); }
            #mobile-handle { display: block; }
            
            #zoom-controls { bottom: 60px; } /* Move up above handle */
            
            h1 { font-size: 1rem; }
            .subtitle { font-size: 0.75rem; }
        }
    </style>
</head>
<body>

<div id="intro-modal">
    <div class="modal-content" id="modal-step-1">
        <h2>Composite Channel Projection</h2>
        <p>Welcome to the research visualization suite. This tool explores the geometric structure of modular arithmetic by projecting number residues onto "Farey Channels."</p>
        <p><strong>Goal:</strong> Visualize how fractions $r/M$ reduce to their simplest forms.</p>
        <button class="action-btn primary" onclick="nextStep(2)">Next: How to Use</button>
    </div>
    
    <div class="modal-content" id="modal-step-2" style="display:none">
        <h2>How to Navigate</h2>
        <p><strong>1. Square Canvas:</strong> The visual is always 1:1. <br>
           <strong>2. Zoom & Pan:</strong> Use the +/- buttons or mouse wheel. Drag to move around.<br>
           <strong>3. Mobile:</strong> The settings panel is at the bottom. Tap the "Settings" bar to open it.</p>
        <button class="action-btn primary" onclick="closeModal()">Start Exploration</button>
    </div>
</div>

<div id="stage">
    <canvas id="vizCanvas"></canvas>
    
    <div id="overlay-header">
        <h1 id="disp-title">M = 60</h1>
        <div id="disp-subtitle" class="subtitle">2² × 3 × 5</div>
        <div id="disp-zoom" class="subtitle" style="color:var(--accent); margin-top:2px;">Zoom: 100%</div>
    </div>

    <div id="zoom-controls">
        <button class="icon-btn" onclick="adjustZoom(-0.2)">−</button>
        <button class="icon-btn" onclick="resetView()">⟲</button>
        <button class="icon-btn" onclick="adjustZoom(0.2)">+</button>
    </div>

    <div id="tooltip"></div>
</div>

<div id="panel">
    <div id="mobile-handle" onclick="togglePanel()">
        ▲ CONFIGURATION & SETTINGS
    </div>

    <div class="section">
        <div class="section-title">Modulus (M)</div>
        <div class="control-row">
            <input type="number" id="input-m" value="60" min="2" max="5000">
            <button class="btn-pill" style="width:auto; padding:8px 16px;" onclick="toggleAnim()" id="btn-anim">▶ Animate Sequence</button>
        </div>
        <input type="range" id="slider-m" min="4" max="2520" value="60">
        <div class="btn-grid">
            <button class="btn-pill" onclick="setM(12)">12</button>
            <button class="btn-pill" onclick="setM(60)">60</button>
            <button class="btn-pill" onclick="setM(210)">210</button>
            <button class="btn-pill" onclick="setM(2520)">2520</button>
        </div>
    </div>

    <div class="section">
        <div class="section-title">Projection Geometry</div>
        <div class="view-switcher">
            <button class="view-btn active" onclick="setView('projection')" id="btn-v-projection">Radial Projection</button>
            <button class="view-btn" onclick="setView('rings')" id="btn-v-rings">Channel Rings</button>
            <button class="view-btn" onclick="setView('ford')" id="btn-v-ford">Ford Horizon</button>
            <button class="view-btn" onclick="setView('lattice')" id="btn-v-lattice">Lattice Map</button>
        </div>

        <div class="control-row">
            <label>Color Scheme</label>
            <select id="sel-color" onchange="updateConfig()">
                <option value="spectral">Spectral Channels</option>
                <option value="type">Residue Type</option>
                <option value="gcd">Gradient by GCD</option>
            </select>
        </div>
        
        <div class="control-row">
            <label>Opacity</label>
            <input type="range" style="width:100px" min="0.1" max="1" step="0.1" value="0.5" id="rng-opacity" oninput="updateConfig()">
        </div>
    </div>

    <div class="section">
        <div class="section-title">Export</div>
        <button class="action-btn" onclick="exportPNG()">Download 4K PNG</button>
    </div>
    
    <div style="padding:20px; text-align:center; font-size:0.7rem; color:var(--text-secondary);">
        Tool by Wessen Getachew
    </div>
</div>

<script>
/** * UI LOGIC 
 */
function nextStep(step) {
    document.getElementById('modal-step-1').style.display = 'none';
    document.getElementById('modal-step-2').style.display = 'block';
}

function closeModal() {
    document.getElementById('intro-modal').style.display = 'none';
    resize(); // Ensure canvas matches layout after modal closes
}

function togglePanel() {
    const p = document.getElementById('panel');
    const h = document.getElementById('mobile-handle');
    p.classList.toggle('open');
    h.innerText = p.classList.contains('open') ? "▼ CLOSE SETTINGS" : "▲ CONFIGURATION & SETTINGS";
}

/** * MATHEMATICAL CORE 
 */
const MathCore = {
    gcd: (a, b) => { while (b) [a, b] = [b, a % b]; return a; },
    phi: (n) => {
        let result = n;
        for (let i = 2; i * i <= n; i++) {
            if (n % i === 0) {
                while (n % i === 0) n /= i;
                result -= result / i;
            }
        }
        if (n > 1) result -= result / n;
        return result;
    },
    getFactors: (n) => {
        const f = new Set();
        let d = 2, temp = n;
        while (d * d <= temp) {
            if (temp % d === 0) { f.add(d); temp /= d; } else { d++; }
        }
        if (temp > 1) f.add(temp);
        return Array.from(f).join(" × ");
    }
};

/** * APP STATE 
 */
const State = {
    M: 60,
    residues: [],
    channels: [],
    viewMode: 'projection',
    colorMode: 'spectral',
    opacity: 0.5,
    zoom: 1,
    panX: 0,
    panY: 0,
    isDragging: false,
    lastMouse: {x:0, y:0},
    isolatedChannel: null,
    isAnimating: false,
    animTimer: null
};

/** * DATA ENGINE 
 */
function computeData() {
    const M = State.M;
    State.residues = [];
    const channelMap = {};

    for (let r = 0; r <= M; r++) {
        const effectiveR = r === 0 ? M : r;
        const d = MathCore.gcd(effectiveR, M);
        const m_prime = M / d;
        const r_prime = effectiveR / d;

        if (!channelMap[m_prime]) channelMap[m_prime] = { val: m_prime, d: d, color: null };

        State.residues.push({
            r: r, d: d, m_prime: m_prime, r_prime: r_prime,
            angle: (r / M) * Math.PI * 2 - (Math.PI / 2),
            type: d === 1 ? 'coprime' : 'reducible'
        });
    }

    State.channels = Object.values(channelMap).sort((a,b) => a.val - b.val);

    State.channels.forEach((ch, index) => {
        const hue = ((index * 0.618033988749895) % 1) * 360;
        ch.color = `hsl(${hue}, 75%, 60%)`;
    });

    render();
}

/** * RENDERER (SQUARE ENGINE) 
 */
const canvas = document.getElementById('vizCanvas');
const ctx = canvas.getContext('2d');

function resize() {
    const stage = document.getElementById('stage');
    // Calculate largest possible square
    const size = Math.min(stage.clientWidth, stage.clientHeight) - 20; // 20px padding
    
    // Set internal resolution matches CSS size for sharpness
    // Use window.devicePixelRatio for high-DPI screens
    const dpr = window.devicePixelRatio || 1;
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    
    ctx.scale(dpr, dpr); // Normalize drawing coordinate system
    
    // Store logical size
    State.size = size;
    render();
}
window.addEventListener('resize', resize);

function getPointColor(res) {
    if (State.colorMode === 'type') {
        if (res.d === 1) return '#58a6ff';
        if (res.m_prime === 1) return '#ffd700';
        return '#ff6b6b';
    }
    if (State.colorMode === 'gcd') {
        if (res.d === 1) return '#58a6ff';
        return `hsl(${(res.d * 15) % 360}, 70%, 60%)`;
    }
    const ch = State.channels.find(c => c.val === res.m_prime);
    return ch ? ch.color : '#fff';
}

function render() {
    const width = State.size || 500;
    const height = State.size || 500;
    
    // Clear
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    // Center Coordinate System
    ctx.translate(width/2 + State.panX, height/2 + State.panY);
    ctx.scale(State.zoom, State.zoom);

    if (State.viewMode === 'ford') renderFord(ctx, width);
    else if (State.viewMode === 'lattice') renderLattice(ctx, width);
    else renderRadial(ctx, width); // Radial default

    ctx.restore();
    
    // UI Updates
    document.getElementById('disp-title').innerText = `M = ${State.M}`;
    document.getElementById('disp-subtitle').innerText = MathCore.getFactors(State.M);
    document.getElementById('disp-zoom').innerText = `Zoom: ${(State.zoom*100).toFixed(0)}%`;
}

// MODE: RADIAL
function renderRadial(ctx, size) {
    const baseRadius = size * 0.45;

    State.channels.forEach((ch, i) => {
        if (State.isolatedChannel && State.isolatedChannel !== ch.val) return;
        const pct = (i + 1) / (State.channels.length + 1);
        let r = pct * baseRadius;
        if (ch.val === State.M) r = baseRadius;
        if (ch.val === 1) r = baseRadius * 0.05;
        ch.renderR = r; 

        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.strokeStyle = State.isolatedChannel ? ch.color : '#30363d';
        ctx.lineWidth = 1/State.zoom;
        ctx.stroke();
    });

    State.residues.forEach(res => {
        if (res.r === 0 || res.r === State.M) return;
        if (State.isolatedChannel && State.isolatedChannel !== res.m_prime) return;

        const color = getPointColor(res);
        const ch = State.channels.find(c => c.val === res.m_prime);
        const x2 = Math.cos(res.angle) * ch.renderR;
        const y2 = Math.sin(res.angle) * ch.renderR;

        if (State.viewMode === 'projection' && res.d > 1) {
            const x1 = Math.cos(res.angle) * baseRadius;
            const y1 = Math.sin(res.angle) * baseRadius;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            ctx.strokeStyle = color; ctx.lineWidth = 1/State.zoom;
            ctx.globalAlpha = State.opacity; ctx.stroke(); ctx.globalAlpha = 1.0;
        }

        ctx.beginPath(); ctx.arc(x2, y2, 3/State.zoom, 0, Math.PI*2);
        ctx.fillStyle = color; ctx.fill();
        
        // Save Screen Coords for hit testing
        // Need to reverse transform later
        res.hit = { x: x2, y: y2, r: 5/State.zoom };
    });
}

// MODE: FORD HORIZON
function renderFord(ctx, size) {
    const scale = size * 0.9;
    const groundY = size * 0.3;
    const offsetX = -size * 0.45;
    
    ctx.beginPath(); ctx.moveTo(-size, groundY); ctx.lineTo(size, groundY);
    ctx.strokeStyle = '#8b949e'; ctx.lineWidth = 2/State.zoom; ctx.stroke();

    const drawn = new Set();
    State.residues.forEach(res => {
        if (State.isolatedChannel && State.isolatedChannel !== res.m_prime) return;
        const key = `${res.r_prime}/${res.m_prime}`;
        if (drawn.has(key)) return; drawn.add(key);

        const q = res.m_prime;
        const p = res.r_prime;
        const radius = (1 / (2 * q * q)) * scale * 1.5;
        
        const x = offsetX + (p/q) * scale;
        const y = groundY - radius;
        
        if (radius * State.zoom < 0.5) return;

        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2);
        const ch = State.channels.find(c => c.val === q);
        ctx.fillStyle = ch.color + '80'; ctx.fill();
        ctx.strokeStyle = ch.color; ctx.lineWidth = 1/State.zoom; ctx.stroke();
        
        res.hit = { x: x, y: y, r: radius };
    });
}

// MODE: LATTICE
function renderLattice(ctx, size) {
    const plotW = size * 0.8;
    const plotH = size * 0.8;
    const startX = -plotW/2;
    const startY = plotH/2;

    ctx.beginPath();
    ctx.moveTo(startX, startY); ctx.lineTo(startX+plotW, startY);
    ctx.moveTo(startX, startY); ctx.lineTo(startX, startY-plotH);
    ctx.strokeStyle = '#30363d'; ctx.lineWidth = 2/State.zoom; ctx.stroke();

    State.residues.forEach(res => {
        if (res.r === 0) return;
        if (State.isolatedChannel && State.isolatedChannel !== res.m_prime) return;

        const x = startX + (res.r / State.M) * plotW;
        const y = startY - (res.d / State.channels[State.channels.length-1].d) * plotH;
        const color = getPointColor(res);

        ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, y);
        ctx.strokeStyle = color; ctx.globalAlpha = 0.3; ctx.lineWidth = Math.max(1, plotW/State.M)/State.zoom;
        ctx.stroke(); ctx.globalAlpha = 1.0;

        ctx.beginPath(); ctx.arc(x, y, 3/State.zoom, 0, Math.PI*2);
        ctx.fillStyle = color; ctx.fill();
        res.hit = { x: x, y: y, r: 5/State.zoom };
    });
}

/** * INPUT HANDLERS 
 */
function adjustZoom(delta) {
    State.zoom = Math.max(0.1, Math.min(10, State.zoom + delta * State.zoom));
    render();
}
function resetView() { State.zoom=1; State.panX=0; State.panY=0; render(); }
function setM(val) {
    State.M = parseInt(val);
    document.getElementById('input-m').value = State.M;
    document.getElementById('slider-m').value = State.M;
    computeData();
}
function setView(mode) {
    State.viewMode = mode;
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-v-${mode}`).classList.add('active');
    render();
}
function updateConfig() {
    State.colorMode = document.getElementById('sel-color').value;
    State.opacity = parseFloat(document.getElementById('rng-opacity').value);
    render();
}
function toggleAnim() {
    if(State.isAnimating) { clearInterval(State.animTimer); State.isAnimating=false; }
    else { State.isAnimating=true; State.animTimer = setInterval(() => {
        let n = State.M+1; if(n>2520) n=4; setM(n);
    }, 100); }
}

// Mouse/Touch Interaction
function handlePointerStart(x, y) {
    State.isDragging = true;
    State.lastMouse = { x, y };
}
function handlePointerMove(x, y) {
    if (State.isDragging) {
        State.panX += x - State.lastMouse.x;
        State.panY += y - State.lastMouse.y;
        State.lastMouse = { x, y };
        render();
    }
    
    // Hover Test
    // Normalize logic for hit testing in Square Canvas
    const width = State.size;
    const height = State.size;
    const cx = width/2 + State.panX;
    const cy = height/2 + State.panY;
    
    // Mouse relative to canvas center, scaled by zoom
    const mx = (x - cx) / State.zoom;
    const my = (y - cy) / State.zoom;
    
    let target = null;
    let minD = 10 / State.zoom;

    State.residues.forEach(res => {
        if (!res.hit) return;
        const dist = Math.sqrt((mx-res.hit.x)**2 + (my-res.hit.y)**2);
        const limit = Math.max(minD, res.hit.r);
        if (dist < limit) { minD = dist; target = res; }
    });

    const tip = document.getElementById('tooltip');
    if (target) {
        // Position tooltip using page coords
        const rect = canvas.getBoundingClientRect();
        tip.style.display = 'block';
        tip.style.left = (rect.left + x + 10) + 'px';
        tip.style.top = (rect.top + y + 10) + 'px';
        tip.innerHTML = `r=${target.r} <span style="color:#aaa">(${target.d})</span>`;
    } else {
        tip.style.display = 'none';
    }
}

// Event Listeners (Mouse + Touch)
canvas.addEventListener('mousedown', e => handlePointerStart(e.offsetX, e.offsetY));
window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    if(e.target === canvas || State.isDragging) {
        handlePointerMove(e.clientX - rect.left, e.clientY - rect.top);
    }
});
window.addEventListener('mouseup', () => State.isDragging = false);

// Touch Support
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    handlePointerStart(t.clientX - rect.left, t.clientY - rect.top);
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    handlePointerMove(t.clientX - rect.left, t.clientY - rect.top);
}, {passive: false});

// Export
function exportPNG() {
    const link = document.createElement('a');
    link.download = `Projection_M${State.M}.png`;
    link.href = canvas.toDataURL('image/png'); // Can export exact canvas state
    link.click();
}

// Init
document.getElementById('input-m').addEventListener('change', e=>setM(e.target.value));
document.getElementById('slider-m').addEventListener('input', e=>setM(e.target.value));
resize();
computeData();

</script>
</body>
</html>

