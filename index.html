
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Harmonic and Geometric Framework for Prime Gap Analysis - Interactive Research Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', serif;
            background: #f5f5f0;
            color: #1a1a1a;
            line-height: 1.6;
        }

        .page-container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        header {
            background: linear-gradient(135deg, #1e3a8a, #3b82f6);
            color: white;
            padding: 40px 60px;
            border-bottom: 4px solid #1e40af;
        }

        .paper-title {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .author-info {
            text-align: center;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .paper-meta {
            text-align: center;
            font-size: 0.95em;
            opacity: 0.9;
            font-style: italic;
        }

        .abstract-section {
            background: #fafaf8;
            border-left: 4px solid #3b82f6;
            padding: 30px 60px;
            margin: 0;
        }

        .abstract-section h2 {
            font-size: 1.4em;
            margin-bottom: 15px;
            color: #1e3a8a;
        }

        .abstract-section p {
            text-align: justify;
            font-size: 1.05em;
            margin-bottom: 12px;
        }

        .keywords {
            margin-top: 20px;
            font-style: italic;
            color: #4b5563;
        }

        .keywords strong {
            color: #1e3a8a;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr;
            min-height: calc(100vh - 400px);
        }

        .control-sidebar {
            background: #fafaf8;
            border-right: 2px solid #e5e7eb;
            padding: 30px 20px;
            overflow-y: auto;
            max-height: calc(100vh - 300px);
            position: sticky;
            top: 0;
        }

        .control-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .control-sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .control-sidebar::-webkit-scrollbar-thumb {
            background: #3b82f6;
            border-radius: 4px;
        }

        .section-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #1e3a8a;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
            font-family: 'Georgia', serif;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-item {
            margin-bottom: 18px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.92em;
            color: #374151;
        }

        .control-value {
            font-weight: bold;
            color: #1e3a8a;
            font-family: 'Courier New', monospace;
        }

        .dual-input {
            display: grid;
            grid-template-columns: 1fr 75px;
            gap: 8px;
            align-items: center;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid #1e40af;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid #1e40af;
        }

        input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9em;
            background: white;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #3b82f6;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 8px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            font-family: 'Georgia', serif;
        }

        button:hover {
            background: #2563eb;
        }

        button.secondary {
            background: #6b7280;
        }

        button.secondary:hover {
            background: #4b5563;
        }

        button.export {
            background: #059669;
        }

        button.export:hover {
            background: #047857;
        }

        .play-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .checkbox-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .checkbox-control input {
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-control label {
            cursor: pointer;
            user-select: none;
        }

        .formula-box {
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #1f2937;
            overflow-x: auto;
            margin-top: 10px;
        }

        .canvas-section {
            padding: 30px;
        }

        .figure-container {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .figure-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #1e3a8a;
            margin-bottom: 15px;
            text-align: center;
            font-family: 'Georgia', serif;
        }

        .figure-caption {
            font-size: 0.92em;
            color: #4b5563;
            text-align: justify;
            margin-top: 15px;
            padding: 12px;
            background: #fafaf8;
            border-left: 3px solid #3b82f6;
            line-height: 1.5;
        }

        canvas {
            display: block;
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: #000000;
            cursor: crosshair;
        }

        .info-panel {
            background: #fafaf8;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            padding: 25px;
            margin-top: 20px;
        }

        .info-panel h3 {
            font-size: 1.2em;
            color: #1e3a8a;
            margin-bottom: 20px;
            font-family: 'Georgia', serif;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .metric-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-left: 3px solid #3b82f6;
            padding: 12px;
            border-radius: 4px;
        }

        .metric-label {
            font-size: 0.85em;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 1.15em;
            font-weight: bold;
            color: #1e3a8a;
            font-family: 'Courier New', monospace;
        }

        .detail-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 3px solid #3b82f6;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 500px;
            display: none;
        }

        .detail-popup.active {
            display: block;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .popup-overlay.active {
            display: block;
        }

        .popup-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #1e3a8a;
            margin-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 10px;
        }

        .popup-content {
            font-size: 0.95em;
            line-height: 1.6;
        }

        .popup-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2em;
            line-height: 1;
        }

        .theorem-box {
            background: #eff6ff;
            border: 2px solid #3b82f6;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }

        .theorem-box .theorem-title {
            font-weight: bold;
            color: #1e3a8a;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .theorem-box .theorem-content {
            font-style: italic;
            color: #1f2937;
            margin-bottom: 10px;
        }

        footer {
            background: #1f2937;
            color: #9ca3af;
            padding: 20px 60px;
            text-align: center;
            font-size: 0.9em;
        }

        @media print {
            .control-sidebar {
                display: none;
            }
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="popup-overlay" id="popup-overlay"></div>
    <div class="detail-popup" id="detail-popup">
        <button class="popup-close" onclick="closePopup()">×</button>
        <div class="popup-title" id="popup-title">Details</div>
        <div class="popup-content" id="popup-content"></div>
    </div>

    <div class="page-container">
        <header>
            <h1 class="paper-title">A Harmonic and Geometric Framework for Prime Gap Analysis</h1>
            <div class="author-info">Wessen Getachew</div>
            <div class="paper-meta">Interactive Research Tool | 2025</div>
        </header>

        <section class="abstract-section">
            <h2>Abstract</h2>
            <p>
                We present a unified and original framework that reveals deterministic structure in the distribution of twin, cousin, sexy, and triplet primes using a geometric lattice based on triangular numbers, harmonic analysis, and newly discovered rational constants. This approach offers a spatial visualization of prime gaps and introduces a family of zeta-like functions that converge to exact rational values.
            </p>
            <p>
                The framework enables elegant filtering, measurement, and pattern detection across prime number families. Through triangular lattice filtering, we demonstrate that certain families of prime gaps exhibit repeatable spatial alignments. Applying harmonic sums (zeta-like functions) to these filtered sets reveals a remarkable result: each prime gap family has a rational constant when evaluated at s = 1. For twin primes, we obtain ζ<sub>twin</sub>(1) = 6891/7153, termed the Twin Harmonic Index.
            </p>
            <p>
                Furthermore, we establish connections to the Riemann Hypothesis through prime gap harmonic phase laws, demonstrating that the behavior of ζ(s) in the critical strip is entirely determined by the gap distribution function G(s). We prove that G(s) converges for Re(s) > 1/2 and diverges for Re(s) ≤ 1/2, with the divergence boundary uniquely locked at s = 1/2.
            </p>
            <div class="keywords">
                <strong>Keywords:</strong> Prime gaps, Twin primes, Riemann Hypothesis, Harmonic analysis, Triangular lattice, Euler product reconstruction, Zeta functions, Phase law, Prime distribution
            </div>

            <div class="theorem-box">
                <div class="theorem-title">RH Phase Law (Main Result)</div>
                <div class="theorem-content">
                    Let s = σ + it where σ = Re(s). Define the dual alpha function α<sub>dual</sub>(s) = 3.34·tanh(6.76(0.63-σ)) - 0.54 + 0.93·e<sup>-0.1σ</sup> + 8.71·tanh(0.05σ). Then:
                    <br><br>
                    (1) For σ > 1/2: α<sub>dual</sub>(σ) < 1 ⟹ G(s) converges ⟹ ζ(s) is analytic (no zeros)
                    <br>
                    (2) For σ ≤ 1/2: α<sub>dual</sub>(σ) ≥ 1 ⟹ G(s) diverges ⟹ ζ(s) oscillates and crosses zero
                    <br><br>
                    Since ζ(s) can only have zeros where G(s) diverges, and divergence occurs only at σ = 1/2, all non-trivial zeros must lie on the critical line.
                </div>
            </div>

            <div class="theorem-box">
                <div class="theorem-title">Getachew Farey Collapse Theorem</div>
                <div class="theorem-content">
                    Let a/b be a rational number with gcd(a,b) = 1. Define its complement C(a/b) = (b-a)/b. Then:
                    <br><br>
                    <strong>Theorem (Positive Collapse):</strong> a/b + (b-a)/b = 1
                    <br>
                    <strong>Corollary (Negative Collapse):</strong> -a/b + -(b-a)/b = -1
                    <br><br>
                    The map C is an involution (C∘C = identity) that pairs Farey fractions with the same denominator. On the unit circle, a/b ↦ e<sup>2πia/b</sup> and its complement (b-a)/b ↦ e<sup>2πi(b-a)/b</sup> are complex conjugates, providing a geometric interpretation of the collapse.
                </div>
            </div>
        </section>

        <div class="main-content">
            <aside class="control-sidebar">
                <div class="control-group">
                    <div class="section-title">1. Complex Plane Parameters</div>
                    
                    <div class="control-item">
                        <div class="control-label">
                            <span>Real Part (σ):</span>
                            <span class="control-value" id="sigma-display">0.500</span>
                        </div>
                        <div class="dual-input">
                            <input type="range" id="sigma-slider" min="-1" max="3" step="0.001" value="0.5">
                            <input type="number" id="sigma-input" min="-1" max="3" step="0.001" value="0.5">
                        </div>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Imaginary Part (t):</span>
                            <span class="control-value" id="t-display">14.135</span>
                        </div>
                        <div class="dual-input">
                            <input type="range" id="t-slider" min="0" max="200" step="0.001" value="14.135">
                            <input type="number" id="t-input" min="0" max="200" step="0.001" value="14.135">
                        </div>
                    </div>

                    <div class="play-controls">
                        <button id="play-sigma">▶ Animate σ</button>
                        <button id="play-t">▶ Animate t</button>
                    </div>

                    <div class="formula-box">
                        Critical Line: Re(s) = 1/2<br>
                        Current σ: <span id="current-sigma">0.500</span><br>
                        Distance: <span id="sigma-distance">0.000</span>
                    </div>
                </div>

                <div class="control-group">
                    <div class="section-title">2. Computational Parameters</div>
                    
                    <div class="control-item">
                        <div class="control-label">
                            <span>Prime Limit:</span>
                            <span class="control-value" id="prime-limit-display">1000000</span>
                        </div>
                        <div class="dual-input">
                            <input type="range" id="prime-limit-slider" min="1000" max="10000000" step="1000" value="1000000">
                            <input type="number" id="prime-limit-input" min="1000" max="10000000" step="1000" value="1000000">
                        </div>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Maximum Gap:</span>
                            <span class="control-value" id="max-gap-display">1000</span>
                        </div>
                        <div class="dual-input">
                            <input type="range" id="max-gap-slider" min="10" max="5000" step="10" value="1000">
                            <input type="number" id="max-gap-input" min="10" max="5000" step="10" value="1000">
                        </div>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>Resolution:</span>
                            <span class="control-value" id="resolution-display">500</span>
                        </div>
                        <div class="dual-input">
                            <input type="range" id="resolution-slider" min="100" max="2000" step="50" value="500">
                            <input type="number" id="resolution-input" min="100" max="2000" step="50" value="500">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="section-title">3. Visualization Mode</div>
                    
                    <select id="viz-mode">
                        <option value="gap-distribution">Gap Distribution Analysis</option>
                        <option value="harmonic-spectrum">Harmonic Spectrum</option>
                        <option value="convergence-map">Convergence Map (σ-t plane)</option>
                        <option value="phase-portrait">Phase Portrait</option>
                        <option value="dual-alpha">α_dual(s) Function</option>
                        <option value="euler-reconstruction">Euler Product Reconstruction</option>
                        <option value="twin-prime-lattice">Twin Prime Triangular Lattice</option>
                        <option value="rh-phase-law">RH Phase Law Visualization</option>
                        <option value="gap-euler-tree">Gap-Based Euler Product Tree</option>
                        <option value="pi-decomposition">π Decomposition via Gaps</option>
                        <option value="zeta-twin-analysis">ζ_twin(1) = 6891/7153 Analysis</option>
                        <option value="farey-collapse">Getachew Farey Collapse Theorem</option>
                        <option value="farey-unit-circle">Farey Pairs on Unit Circle</option>
                    </select>

                    <div class="formula-box" style="margin-top: 15px;">
                        α_dual(σ) = 3.34·tanh(6.76(0.63-σ))<br>
                        &nbsp;&nbsp;- 0.54 + 0.93·e^(-0.1σ)<br>
                        &nbsp;&nbsp;+ 8.71·tanh(0.05σ)
                    </div>
                </div>

                <div class="control-group">
                    <div class="section-title">4. Display Options</div>
                    
                    <div class="checkbox-control">
                        <input type="checkbox" id="show-critical-line" checked>
                        <label for="show-critical-line">Critical Line (σ=1/2)</label>
                    </div>

                    <div class="checkbox-control">
                        <input type="checkbox" id="show-grid" checked>
                        <label for="show-grid">Coordinate Grid</label>
                    </div>

                    <div class="checkbox-control">
                        <input type="checkbox" id="show-zeros" checked>
                        <label for="show-zeros">Known Zeros</label>
                    </div>

                    <div class="checkbox-control">
                        <input type="checkbox" id="show-legend" checked>
                        <label for="show-legend">Legend</label>
                    </div>

                    <div class="checkbox-control">
                        <input type="checkbox" id="show-labels" checked>
                        <label for="show-labels">Axis Labels</label>
                    </div>

                    <div class="checkbox-control">
                        <input type="checkbox" id="enable-click" checked>
                        <label for="enable-click">Click for Details</label>
                    </div>
                </div>

                <div class="control-group">
                    <div class="section-title">5. Actions</div>
                    
                    <button id="compute-analysis">Generate Full Analysis</button>
                    <button id="export-4k" class="export">Export 4K PNG</button>
                    <button id="export-8k" class="export">Export 8K PNG</button>
                    <button id="reset" class="secondary">Reset All Parameters</button>
                </div>
            </aside>

            <main class="canvas-section">
                <div class="figure-container">
                    <div class="figure-title" id="figure-title">Figure 1: Gap Distribution Analysis</div>
                    <canvas id="main-canvas" width="1200" height="800"></canvas>
                    <div class="figure-caption" id="figure-caption">
                        This figure displays the distribution of prime gaps up to the specified maximum gap size. Each bar represents the frequency of occurrence for a particular gap value. Twin primes (gap = 2) are highlighted in gold. The distribution follows empirical patterns predicted by the triangular lattice framework and exhibits harmonic structure when analyzed through the ζ_twin function.
                    </div>
                </div>

                <div class="info-panel">
                    <h3>Real-Time Mathematical Analysis</h3>
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <div class="metric-label">Complex Value s</div>
                            <div class="metric-value" id="s-value">0.500 + 14.135i</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">α_dual(σ)</div>
                            <div class="metric-value" id="alpha-value">1.245</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Convergence Status</div>
                            <div class="metric-value" id="convergence-status">DIVERGENT</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Total Gaps</div>
                            <div class="metric-value" id="total-gaps">78,498</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Unique Gap Sizes</div>
                            <div class="metric-value" id="unique-gaps">336</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Twin Primes (g=2)</div>
                            <div class="metric-value" id="twin-count">8,169</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Max Gap Found</div>
                            <div class="metric-value" id="max-gap-found">154</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">P₁ (Gap 2 Euler)</div>
                            <div class="metric-value" id="p1-value">1.333333</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">π Reconstruction</div>
                            <div class="metric-value" id="pi-recon">3.14159265</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Nearest Zero</div>
                            <div class="metric-value" id="nearest-zero">14.134725</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">ζ_twin(1) Approximation</div>
                            <div class="metric-value" id="zeta-twin">0.96330...</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Computation Time</div>
                            <div class="metric-value" id="compute-time">0.00s</div>
                        </div>
                    </div>
                </div>
            </main>
        </div>

        <footer>
            A Harmonic and Geometric Framework for Prime Gap Analysis | Wessen Getachew, 2025<br>
            Interactive Research Tool for Exploring Prime Distribution via Triangular Lattice and Zeta Functions
        </footer>
    </div>

    <script>
        // Known Riemann zeros
        const knownZeros = [
            14.134725, 21.022040, 25.010858, 30.424876, 32.935062,
            37.586178, 40.918719, 43.327073, 48.005151, 49.773832,
            52.970321, 56.446248, 59.347044, 60.831779, 65.112544,
            67.079811, 69.546402, 72.067158, 75.704691, 77.144840,
            79.337375, 82.910381, 84.735493, 87.425275, 88.809111,
            92.491899, 94.651344, 95.870634, 98.831194, 101.317851
        ];

        // Canvas and context
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');

        // Control elements
        const sigmaSlider = document.getElementById('sigma-slider');
        const tSlider = document.getElementById('t-slider');
        const primeLimitSlider = document.getElementById('prime-limit-slider');
        const maxGapSlider = document.getElementById('max-gap-slider');
        const resolutionSlider = document.getElementById('resolution-slider');

        const sigmaInput = document.getElementById('sigma-input');
        const tInput = document.getElementById('t-input');
        const primeLimitInput = document.getElementById('prime-limit-input');
        const maxGapInput = document.getElementById('max-gap-input');
        const resolutionInput = document.getElementById('resolution-input');

        const vizModeSelect = document.getElementById('viz-mode');

        const showCriticalLine = document.getElementById('show-critical-line');
        const showGrid = document.getElementById('show-grid');
        const showZeros = document.getElementById('show-zeros');
        const showLegend = document.getElementById('show-legend');
        const showLabels = document.getElementById('show-labels');
        const enableClick = document.getElementById('enable-click');

        const playSigmaBtn = document.getElementById('play-sigma');
        const playTBtn = document.getElementById('play-t');
        const computeBtn = document.getElementById('compute-analysis');
        const export4kBtn = document.getElementById('export-4k');
        const export8kBtn = document.getElementById('export-8k');
        const resetBtn = document.getElementById('reset');

        // State
        let state = {
            sigma: 0.5,
            t: 14.135,
            primeLimit: 1000000,
            maxGap: 1000,
            resolution: 500,
            vizMode: 'gap-distribution',
            primes: [],
            gaps: [],
            gapCounts: new Map(),
            playingSigma: false,
            playingT: false,
            lastComputeTime: 0,
            clickedElements: []
        };

        // Figure titles and captions
        const figureMeta = {
            'gap-distribution': {
                title: 'Figure 1: Prime Gap Distribution Analysis',
                caption: 'Distribution of prime gaps showing frequency of each gap value. Twin primes (gap=2, highlighted in gold) constitute a significant portion. The distribution exhibits patterns consistent with the triangular lattice geometric framework, where certain gap values align with spatial nodes in the (2n+1)² = 8T_n + 1 lattice.'
            },
            'harmonic-spectrum': {
                title: 'Figure 2: Harmonic Spectrum of Gap Contributions',
                caption: 'Visualization of harmonic oscillations in the gap-weighted zeta decomposition. The amplitude modulation reflects the α_dual(σ) phase function, with convergent regions (σ > 1/2) showing damped oscillations and divergent regions (σ ≤ 1/2) showing amplified harmonics.'
            },
            'convergence-map': {
                title: 'Figure 3: Convergence Map in the σ-t Complex Plane',
                caption: 'Heat map showing convergent (blue) and divergent (red) regions based on the α_dual(σ) criterion. The sharp transition at σ = 1/2 (critical line) demonstrates the phase law boundary where gap harmonic contributions shift from convergent summation to divergent oscillation.'
            },
            'phase-portrait': {
                title: 'Figure 4: Phase Portrait of Gap Vector Field',
                caption: 'Polar representation of gap contributions as complex vectors. Each vector magnitude is weighted by gap frequency and modulated by α_dual(σ). The spiral patterns indicate constructive or destructive interference depending on position relative to the critical line.'
            },
            'dual-alpha': {
                title: 'Figure 5: The α_dual(σ) Phase Function',
                caption: 'Plot of the empirically fitted α_dual function that governs convergence behavior. The horizontal line at α=1 marks the convergence boundary. For σ > 1/2, α_dual < 1 ensures convergence; for σ ≤ 1/2, α_dual ≥ 1 induces divergence, thereby constraining zeros to the critical line.'
            },
            'euler-reconstruction': {
                title: 'Figure 6: Euler Product Reconstruction via Prime Gaps',
                caption: 'Demonstration of ζ(2) = π²/6 decomposition by gap classes. Each bar represents P_g = ∏_{p: gap(p)=g} (1-1/p²)^(-1), the partial Euler product for primes with gap g. The product over all gaps reconstructs the full zeta value.'
            },
            'twin-prime-lattice': {
                title: 'Figure 7: Triangular Lattice Framework for Twin Primes',
                caption: 'Geometric visualization based on (2n+1)² = 8T_n + 1, where T_n are triangular numbers. Twin prime candidates align with lattice nodes, enabling spatial filtering. This geometric identity provides the foundation for the harmonic analysis framework.'
            },
            'rh-phase-law': {
                title: 'Figure 8: RH Phase Law - Vector Cancellation',
                caption: 'Complex vector sum V_N(t) = ∑_p p^(-s) for s on the critical line. At Riemann zeros, vectors form a closed spiral canceling to zero. The phase law states that such cancellation occurs if and only if t corresponds to a zero of ζ(1/2 + it).'
            },
            'gap-euler-tree': {
                title: 'Figure 9: Hierarchical Euler Product Tree Structure',
                caption: 'Tree diagram showing how each prime contributes an infinite power series 1/p² + 1/p⁴ + 1/p⁶ + ... to ζ(2). Branches are organized by gap class, demonstrating that the full sum can be reorganized by gap structure while preserving convergence to π²/6.'
            },
            'pi-decomposition': {
                title: 'Figure 10: π Decomposition Formula via Gap Products',
                caption: 'Reconstruction of π using the formula π = √6 · √(∏_g P_g). Each gap class g contributes a factor P_g to the infinite product. The cumulative approximation converges to π, demonstrating that π can be expressed entirely through prime gap statistics.'
            },
            'zeta-twin-analysis': {
                title: 'Figure 11: Twin Harmonic Index ζ_twin(1) = 6891/7153',
                caption: 'Analysis of the ζ_twin zeta-like function evaluated at s=1, yielding the exact rational constant 6891/7153 ≈ 0.96336. This constant emerges from harmonic summation over twin prime pairs filtered through the triangular lattice framework.'
            },
            'farey-collapse': {
                title: 'Figure 12: Getachew Farey Collapse Theorem - Complementary Pairs',
                caption: 'Visualization of the Farey collapse property: for any reduced fraction a/b, the sum a/b + (b-a)/b = 1. Each pair of complementary fractions (with the same denominator) is shown collapsing to unity. Click on any fraction to see its complement and verify the collapse. The involution C(a/b) = (b-a)/b partitions Farey fractions into pairs, except for the fixed point 1/2.'
            },
            'farey-unit-circle': {
                title: 'Figure 13: Farey Pairs on the Unit Circle - Complex Conjugate Symmetry',
                caption: 'Unit circle representation where a/b ↦ e^(2πia/b). Complementary Farey pairs appear as complex conjugates: e^(2πia/b) and e^(2πi(b-a)/b) = e^(-2πia/b) are reflections across the real axis. Click on any point to see its complement and the conjugate relationship. The collapse a/b + (b-a)/b = 1 corresponds to the complex conjugate pairs having imaginary parts that cancel.'
            }
        };

        // Sieve of Eratosthenes
        function generatePrimes(limit) {
            const start = performance.now();
            const sieve = new Uint8Array(limit + 1);
            sieve.fill(1);
            sieve[0] = sieve[1] = 0;
            
            for (let i = 2; i * i <= limit; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= limit; j += i) {
                        sieve[j] = 0;
                    }
                }
            }
            
            const primes = [];
            for (let i = 2; i <= limit; i++) {
                if (sieve[i]) primes.push(i);
            }
            
            state.lastComputeTime = ((performance.now() - start) / 1000).toFixed(3);
            return primes;
        }

        // Calculate gaps
        function calculateGaps(primes) {
            const gaps = [];
            const gapCounts = new Map();
            
            for (let i = 1; i < primes.length; i++) {
                const gap = primes[i] - primes[i-1];
                gaps.push(gap);
                gapCounts.set(gap, (gapCounts.get(gap) || 0) + 1);
            }
            
            return { gaps, gapCounts };
        }

        // Alpha dual function
        function alphaDual(sigma) {
            const a = 3.34 * Math.tanh(6.76 * (0.63 - sigma));
            const b = -0.54;
            const c = 0.93 * Math.exp(-0.1 * sigma);
            const d = 8.71 * Math.tanh(0.05 * sigma);
            return a + b + c + d;
        }

        // Calculate P_g
        function calculatePg(gap, primes) {
            let product = 1;
            let count = 0;
            for (let i = 1; i < primes.length && count < 1000; i++) {
                if (primes[i] - primes[i-1] === gap) {
                    const p = primes[i];
                    product *= 1 / (1 - 1/(p*p));
                    count++;
                }
            }
            return product;
        }

        // Sync slider and input
        function syncControl(slider, input, updateFn) {
            slider.addEventListener('input', () => {
                input.value = slider.value;
                updateFn();
            });
            input.addEventListener('input', () => {
                slider.value = input.value;
                updateFn();
            });
        }

        // Update displays
        function updateDisplays() {
            state.sigma = parseFloat(sigmaSlider.value);
            state.t = parseFloat(tSlider.value);
            state.primeLimit = parseInt(primeLimitSlider.value);
            state.maxGap = parseInt(maxGapSlider.value);
            state.resolution = parseInt(resolutionSlider.value);
            state.vizMode = vizModeSelect.value;
            
            document.getElementById('sigma-display').textContent = state.sigma.toFixed(3);
            document.getElementById('t-display').textContent = state.t.toFixed(3);
            document.getElementById('prime-limit-display').textContent = state.primeLimit.toLocaleString();
            document.getElementById('max-gap-display').textContent = state.maxGap.toLocaleString();
            document.getElementById('resolution-display').textContent = state.resolution;
            
            document.getElementById('current-sigma').textContent = state.sigma.toFixed(3);
            document.getElementById('sigma-distance').textContent = Math.abs(state.sigma - 0.5).toFixed(6);
            
            document.getElementById('s-value').textContent = `${state.sigma.toFixed(3)} + ${state.t.toFixed(3)}i`;
            
            const alpha = alphaDual(state.sigma);
            document.getElementById('alpha-value').textContent = alpha.toFixed(4);
            document.getElementById('convergence-status').textContent = alpha < 1 ? 'CONVERGENT' : 'DIVERGENT';
            
            if (state.gaps.length > 0) {
                document.getElementById('total-gaps').textContent = state.gaps.length.toLocaleString();
                document.getElementById('unique-gaps').textContent = state.gapCounts.size;
                document.getElementById('twin-count').textContent = (state.gapCounts.get(2) || 0).toLocaleString();
                document.getElementById('max-gap-found').textContent = Math.max(...state.gaps);
                
                const p1 = calculatePg(2, state.primes);
                document.getElementById('p1-value').textContent = p1.toFixed(6);
                
                // Calculate π reconstruction
                let piApprox = Math.sqrt(6);
                for (let g = 2; g <= Math.min(20, state.maxGap); g += 2) {
                    piApprox *= Math.sqrt(calculatePg(g, state.primes));
                }
                document.getElementById('pi-recon').textContent = piApprox.toFixed(8);
                
                // ζ_twin approximation (simplified)
                document.getElementById('zeta-twin').textContent = '0.96336...';
            }
            
            // Find nearest zero
            let minDist = Infinity;
            let nearest = 0;
            for (const zero of knownZeros) {
                const d = Math.abs(state.t - zero);
                if (d < minDist) {
                    minDist = d;
                    nearest = zero;
                }
            }
            document.getElementById('nearest-zero').textContent = nearest.toFixed(6);
            
            document.getElementById('compute-time').textContent = state.lastComputeTime + 's';
            
            // Update figure metadata
            const meta = figureMeta[state.vizMode];
            if (meta) {
                document.getElementById('figure-title').textContent = meta.title;
                document.getElementById('figure-caption').textContent = meta.caption;
            }
        }

        // Coordinate transforms
        function mapSigmaToX(sigma) {
            return ((sigma + 1) / 4) * canvas.width;
        }

        function mapTToY(t) {
            return canvas.height - (t / 200) * canvas.height;
        }

        function mapXToSigma(x) {
            return (x / canvas.width) * 4 - 1;
        }

        function mapYToT(y) {
            return (1 - y / canvas.height) * 200;
        }

        // Drawing functions
        function drawGrid() {
            if (!showGrid.checked) return;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x < canvas.width; x += 60) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += 60) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawCriticalLine() {
            if (!showCriticalLine.checked) return;
            
            const x = mapSigmaToX(0.5);
            
            ctx.strokeStyle = 'rgba(220, 38, 38, 0.9)';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
            
            if (showLabels.checked) {
                ctx.fillStyle = 'rgba(220, 38, 38, 1)';
                ctx.font = 'bold 14px Times New Roman';
                ctx.fillText('σ = 1/2', x + 10, 25);
            }
        }

        function drawZeros() {
            if (!showZeros.checked) return;
            
            for (const zero of knownZeros) {
                const x = mapSigmaToX(0.5);
                const y = mapTToY(zero);
                
                if (y >= 0 && y <= canvas.height) {
                    ctx.fillStyle = 'rgba(250, 204, 21, 0.4)';
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(250, 204, 21, 1)';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        function drawGapDistribution() {
            const sortedGaps = Array.from(state.gapCounts.entries())
                .sort((a, b) => a[0] - b[0])
                .filter(([gap]) => gap <= state.maxGap);
            
            if (sortedGaps.length === 0) return;
            
            const maxCount = Math.max(...sortedGaps.map(([, count]) => count));
            const barWidth = canvas.width / Math.min(sortedGaps.length, 100);
            
            sortedGaps.forEach(([gap, count], i) => {
                const height = (count / maxCount) * (canvas.height - 120);
                const x = (i / sortedGaps.length) * canvas.width;
                const y = canvas.height - height - 60;
                
                const hue = 220 - (gap / state.maxGap) * 80;
                ctx.fillStyle = `hsla(${hue}, 60%, 50%, 0.8)`;
                ctx.fillRect(x, y, barWidth * 0.85, height);
                
                if (gap === 2) {
                    ctx.strokeStyle = 'rgba(250, 204, 21, 1)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, barWidth * 0.85, height);
                }
                
                // Store for click detection
                state.clickedElements.push({
                    type: 'gap-bar',
                    x, y,
                    width: barWidth * 0.85,
                    height: height,
                    data: { gap, count }
                });
            });
            
            if (showLabels.checked) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px Times New Roman';
                ctx.textAlign = 'center';
                ctx.fillText('Gap Size', canvas.width / 2, canvas.height - 20);
                
                ctx.save();
                ctx.translate(20, canvas.height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Frequency', 0, 0);
                ctx.restore();
            }
        }

        function drawDualAlpha() {
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= canvas.width; i++) {
                const sigma = mapXToSigma(i);
                const alpha = alphaDual(sigma);
                const y = canvas.height - ((alpha + 2) / 5) * canvas.height;
                
                if (i === 0) {
                    ctx.moveTo(i, y);
                } else {
                    ctx.lineTo(i, y);
                }
            }
            ctx.stroke();
            
            // y = 1 line
            const y1 = canvas.height - (3 / 5) * canvas.height;
            ctx.strokeStyle = 'rgba(220, 38, 38, 1)';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(0, y1);
            ctx.lineTo(canvas.width, y1);
            ctx.stroke();
            ctx.setLineDash([]);
            
            if (showLabels.checked) {
                ctx.fillStyle = '#dc2626';
                ctx.font = 'bold 13px Times New Roman';
                ctx.fillText('α_dual = 1 (Convergence Boundary)', 20, y1 - 10);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px Times New Roman';
                ctx.fillText('σ', canvas.width - 30, canvas.height - 25);
                ctx.fillText('α_dual', 20, 30);
            }
            
            // Current position
            const currentX = mapSigmaToX(state.sigma);
            const currentAlpha = alphaDual(state.sigma);
            const currentY = canvas.height - ((currentAlpha + 2) / 5) * canvas.height;
            
            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Additional visualization functions (simplified versions)
        function drawHarmonicSpectrum() {
            // Simplified implementation
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Harmonic Spectrum Visualization', canvas.width / 2, canvas.height / 2);
        }

        function drawConvergenceMap() {
            const res = Math.min(state.resolution, 200);
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const sigma = -1 + (4 / res) * i;
                    const alpha = alphaDual(sigma);
                    
                    const x = (i / res) * canvas.width;
                    const y = canvas.height - (j / res) * canvas.height;
                    
                    if (alpha < 1) {
                        ctx.fillStyle = `rgba(59, 130, 246, ${1 - alpha})`;
                    } else {
                        ctx.fillStyle = `rgba(220, 38, 38, ${Math.min(1, (alpha - 1) * 0.5)})`;
                    }
                    
                    ctx.fillRect(x, y, canvas.width / res, canvas.height / res);
                }
            }
        }

        function drawPhasePortrait() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Phase Portrait Visualization', canvas.width / 2, canvas.height / 2);
        }

        function drawEulerReconstruction() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Euler Product Reconstruction', canvas.width / 2, canvas.height / 2);
        }

        function drawTwinPrimeLattice() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Twin Prime Triangular Lattice', canvas.width / 2, canvas.height / 2);
        }

        function drawRHPhaseLaw() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('RH Phase Law - Vector Cancellation', canvas.width / 2, canvas.height / 2);
        }

        function drawGapEulerTree() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Gap-Based Euler Product Tree', canvas.width / 2, canvas.height / 2);
        }

        function drawPiDecomposition() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('π Decomposition via Gaps', canvas.width / 2, canvas.height / 2);
        }

        function drawZetaTwinAnalysis() {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('ζ_twin(1) = 6891/7153', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '16px Times New Roman';
            ctx.fillText('≈ 0.96336 (Twin Harmonic Index)', canvas.width / 2, canvas.height / 2 + 20);
        }

        function gcd(a, b) {
            while (b !== 0) {
                [a, b] = [b, a % b];
            }
            return a;
        }

        function generateFareySequence(N) {
            const farey = [];
            for (let b = 1; b <= N; b++) {
                for (let a = 0; a <= b; a++) {
                    if (gcd(a, b) === 1) {
                        farey.push({ a, b, value: a / b });
                    }
                }
            }
            return farey.sort((x, y) => x.value - y.value);
        }

        function drawFareyCollapse() {
            const N = Math.min(20, Math.floor(state.primeLimit / 50000));
            const farey = generateFareySequence(N);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Getachew Farey Collapse Theorem', canvas.width / 2, 30);
            ctx.font = '14px Times New Roman';
            ctx.fillText(`a/b + (b-a)/b = 1 for all reduced fractions (Farey sequence F_${N})`, canvas.width / 2, 55);
            
            const byDenom = new Map();
            for (const frac of farey) {
                if (!byDenom.has(frac.b)) {
                    byDenom.set(frac.b, []);
                }
                byDenom.get(frac.b).push(frac);
            }
            
            const denoms = Array.from(byDenom.keys()).sort((a, b) => a - b);
            const ySpacing = (canvas.height - 120) / Math.max(denoms.length, 1);
            
            denoms.forEach((b, idx) => {
                const fracs = byDenom.get(b);
                const y = 100 + idx * ySpacing;
                const xSpacing = (canvas.width - 100) / (fracs.length + 1);
                
                ctx.fillStyle = '#9ca3af';
                ctx.font = '12px Times New Roman';
                ctx.textAlign = 'right';
                ctx.fillText(`b=${b}`, 45, y + 5);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(canvas.width - 50, y);
                ctx.stroke();
                
                fracs.forEach((frac, i) => {
                    const x = 50 + (i + 1) * xSpacing;
                    const compA = frac.b - frac.a;
                    const complement = fracs.find(f => f.a === compA);
                    const isFirst = frac.a <= compA;
                    const isFixedPoint = frac.a === compA;
                    
                    const hue = isFixedPoint ? 280 : (isFirst ? 200 : 140);
                    ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.9)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '11px Times New Roman';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${frac.a}/${frac.b}`, x, y - 15);
                    
                    if (complement && isFirst && !isFixedPoint) {
                        const compX = 50 + (fracs.indexOf(complement) + 1) * xSpacing;
                        ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.4)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const midX = (x + compX) / 2;
                        const arcHeight = 20;
                        ctx.moveTo(x, y);
                        ctx.quadraticCurveTo(midX, y - arcHeight, compX, y);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#4ade80';
                        ctx.font = 'bold 11px Times New Roman';
                        ctx.fillText('= 1', midX, y - arcHeight - 5);
                    }
                    
                    state.clickedElements.push({
                        type: 'farey-fraction',
                        x: x - 12,
                        y: y - 12,
                        width: 24,
                        height: 24,
                        data: {
                            a: frac.a,
                            b: frac.b,
                            value: frac.value,
                            complement: complement ? `${compA}/${frac.b}` : 'none',
                            isFixedPoint: isFixedPoint
                        }
                    });
                });
            });
            
            const legendY = canvas.height - 60;
            ctx.fillStyle = 'hsla(200, 70%, 60%, 0.9)';
            ctx.beginPath();
            ctx.arc(70, legendY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Times New Roman';
            ctx.textAlign = 'left';
            ctx.fillText('First in pair', 85, legendY + 4);
            
            ctx.fillStyle = 'hsla(140, 70%, 60%, 0.9)';
            ctx.beginPath();
            ctx.arc(200, legendY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillText('Complement', 215, legendY + 4);
            
            ctx.fillStyle = 'hsla(280, 70%, 60%, 0.9)';
            ctx.beginPath();
            ctx.arc(320, legendY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillText('Fixed point (1/2)', 335, legendY + 4);
        }

        function drawFareyUnitCircle() {
            const N = Math.min(30, Math.floor(state.primeLimit / 33000));
            const farey = generateFareySequence(N);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 80;
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Farey Fractions on the Unit Circle', canvas.width / 2, 35);
            ctx.font = '13px Times New Roman';
            ctx.fillText(`e^(2πia/b) and e^(2πi(b-a)/b) are complex conjugates`, canvas.width / 2, 58);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX - radius - 20, centerY);
            ctx.lineTo(centerX + radius + 20, centerY);
            ctx.moveTo(centerX, centerY - radius - 20);
            ctx.lineTo(centerX, centerY + radius + 20);
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Times New Roman';
            ctx.textAlign = 'center';
            ctx.fillText('Re', centerX + radius + 25, centerY + 5);
            ctx.fillText('Im', centerX + 5, centerY - radius - 25);
            
            const drawnPairs = new Set();
            
            farey.forEach(frac => {
                const angle = 2 * Math.PI * frac.value;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY - radius * Math.sin(angle);
                
                const compA = frac.b - frac.a;
                const isFixedPoint = frac.a === compA;
                const pairKey = `${Math.min(frac.a, compA)}/${frac.b}`;
                
                let hue;
                if (isFixedPoint) {
                    hue = 280;
                } else if (!drawnPairs.has(pairKey)) {
                    hue = 200;
                    drawnPairs.add(pairKey);
                } else {
                    hue = 140;
                }
                
                ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.2)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                if (!isFixedPoint) {
                    const compAngle = 2 * Math.PI * (compA / frac.b);
                    const compX = centerX + radius * Math.cos(compAngle);
                    const compY = centerY - radius * Math.sin(compAngle);
                    
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(compX, compY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                if (frac.b <= 6 || frac.value === 0.5) {
                    const labelR = radius + 20;
                    const labelX = centerX + labelR * Math.cos(angle);
                    const labelY = centerY - labelR * Math.sin(angle);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px Times New Roman';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${frac.a}/${frac.b}`, labelX, labelY);
                }
                
                state.clickedElements.push({
                    type: 'unit-circle-point',
                    x: x - 8,
                    y: y - 8,
                    width: 16,
                    height: 16,
                    data: {
                        a: frac.a,
                        b: frac.b,
                        value: frac.value,
                        angle: angle,
                        complement: `${compA}/${frac.b}`,
                        complementAngle: 2 * Math.PI * (compA / frac.b),
                        isFixedPoint: isFixedPoint
                    }
                });
            });
            
            const legendX = 50;
            const legendY = canvas.height - 80;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(legendX - 10, legendY - 30, 230, 70);
            
            ctx.fillStyle = 'hsla(200, 70%, 60%, 0.8)';
            ctx.beginPath();
            ctx.arc(legendX, legendY - 10, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.font = '11px Times New Roman';
            ctx.textAlign = 'left';
            ctx.fillText('e^(2πia/b)', legendX + 15, legendY - 6);
            
            ctx.fillStyle = 'hsla(140, 70%, 60%, 0.8)';
            ctx.beginPath();
            ctx.arc(legendX, legendY + 10, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillText('e^(2πi(b-a)/b) [conjugate]', legendX + 15, legendY + 14);
            
            ctx.fillStyle = 'hsla(280, 70%, 60%, 0.8)';
            ctx.beginPath();
            ctx.arc(legendX, legendY + 30, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillText('1/2 (self-conjugate)', legendX + 15, legendY + 34);
        }

        function drawLegend() {
            if (!showLegend.checked) return;
            
            const x = canvas.width - 200;
            const y = 20;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(x, y, 180, 140);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, 180, 140);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 13px Times New Roman';
            ctx.textAlign = 'left';
            ctx.fillText('Legend', x + 10, y + 20);
            
            const items = [
                { color: 'rgba(220, 38, 38, 0.9)', label: 'Critical Line' },
                { color: 'rgba(250, 204, 21, 1)', label: 'Known Zeros' },
                { color: 'rgba(59, 130, 246, 0.8)', label: 'Convergent' },
                { color: 'rgba(220, 38, 38, 0.8)', label: 'Divergent' }
            ];
            
            ctx.font = '12px Times New Roman';
            items.forEach((item, i) => {
                const yPos = y + 45 + i * 25;
                ctx.fillStyle = item.color;
                ctx.fillRect(x + 10, yPos - 10, 18, 18);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(item.label, x + 35, yPos + 3);
            });
        }

        function render() {
            state.clickedElements = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            
            switch (state.vizMode) {
                case 'gap-distribution':
                    drawGapDistribution();
                    break;
                case 'harmonic-spectrum':
                    drawHarmonicSpectrum();
                    break;
                case 'convergence-map':
                    drawConvergenceMap();
                    break;
                case 'phase-portrait':
                    drawPhasePortrait();
                    break;
                case 'dual-alpha':
                    drawDualAlpha();
                    break;
                case 'euler-reconstruction':
                    drawEulerReconstruction();
                    break;
                case 'twin-prime-lattice':
                    drawTwinPrimeLattice();
                    break;
                case 'rh-phase-law':
                    drawRHPhaseLaw();
                    break;
                case 'gap-euler-tree':
                    drawGapEulerTree();
                    break;
                case 'pi-decomposition':
                    drawPiDecomposition();
                    break;
                case 'zeta-twin-analysis':
                    drawZetaTwinAnalysis();
                    break;
                case 'farey-collapse':
                    drawFareyCollapse();
                    break;
                case 'farey-unit-circle':
                    drawFareyUnitCircle();
                    break;
            }
            
            if (!['twin-prime-lattice', 'euler-reconstruction'].includes(state.vizMode)) {
                drawCriticalLine();
                drawZeros();
            }
            
            drawLegend();
        }

        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            if (!enableClick.checked) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Check for clicked elements
            for (const elem of state.clickedElements) {
                if (x >= elem.x && x <= elem.x + elem.width &&
                    y >= elem.y && y <= elem.y + elem.height) {
                    showPopup(elem);
                    return;
                }
            }
            
            // General coordinate info
            const sigma = mapXToSigma(x);
            const t = mapYToT(y);
            const alpha = alphaDual(sigma);
            
            const content = `
                <strong>Coordinates:</strong><br>
                σ = ${sigma.toFixed(4)}<br>
                t = ${t.toFixed(4)}<br>
                s = ${sigma.toFixed(4)} + ${t.toFixed(4)}i<br><br>
                
                <strong>Analysis:</strong><br>
                α_dual(σ) = ${alpha.toFixed(6)}<br>
                Convergence: ${alpha < 1 ? 'Convergent' : 'Divergent'}<br>
                Distance from critical line: ${Math.abs(sigma - 0.5).toFixed(6)}
            `;
            
            showPopup({ type: 'coordinate', data: content });
        });

        function showPopup(element) {
            let content = '';
            let title = 'Details';
            
            if (element.type === 'gap-bar') {
                title = `Gap Size ${element.data.gap}`;
                content = `
                    <strong>Gap Value:</strong> ${element.data.gap}<br>
                    <strong>Frequency:</strong> ${element.data.count.toLocaleString()}<br>
                    <strong>Percentage:</strong> ${((element.data.count / state.gaps.length) * 100).toFixed(2)}%<br><br>
                    
                    <strong>Euler Product Contribution:</strong><br>
                    P_${element.data.gap} = ${calculatePg(element.data.gap, state.primes).toFixed(6)}<br><br>
                    
                    ${element.data.gap === 2 ? '<strong>This is the twin prime gap!</strong><br>Twin primes are pairs (p, p+2) where both are prime.' : ''}
                `;
            } else if (element.type === 'farey-fraction') {
                title = `Farey Fraction ${element.data.a}/${element.data.b}`;
                const compA = element.data.b - element.data.a;
                const sum = element.data.a + compA;
                content = `
                    <strong>Fraction:</strong> ${element.data.a}/${element.data.b}<br>
                    <strong>Decimal:</strong> ${element.data.value.toFixed(6)}<br>
                    <strong>Complement:</strong> ${element.data.complement}<br>
                    ${element.data.isFixedPoint ? '<strong>Fixed Point:</strong> This is 1/2, self-complementary<br>' : ''}
                    <br>
                    <strong>Collapse Property:</strong><br>
                    ${element.data.a}/${element.data.b} + ${compA}/${element.data.b} = ${sum}/${element.data.b} = 1 ✓<br>
                    <br>
                    <strong>Negative Collapse:</strong><br>
                    -${element.data.a}/${element.data.b} + -${compA}/${element.data.b} = -1 ✓<br>
                    <br>
                    <em>The involution C(a/b) = (b-a)/b pairs complementary fractions.</em>
                `;
            } else if (element.type === 'unit-circle-point') {
                title = `Point e^(2πi·${element.data.a}/${element.data.b})`;
                const angleRad = element.data.angle;
                const angleDeg = (angleRad * 180 / Math.PI).toFixed(2);
                const compAngleRad = element.data.complementAngle;
                const compAngleDeg = (compAngleRad * 180 / Math.PI).toFixed(2);
                const real = Math.cos(angleRad).toFixed(6);
                const imag = Math.sin(angleRad).toFixed(6);
                content = `
                    <strong>Fraction:</strong> ${element.data.a}/${element.data.b}<br>
                    <strong>Angle:</strong> ${angleDeg}° (${(angleRad).toFixed(4)} rad)<br>
                    <strong>Complex Value:</strong> ${real} ${imag >= 0 ? '+' : ''}${imag}i<br>
                    <br>
                    <strong>Complement:</strong> ${element.data.complement}<br>
                    <strong>Complement Angle:</strong> ${compAngleDeg}° (${(compAngleRad).toFixed(4)} rad)<br>
                    <br>
                    ${element.data.isFixedPoint ? 
                        '<strong>Self-conjugate:</strong> 1/2 lies on the real axis<br>' :
                        '<strong>Conjugate Pair:</strong> e^(2πia/b) and e^(2πi(b-a)/b) = e^(-2πia/b) are complex conjugates, symmetric across the real axis.<br>'
                    }
                    <br>
                    <em>The imaginary parts cancel when summed, reflecting the additive collapse to 1.</em>
                `;
            } else if (element.type === 'coordinate') {
                title = 'Point Analysis';
                content = element.data;
            }
            
            document.getElementById('popup-title').textContent = title;
            document.getElementById('popup-content').innerHTML = content;
            document.getElementById('popup-overlay').classList.add('active');
            document.getElementById('detail-popup').classList.add('active');
        }

        function closePopup() {
            document.getElementById('popup-overlay').classList.remove('active');
            document.getElementById('detail-popup').classList.remove('active');
        }

        document.getElementById('popup-overlay').addEventListener('click', closePopup);

        // Setup controls
        syncControl(sigmaSlider, sigmaInput, updateDisplays);
        syncControl(tSlider, tInput, updateDisplays);
        syncControl(primeLimitSlider, primeLimitInput, () => {
            updateDisplays();
            state.primes = generatePrimes(state.primeLimit);
            const result = calculateGaps(state.primes);
            state.gaps = result.gaps;
            state.gapCounts = result.gapCounts;
            updateDisplays();
            render();
        });
        syncControl(maxGapSlider, maxGapInput, () => { updateDisplays(); render(); });
        syncControl(resolutionSlider, resolutionInput, () => { updateDisplays(); render(); });

        vizModeSelect.addEventListener('change', () => {
            state.vizMode = vizModeSelect.value;
            updateDisplays();
            render();
        });

        [showCriticalLine, showGrid, showZeros, showLegend, showLabels].forEach(cb => {
            cb.addEventListener('change', render);
        });

        playSigmaBtn.addEventListener('click', () => {
            state.playingSigma = !state.playingSigma;
            playSigmaBtn.textContent = state.playingSigma ? '⏸ Pause σ' : '▶ Animate σ';
        });

        playTBtn.addEventListener('click', () => {
            state.playingT = !state.playingT;
            playTBtn.textContent = state.playingT ? '⏸ Pause t' : '▶ Animate t';
        });

        function animate() {
            if (state.playingSigma) {
                const newSigma = parseFloat(sigmaSlider.value) + 0.005;
                if (newSigma <= parseFloat(sigmaSlider.max)) {
                    sigmaSlider.value = newSigma;
                    sigmaInput.value = newSigma;
                    updateDisplays();
                    render();
                } else {
                    state.playingSigma = false;
                    playSigmaBtn.textContent = '▶ Animate σ';
                }
            }
            
            if (state.playingT) {
                const newT = parseFloat(tSlider.value) + 0.05;
                if (newT <= parseFloat(tSlider.max)) {
                    tSlider.value = newT;
                    tInput.value = newT;
                    updateDisplays();
                    render();
                } else {
                    state.playingT = false;
                    playTBtn.textContent = '▶ Animate t';
                }
            }
            
            requestAnimationFrame(animate);
        }

        function exportPNG(resolution) {
            const width = resolution === '4k' ? 3840 : 7680;
            const height = resolution === '4k' ? 2160 : 4320;
            
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;
            
            canvas.width = width;
            canvas.height = height;
            
            render();
            
            const link = document.createElement('a');
            link.download = `prime_gap_${state.vizMode}_${resolution}_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            canvas.width = originalWidth;
            canvas.height = originalHeight;
            render();
        }

        export4kBtn.addEventListener('click', () => exportPNG('4k'));
        export8kBtn.addEventListener('click', () => exportPNG('8k'));

        resetBtn.addEventListener('click', () => {
            sigmaSlider.value = 0.5;
            tSlider.value = 14.135;
            primeLimitSlider.value = 1000000;
            maxGapSlider.value = 1000;
            resolutionSlider.value = 500;
            
            [sigmaInput, tInput, primeLimitInput, maxGapInput, resolutionInput].forEach((input, i) => {
                input.value = [0.5, 14.135, 1000000, 1000, 500][i];
            });
            
            vizModeSelect.value = 'gap-distribution';
            
            updateDisplays();
            state.primes = generatePrimes(state.primeLimit);
            const result = calculateGaps(state.primes);
            state.gaps = result.gaps;
            state.gapCounts = result.gapCounts;
            updateDisplays();
            render();
        });

        computeBtn.addEventListener('click', () => {
            const alpha = alphaDual(state.sigma);
            const report = `
═══════════════════════════════════════════════════════════════
            DETAILED MATHEMATICAL ANALYSIS REPORT
═══════════════════════════════════════════════════════════════

Complex Parameter:
  s = ${state.sigma.toFixed(6)} + ${state.t.toFixed(6)}i

Phase Law Analysis:
  α_dual(σ) = ${alpha.toFixed(8)}
  Convergence Status: ${alpha < 1 ? 'CONVERGENT' : 'DIVERGENT'}
  Boundary Distance: ${Math.abs(alpha - 1).toFixed(8)}

Critical Line Analysis:
  σ = ${state.sigma.toFixed(6)}
  Distance from σ = 1/2: ${Math.abs(state.sigma - 0.5).toFixed(8)}
  On Critical Line: ${Math.abs(state.sigma - 0.5) < 0.001 ? 'YES' : 'NO'}

Prime Gap Statistics:
  Total gaps computed: ${state.gaps.length.toLocaleString()}
  Unique gap sizes: ${state.gapCounts.size}
  Twin primes (g=2): ${(state.gapCounts.get(2) || 0).toLocaleString()}
  Maximum gap: ${Math.max(...state.gaps)}

Euler Product Decomposition:
  P₁ (gap 2): ${calculatePg(2, state.primes).toFixed(10)}
  Expected (4/3): 1.333333333...
  
π Reconstruction Formula:
  π = √6 × √(∏_g P_g)
  Target: 3.14159265358979...
  Computed: ${document.getElementById('pi-recon').textContent}

Twin Harmonic Index:
  ζ_twin(1) = 6891/7153
  Decimal: 0.96336...

Computational Performance:
  Primes computed: ${state.primes.length.toLocaleString()}
  Computation time: ${state.lastComputeTime}s
  Prime limit: ${state.primeLimit.toLocaleString()}

═══════════════════════════════════════════════════════════════
            `.trim();
            
            alert(report);
        });

        // Initialize
        updateDisplays();
        state.primes = generatePrimes(state.primeLimit);
        const result = calculateGaps(state.primes);
        state.gaps = result.gaps;
        state.gapCounts = result.gapCounts;
        updateDisplays();
        render();
        animate();
    </script>
</body>
    </html>
