
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Channel Projection Corollary</title>
    <style>
        :root {
            --bg-color: #0f1115;
            --panel-bg: #161b22;
            --text-main: #e6edf3;
            --text-muted: #8b949e;
            --accent: #58a6ff;
            --accent-hover: #79c0ff;
            --border: #30363d;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            height: 100vh;
        }

        /* Sidebar Controls */
        #controls {
            width: 320px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 10;
        }

        h1 { font-size: 1.2rem; margin: 0 0 10px 0; color: var(--accent); }
        h2 { font-size: 0.9rem; text-transform: uppercase; color: var(--text-muted); margin: 15px 0 5px 0; letter-spacing: 1px; }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label { font-size: 0.85rem; display: flex; justify-content: space-between; }
        
        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        input[type="number"] {
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 4px 8px;
            border-radius: 4px;
            width: 60px;
        }

        button {
            background: #21262d;
            border: 1px solid var(--border);
            color: var(--accent);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: 0.2s;
        }

        button:hover { background: #30363d; color: var(--accent-hover); }
        button.active { background: var(--accent); color: white; border-color: var(--accent); }

        .presets { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; }
        
        .stats-panel {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
        }

        /* Main Canvas Area */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }

        canvas { display: block; }

        /* Floating Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid var(--accent);
            padding: 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 0.85rem;
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 20;
            white-space: pre-line;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.8);
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }

    </style>
</head>
<body>

    <div id="controls">
        <h1>Channel Projection</h1>
        
        <div class="control-group">
            <label>
                Modulus (M)
                <input type="number" id="input-m" value="60" min="2" max="5000">
            </label>
            <input type="range" id="slider-m" min="2" max="1000" value="60">
            <div class="presets">
                <button onclick="setM(12)">12</button>
                <button onclick="setM(30)">30</button>
                <button onclick="setM(60)">60</button>
                <button onclick="setM(210)">210</button>
                <button onclick="setM(360)">360</button>
                <button onclick="setM(2310)">2310</button>
            </div>
        </div>

        <div class="stats-panel" id="global-stats">
            </div>

        <h2>Visualization</h2>
        <div class="control-group">
            <label>View Mode</label>
            <div class="presets" style="grid-template-columns: 1fr 1fr;">
                <button id="btn-view-projection" class="active" onclick="setView('projection')">Projection</button>
                <button id="btn-view-rings" onclick="setView('rings')">Rings</button>
            </div>
        </div>

        <div class="control-group">
            <label>Color Scheme</label>
            <select id="color-scheme" style="background:var(--bg-color); color:white; padding:5px; border:1px solid var(--border);">
                <option value="channel">By Channel (M')</option>
                <option value="gcd">By Reduction Factor (d)</option>
                <option value="prime">By Smallest Prime Factor</option>
            </select>
        </div>

        <div class="control-group">
            <label>Line Opacity <span id="val-opacity">0.3</span></label>
            <input type="range" id="slider-opacity" min="0" max="1" step="0.05" value="0.3">
        </div>

        <div class="control-group">
            <label>Animation</label>
            <button id="btn-animate" onclick="toggleAnimation()">Play Sequence</button>
        </div>

        <div style="margin-top: auto; font-size: 0.75rem; color: var(--text-muted);">
            <strong>Corrected Math:</strong><br>
            Channel Pop = &phi;(M')<br>
            Reduction Factor = M/M'
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="vizCanvas"></canvas>
        <div id="tooltip"></div>
        <div class="legend">
            <div class="legend-item"><div class="dot" style="background:#58a6ff"></div>Irreducible (M' = M)</div>
            <div class="legend-item"><div class="dot" style="background:#ff6b6b"></div>Reducible</div>
            <div class="legend-item"><div class="dot" style="background:#ffd700"></div>Center (M' = 1)</div>
        </div>
    </div>

<script>
/**
 * MATHEMATICAL CORE
 * Optimized for performance up to M=5000
 */

const MathCore = {
    gcd: (a, b) => {
        while (b) { [a, b] = [b, a % b]; }
        return a;
    },

    // Euler's Totient Function
    phi: (n) => {
        let result = n;
        for (let i = 2; i * i <= n; i++) {
            if (n % i === 0) {
                while (n % i === 0) n /= i;
                result -= result / i;
            }
        }
        if (n > 1) result -= result / n;
        return result;
    },

    getSmallestPrimeFactor: (n) => {
        if (n === 0 || n === 1) return 0;
        if (n % 2 === 0) return 2;
        if (n % 3 === 0) return 3;
        for (let i = 5; i * i <= n; i += 6) {
            if (n % i === 0) return i;
            if (n % (i + 2) === 0) return i + 2;
        }
        return n;
    },

    getPrimeFactors: (n) => {
        const factors = new Set();
        let d = 2;
        let temp = n;
        while (d * d <= temp) {
            if (temp % d === 0) {
                factors.add(d);
                temp /= d;
            } else {
                d++;
            }
        }
        if (temp > 1) factors.add(temp);
        return Array.from(factors);
    }
};

/**
 * APPLICATION STATE & CONFIG
 */
const State = {
    M: 60,
    viewMode: 'projection', // 'projection' or 'rings'
    colorScheme: 'channel',
    opacity: 0.3,
    isAnimating: false,
    animationId: null,
    
    // Calculated Data
    residues: [],
    channels: {}, // Map of M_prime -> { count, d, radius }
    sortedChannels: [] // Array of M_prime sorted by size
};

/**
 * DATA GENERATION
 */
function calculateData() {
    const M = State.M;
    State.residues = [];
    State.channels = {};

    // 1. Generate Residues and identify Channels
    for (let r = 0; r < M; r++) {
        // Special case for 0: acts as M
        const effectiveR = (r === 0) ? M : r;
        const d = MathCore.gcd(effectiveR, M);
        const M_prime = M / d; // The Channel
        const r_prime = effectiveR / d; // Reduced numerator

        // Register Channel
        if (!State.channels[M_prime]) {
            State.channels[M_prime] = {
                val: M_prime,
                d: d, // Reduction factor
                residues: [],
                population: MathCore.phi(M_prime) // THE FIX: Using Totient
            };
        }
        
        // Store Residue
        const residueObj = {
            r: r,
            d: d,
            M_prime: M_prime,
            r_prime: r_prime,
            angle: (r / M) * Math.PI * 2 - (Math.PI / 2), // Start at top
            spf: MathCore.getSmallestPrimeFactor(d > 1 ? d : M),
            isCoprime: (d === 1)
        };

        State.residues.push(residueObj);
        State.channels[M_prime].residues.push(residueObj);
    }

    // 2. Sort Channels for Visual Layout
    // We sort by M_prime. M_prime=1 (center) to M_prime=M (outer)
    State.sortedChannels = Object.values(State.channels).sort((a, b) => a.val - b.val);
    
    // 3. Assign Visual Radii
    // Logic: Distributed evenly between inner padding and outer edge
    const totalChannels = State.sortedChannels.length;
    State.sortedChannels.forEach((ch, index) => {
        // Normalized radius 0 to 1
        // If M_prime is 1, it's at the center (index 0)
        // If M_prime is M, it's at the edge
        ch.radiusPct = (index + 1) / (totalChannels + 1); // +1 padding
        
        // Override for visual clarity in 'projection' mode
        // The outer ring is always max radius
        if (ch.val === M) ch.radiusPct = 1.0;
        // The center point
        if (ch.val === 1) ch.radiusPct = 0.05; 
    });

    updateStatsUI();
}

function updateStatsUI() {
    const phi = MathCore.phi(State.M);
    const distinctPrimes = MathCore.getPrimeFactors(State.M).join(" × ");
    
    let html = `
        <div><strong>M = ${State.M}</strong></div>
        <div>Factors: ${distinctPrimes}</div>
        <div>φ(M): ${phi} (Coprimes)</div>
        <div>Channels: ${State.sortedChannels.length}</div>
        <div style="margin-top:5px; border-top:1px solid #444; padding-top:5px;">
            <small>Hover chart for details</small>
        </div>
    `;
    document.getElementById('global-stats').innerHTML = html;
}

/**
 * RENDERING ENGINE
 */
const canvas = document.getElementById('vizCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimization
let centerX, centerY, maxRadius;

function resize() {
    const container = document.getElementById('canvas-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    centerX = canvas.width / 2;
    centerY = canvas.height / 2;
    maxRadius = Math.min(centerX, centerY) - 40;
    render();
}

function getColor(residue) {
    const scheme = State.colorScheme;
    
    if (scheme === 'channel') {
        // Color based on the Channel (M_prime)
        // Map index to hue
        const chIndex = State.sortedChannels.findIndex(c => c.val === residue.M_prime);
        const hue = (chIndex / State.sortedChannels.length) * 300;
        if (residue.M_prime === 1) return '#ffd700'; // Gold for center
        if (residue.M_prime === State.M) return '#58a6ff'; // Blue for outer
        return `hsl(${hue}, 70%, 60%)`;
    } 
    else if (scheme === 'gcd') {
        // Color based on GCD value
        if (residue.d === 1) return '#58a6ff';
        return `hsl(${(residue.d * 137.5) % 360}, 70%, 60%)`;
    }
    else if (scheme === 'prime') {
        const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23];
        const colors = ['#ff6b6b', '#51cf66', '#fcc419', '#339af0', '#cc5de8', '#ff922b'];
        const pIndex = primes.indexOf(residue.spf);
        if (pIndex === -1) return '#868e96';
        return colors[pIndex % colors.length];
    }
    return '#fff';
}

function render() {
    // Background
    ctx.fillStyle = '#0f1115';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!State.sortedChannels.length) return;

    // 1. Draw Channel Rings
    State.sortedChannels.forEach(ch => {
        const r = ch.radiusPct * maxRadius;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        ctx.strokeStyle = '#30363d';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Label the ring if space permits
        if (State.sortedChannels.length < 15 || ch.val === State.M || ch.val === 1) {
            ctx.fillStyle = '#8b949e';
            ctx.font = '10px monospace';
            ctx.fillText(`M'=${ch.val}`, centerX + 5, centerY - r - 2);
        }
    });

    // 2. Draw Projections / Points
    ctx.lineWidth = 1;
    
    State.residues.forEach(res => {
        // Origin coordinates (Outer Ring)
        const outerR = maxRadius;
        const x1 = centerX + Math.cos(res.angle) * outerR;
        const y1 = centerY + Math.sin(res.angle) * outerR;

        // Destination coordinates (Channel Ring)
        // In 'rings' mode, the point stays on its channel ring
        // In 'projection' mode, we draw a line from outer to channel
        
        const chObj = State.channels[res.M_prime];
        const destR = chObj.radiusPct * maxRadius;
        
        // Angle logic: 
        // In standard view, angle is fixed by r/M.
        // In Ring view, we might want to rotate relative to M' but let's keep it simple first.
        const x2 = centerX + Math.cos(res.angle) * destR;
        const y2 = centerY + Math.sin(res.angle) * destR;

        const color = getColor(res);

        if (State.viewMode === 'projection' && res.d > 1) {
            // Draw Line
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.globalAlpha = State.opacity;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        // Draw Point at destination
        const pointSize = (res.M_prime === State.M) ? 2 : 3;
        ctx.beginPath();
        ctx.arc(x2, y2, pointSize, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        // Save coordinates for hover detection
        res.hitX = x2;
        res.hitY = y2;
        res.hitR = pointSize + 2; // Hit radius
    });
}

/**
 * INTERACTIVITY
 */
function handleInteraction(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Find closest point
    let minDist = 10;
    let target = null;

    // Optimization: Iterate backward (draw order) or use quadtree for huge N
    // Simple iteration is fine for N < 5000 on modern CPU
    for (let i = 0; i < State.residues.length; i++) {
        const res = State.residues[i];
        const dx = mx - res.hitX;
        const dy = my - res.hitY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist < minDist) {
            minDist = dist;
            target = res;
        }
    }

    const tooltip = document.getElementById('tooltip');
    
    if (target) {
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
        
        const ch = State.channels[target.M_prime];
        
        tooltip.innerHTML = `
            <span style="color:${getColor(target)}; font-weight:bold">r = ${target.r}</span> (mod ${State.M})
            <hr style="border:0; border-top:1px solid #444; margin:4px 0">
            <strong>Projection:</strong>
            ${target.r}/${State.M} → <span style="color:var(--accent)">${target.r_prime}/${target.M_prime}</span>
            <br>
            <strong>Analysis:</strong>
            GCD (Reduction): ${target.d}
            Target Channel: M'=${target.M_prime}
            <br>
            <span style="font-size:0.8em; color:#8b949e">
            Channel Population: ${ch.population} (φ(${target.M_prime}))
            Channel Multiplicity: ${ch.d} (M/M')
            </span>
        `;
        
        // Highlight this specific line if in projection mode
        if (State.viewMode === 'projection') {
            requestAnimationFrame(() => {
                render(); // clear
                // Draw highlight
                ctx.beginPath();
                ctx.moveTo(centerX + Math.cos(target.angle) * maxRadius, centerY + Math.sin(target.angle) * maxRadius);
                ctx.lineTo(target.hitX, target.hitY);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 1;
                ctx.stroke();
                ctx.lineWidth = 1;
            });
        }
    } else {
        tooltip.style.display = 'none';
        // Only re-render if we were highlighting something
        // (Debounce this in prod)
        render();
    }
}

/**
 * EVENT LISTENERS & CONTROLS
 */
document.getElementById('input-m').addEventListener('change', (e) => setM(parseInt(e.target.value)));
document.getElementById('slider-m').addEventListener('input', (e) => setM(parseInt(e.target.value)));

document.getElementById('slider-opacity').addEventListener('input', (e) => {
    State.opacity = parseFloat(e.target.value);
    document.getElementById('val-opacity').innerText = State.opacity;
    render();
});

document.getElementById('color-scheme').addEventListener('change', (e) => {
    State.colorScheme = e.target.value;
    render();
});

canvas.addEventListener('mousemove', handleInteraction);
window.addEventListener('resize', resize);

function setM(val) {
    if (val < 2) val = 2;
    if (val > 5000) val = 5000;
    State.M = val;
    
    // Sync Inputs
    document.getElementById('input-m').value = val;
    document.getElementById('slider-m').value = val;
    
    calculateData();
    render();
}

function setView(mode) {
    State.viewMode = mode;
    document.getElementById('btn-view-projection').className = mode === 'projection' ? 'active' : '';
    document.getElementById('btn-view-rings').className = mode === 'rings' ? 'active' : '';
    render();
}

function toggleAnimation() {
    const btn = document.getElementById('btn-animate');
    if (State.isAnimating) {
        State.isAnimating = false;
        clearInterval(State.animationId);
        btn.innerText = "Play Sequence";
        btn.className = "";
    } else {
        State.isAnimating = true;
        btn.innerText = "Stop";
        btn.className = "active";
        State.animationId = setInterval(() => {
            let nextM = parseInt(State.M) + 1;
            if (nextM > 1000) nextM = 4;
            setM(nextM);
        }, 150); // Speed
    }
}

// Initialize
resize();
calculateData(); // Initial calc for M=60

</script>
</body>
</html>
