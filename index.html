<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Farey Chandelier - Modular Rings</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
        }
        
        #canvas3d {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        
        #canvas3d:active {
            cursor: grabbing;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.9);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 0.85em;
            color: #00ffff;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            outline: none;
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #00ffff 0%, #0088ff 100%);
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            margin-top: 5px;
            font-size: 0.9em;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.4);
        }
        
        .slider-value {
            float: right;
            color: #ffaa00;
            font-weight: normal;
        }
        
        .info-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 300px;
            font-size: 0.85em;
        }
        
        .info-box h3 {
            color: #00ffff;
            margin-bottom: 8px;
            font-size: 1em;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .section-title {
            color: #00ffff;
            font-size: 0.9em;
            font-weight: bold;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }
        
        .preset-btn {
            background: linear-gradient(135deg, #666 0%, #888 100%);
            padding: 6px;
            font-size: 0.8em;
            margin: 2px;
            display: inline-block;
            width: auto;
        }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>
    
    <div class="controls">
        <h2 style="margin-bottom: 15px; color: #00ffff;">3D Farey Chandelier</h2>
        
        <div class="control-group">
            <label>Modulus (M): <span class="slider-value" id="modulusValue">12</span></label>
            <input type="range" id="modulusSlider" min="4" max="100" value="12">
            <input type="number" id="modulusInput" min="2" max="200" value="12" style="margin-top: 5px;">
        </div>
        
        <div style="display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 10px;">
            <button class="preset-btn" onclick="setModulus(6)">M=6</button>
            <button class="preset-btn" onclick="setModulus(12)">M=12</button>
            <button class="preset-btn" onclick="setModulus(24)">M=24</button>
            <button class="preset-btn" onclick="setModulus(30)">M=30</button>
            <button class="preset-btn" onclick="setModulus(60)">M=60</button>
        </div>
        
        <div class="section-title">3D View Controls</div>
        
        <div class="control-group">
            <label>Camera Distance: <span class="slider-value" id="cameraDistValue">3.5</span></label>
            <input type="range" id="cameraDist" min="20" max="80" value="35">
        </div>
        
        <div class="control-group">
            <label>Vertical Spacing: <span class="slider-value" id="vertSpacingValue">0.8</span></label>
            <input type="range" id="vertSpacing" min="20" max="200" value="80">
        </div>
        
        <div class="control-group">
            <label>Ring Size Scale: <span class="slider-value" id="ringSizeValue">1.0</span></label>
            <input type="range" id="ringSize" min="30" max="150" value="100">
        </div>
        
        <div class="control-group">
            <label>Perspective: <span class="slider-value" id="perspectiveValue">800</span></label>
            <input type="range" id="perspective" min="400" max="2000" value="800">
        </div>
        
        <div class="section-title">Rotation</div>
        
        <div class="control-group">
            <label>X-Axis Tilt: <span class="slider-value" id="rotXValue">20°</span></label>
            <input type="range" id="rotX" min="-90" max="90" value="20">
        </div>
        
        <div class="control-group">
            <label>Y-Axis Spin: <span class="slider-value" id="rotYValue">0°</span></label>
            <input type="range" id="rotY" min="0" max="360" value="0">
        </div>
        
        <div class="control-group">
            <label>Z-Axis Roll: <span class="slider-value" id="rotZValue">0°</span></label>
            <input type="range" id="rotZ" min="-90" max="90" value="0">
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="autoRotate">
            <label for="autoRotate">Auto-Rotate</label>
        </div>
        
        <div class="section-title">Display</div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showFareyChains" checked>
            <label for="showFareyChains">Farey Chains (Gold)</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showZeroChains" checked>
            <label for="showZeroChains">r=0 Chains (Red)</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showPoints" checked>
            <label for="showPoints">Points</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showRings" checked>
            <label for="showRings">Ring Circles</label>
        </div>
        
        <div class="control-group">
            <label>Point Size: <span class="slider-value" id="pointSizeValue">4</span></label>
            <input type="range" id="pointSize" min="1" max="15" value="4">
        </div>
        
        <div class="control-group">
            <label>Chain Opacity: <span class="slider-value" id="chainOpacityValue">0.6</span></label>
            <input type="range" id="chainOpacity" min="10" max="100" value="60">
        </div>
        
        <div class="control-group">
            <label for="colorScheme">Color Scheme:</label>
            <select id="colorScheme">
                <option value="coprime">Coprime vs Reducible</option>
                <option value="gcd">GCD Value</option>
                <option value="ring">By Ring Level</option>
                <option value="rainbow">Rainbow</option>
            </select>
        </div>
        
        <button onclick="resetView()">Reset View</button>
    </div>
    
    <div class="info-box">
        <h3>3D Chandelier View</h3>
        <p style="margin-bottom: 8px;">
            <strong>M = <span id="infoM">12</span></strong> (<span id="infoType">COMPOSITE</span>)
        </p>
        <p style="font-size: 0.8em; line-height: 1.4;">
            φ(M) = <span id="infoPhi">4</span><br>
            Rings: <span id="infoRings">6</span><br>
            Points: <span id="infoPoints">28</span><br>
            <br>
            <strong>Controls:</strong><br>
            • Drag to rotate<br>
            • Scroll to zoom<br>
            • M'=1 at bottom<br>
            • M at top
        </p>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas3d');
        const ctx = canvas.getContext('2d');
        let currentData = null;
        let animationFrame = null;
        
        // Camera state
        let camera = {
            distance: 3.5,
            rotX: 20,
            rotY: 0,
            rotZ: 0,
            perspective: 800
        };
        
        // Mouse interaction
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (currentData) render();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Math functions
        function gcd(a, b) {
            while (b !== 0) [a, b] = [b, a % b];
            return a;
        }
        
        function eulerPhi(n) {
            let result = n, p = 2, temp = n;
            while (p * p <= temp) {
                if (temp % p === 0) {
                    while (temp % p === 0) temp /= p;
                    result -= result / p;
                }
                p++;
            }
            if (temp > 1) result -= result / temp;
            return Math.floor(result);
        }
        
        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }
        
        function getDivisors(n) {
            const divisors = [];
            for (let i = 1; i <= n; i++) {
                if (n % i === 0) divisors.push(i);
            }
            return divisors;
        }
        
        function lowestTerms(r, m) {
            if (r === 0) return [0, 1];
            const d = gcd(r, m);
            return [r / d, m / d];
        }
        
        function computeData(M) {
            const divisors = getDivisors(M).sort((a, b) => a - b); // Ascending: 1, 2, ..., M
            const data = {
                M: M,
                isPrime: isPrime(M),
                divisors: divisors,
                phi: eulerPhi(M),
                rings: new Map(),
                allPoints: []
            };
            
            divisors.forEach((m, levelIndex) => {
                const ring = [];
                for (let r = 0; r < m; r++) {
                    const d = gcd(r, m);
                    const [rRed, mRed] = lowestTerms(r, m);
                    
                    const pt = {
                        r: r,
                        M: m,
                        level: levelIndex, // 0 = bottom (M'=1), max = top (M)
                        d: d,
                        rRed: rRed,
                        mRed: mRed,
                        isIrreducible: (d === 1 || r === 0),
                        theta: (2 * Math.PI * r) / m
                    };
                    
                    ring.push(pt);
                    data.allPoints.push(pt);
                }
                data.rings.set(m, ring);
            });
            
            return data;
        }
        
        function getColor(pt, scheme) {
            if (scheme === 'coprime') {
                if (pt.r === 0) return '#888888';
                return pt.isIrreducible ? '#00ffff' : '#ff0066';
            } else if (scheme === 'gcd') {
                if (pt.r === 0) return '#888888';
                const hue = (pt.d * 60) % 360;
                return `hsl(${hue}, 100%, 50%)`;
            } else if (scheme === 'ring') {
                const hue = (pt.level * 40) % 360;
                return `hsl(${hue}, 80%, 60%)`;
            } else if (scheme === 'rainbow') {
                const hue = (pt.theta * 180 / Math.PI) % 360;
                return `hsl(${hue}, 90%, 60%)`;
            }
            return '#ffffff';
        }
        
        // 3D projection
        function project3D(x, y, z) {
            // Apply rotations
            const rotXRad = camera.rotX * Math.PI / 180;
            const rotYRad = camera.rotY * Math.PI / 180;
            const rotZRad = camera.rotZ * Math.PI / 180;
            
            // Rotate X
            let y1 = y * Math.cos(rotXRad) - z * Math.sin(rotXRad);
            let z1 = y * Math.sin(rotXRad) + z * Math.cos(rotXRad);
            
            // Rotate Y
            let x2 = x * Math.cos(rotYRad) + z1 * Math.sin(rotYRad);
            let z2 = -x * Math.sin(rotYRad) + z1 * Math.cos(rotYRad);
            
            // Rotate Z
            let x3 = x2 * Math.cos(rotZRad) - y1 * Math.sin(rotZRad);
            let y3 = x2 * Math.sin(rotZRad) + y1 * Math.cos(rotZRad);
            
            // Apply camera distance
            z2 += camera.distance;
            
            // Perspective projection
            const scale = camera.perspective / (camera.perspective + z2);
            
            return {
                x: x3 * scale + canvas.width / 2,
                y: y3 * scale + canvas.height / 2,
                z: z2,
                scale: scale
            };
        }
        
        function render() {
            if (!currentData) return;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const vertSpacing = parseFloat(document.getElementById('vertSpacing').value) / 100;
            const ringScale = parseFloat(document.getElementById('ringSize').value) / 100;
            const showFarey = document.getElementById('showFareyChains').checked;
            const showZero = document.getElementById('showZeroChains').checked;
            const showPoints = document.getElementById('showPoints').checked;
            const showRings = document.getElementById('showRings').checked;
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const chainOpacity = parseFloat(document.getElementById('chainOpacity').value) / 100;
            const colorScheme = document.getElementById('colorScheme').value;
            
            const numLevels = currentData.divisors.length;
            
            // Calculate 3D positions for all points
            const points3D = currentData.allPoints.map(pt => {
                const radius = (pt.M / currentData.M) * ringScale;
                const height = (pt.level / (numLevels - 1)) * 2 * vertSpacing;
                
                return {
                    pt: pt,
                    x: radius * Math.cos(pt.theta),
                    y: height,
                    z: radius * Math.sin(pt.theta),
                    radius: radius
                };
            });
            
            // Project to 2D
            const projected = points3D.map(p3d => ({
                ...p3d,
                proj: project3D(p3d.x, p3d.y, p3d.z)
            }));
            
            // Sort by depth for proper occlusion
            projected.sort((a, b) => b.proj.z - a.proj.z);
            
            // Draw Farey chains (gold)
            if (showFarey) {
                ctx.globalAlpha = chainOpacity;
                ctx.lineWidth = 1.5;
                
                projected.forEach(p => {
                    if (p.pt.r === 0 || p.pt.mRed === 1) return;
                    
                    // Find target point
                    const target = projected.find(t => 
                        t.pt.M === p.pt.mRed && t.pt.r === p.pt.rRed
                    );
                    
                    if (target && target.proj.z < camera.distance + 5) {
                        ctx.strokeStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.moveTo(p.proj.x, p.proj.y);
                        ctx.lineTo(target.proj.x, target.proj.y);
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw r=0 chains (red, to center bottom)
            if (showZero) {
                ctx.globalAlpha = chainOpacity;
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#ff0000';
                
                const centerBottom = project3D(0, 0, 0);
                
                projected.forEach(p => {
                    if (p.pt.r === 0 && p.pt.M > 1) {
                        ctx.beginPath();
                        ctx.moveTo(p.proj.x, p.proj.y);
                        ctx.lineTo(centerBottom.x, centerBottom.y);
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw rings
            if (showRings) {
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = '#444444';
                ctx.lineWidth = 1;
                
                currentData.divisors.forEach((m, levelIndex) => {
                    const radius = (m / currentData.M) * ringScale;
                    const height = (levelIndex / (numLevels - 1)) * 2 * vertSpacing;
                    
                    // Draw circle as many line segments
                    const segments = 64;
                    ctx.beginPath();
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        const p = project3D(x, height, z);
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw points
            if (showPoints) {
                projected.forEach(p => {
                    const color = getColor(p.pt, colorScheme);
                    const size = pointSize * p.proj.scale;
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(p.proj.x, p.proj.y, size, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    if (p.pt.r === 0) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
            }
        }
        
        function updateVisualization() {
            let M = parseInt(document.getElementById('modulusInput').value);
            if (M < 2) M = 2;
            if (M > 200) M = 200;
            
            document.getElementById('modulusInput').value = M;
            document.getElementById('modulusSlider').value = Math.min(M, 100);
            document.getElementById('modulusValue').textContent = M;
            
            currentData = computeData(M);
            
            // Update info
            document.getElementById('infoM').textContent = M;
            document.getElementById('infoType').textContent = currentData.isPrime ? 'PRIME' : 'COMPOSITE';
            document.getElementById('infoPhi').textContent = currentData.phi;
            document.getElementById('infoRings').textContent = currentData.divisors.length;
            document.getElementById('infoPoints').textContent = currentData.allPoints.length;
            
            render();
        }
        
        function setModulus(M) {
            document.getElementById('modulusInput').value = M;
            updateVisualization();
        }
        
        function resetView() {
            camera.distance = 3.5;
            camera.rotX = 20;
            camera.rotY = 0;
            camera.rotZ = 0;
            
            document.getElementById('cameraDist').value = 35;
            document.getElementById('rotX').value = 20;
            document.getElementById('rotY').value = 0;
            document.getElementById('rotZ').value = 0;
            
            updateSliderDisplays();
            render();
        }
        
        function updateSliderDisplays() {
            document.getElementById('cameraDistValue').textContent = camera.distance.toFixed(1);
            document.getElementById('vertSpacingValue').textContent = (parseFloat(document.getElementById('vertSpacing').value) / 100).toFixed(1);
            document.getElementById('ringSizeValue').textContent = (parseFloat(document.getElementById('ringSize').value) / 100).toFixed(1);
            document.getElementById('perspectiveValue').textContent = camera.perspective;
            document.getElementById('rotXValue').textContent = camera.rotX.toFixed(0) + '°';
            document.getElementById('rotYValue').textContent = camera.rotY.toFixed(0) + '°';
            document.getElementById('rotZValue').textContent = camera.rotZ.toFixed(0) + '°';
            document.getElementById('pointSizeValue').textContent = document.getElementById('pointSize').value;
            document.getElementById('chainOpacityValue').textContent = (parseFloat(document.getElementById('chainOpacity').value) / 100).toFixed(2);
        }
        
        // Event listeners
        document.getElementById('modulusSlider').addEventListener('input', (e) => {
            document.getElementById('modulusInput').value = e.target.value;
            document.getElementById('modulusValue').textContent = e.target.value;
        });
        
        document.getElementById('modulusInput').addEventListener('change', updateVisualization);
        
        ['cameraDist', 'vertSpacing', 'ringSize', 'perspective', 'rotX', 'rotY', 'rotZ', 'pointSize', 'chainOpacity'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                if (id === 'cameraDist') camera.distance = parseFloat(e.target.value) / 10;
                else if (id === 'rotX') camera.rotX = parseFloat(e.target.value);
                else if (id === 'rotY') camera.rotY = parseFloat(e.target.value);
                else if (id === 'rotZ') camera.rotZ = parseFloat(e.target.value);
                else if (id === 'perspective') camera.perspective = parseFloat(e.target.value);
                
                updateSliderDisplays();
                render();
            });
        });
        
        ['showFareyChains', 'showZeroChains', 'showPoints', 'showRings', 'colorScheme'].forEach(id => {
            document.getElementById(id).addEventListener('change', render);
        });
        
        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            camera.rotY += deltaX * 0.5;
            camera.rotX -= deltaY * 0.5;
            
            camera.rotX = Math.max(-90, Math.min(90, camera.rotX));
            camera.rotY = camera.rotY % 360;
            
            document.getElementById('rotX').value = camera.rotX;
            document.getElementById('rotY').value = camera.rotY;
            
            updateSliderDisplays();
            render();
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.distance += e.deltaY * 0.001;
            camera.distance = Math.max(2, Math.min(8, camera.distance));
            
            document.getElementById('cameraDist').value = camera.distance * 10;
            updateSliderDisplays();
            render();
        });
        
        // Auto-rotate
        document.getElementById('autoRotate').addEventListener('change', (e) => {
            if (e.target.checked) {
                function animate() {
                    if (!document.getElementById('autoRotate').checked) return;
                    
                    camera.rotY += 0.5;
                    camera.rotY = camera.rotY % 360;
                    document.getElementById('rotY').value = camera.rotY;
                    updateSliderDisplays();
                    render();
                    
                    animationFrame = requestAnimationFrame(animate);
                }
                animate();
            } else if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        });
        
        // Initialize
        updateVisualization();
        updateSliderDisplays();
    </script>
</body>
</html>
