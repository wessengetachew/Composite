
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Reduction Projection Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 320px;
            background: #1a1a1a;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        h1 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #fff;
            font-weight: 600;
        }

        h2 {
            font-size: 14px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #bbb;
        }

        input[type="number"],
        input[type="range"],
        select {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 13px;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
        }

        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #666;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #3a3a3a;
            border-color: #666;
        }

        .preset-btn:active {
            background: #4a4a4a;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        input[type="checkbox"] {
            margin-right: 8px;
            width: 16px;
            height: 16px;
        }

        .stats-panel {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.6;
        }

        .stats-panel div {
            margin-bottom: 5px;
        }

        .stats-panel strong {
            color: #fff;
        }

        canvas {
            display: block;
            background: #000;
            cursor: crosshair;
        }

        .export-btn {
            padding: 12px 24px;
            background: #2a5a2a;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-top: 20px;
            width: 100%;
            transition: background 0.2s;
        }

        .export-btn:hover {
            background: #3a7a3a;
        }

        .export-btn:active {
            background: #4a9a4a;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #fff;
            font-weight: 500;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 26, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #bbb;
        }

        .color-legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .color-legend-item {
            display: flex;
            align-items: center;
            font-size: 12px;
        }

        .color-box {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            margin-right: 8px;
            border: 1px solid #444;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            line-height: 1.5;
            margin-top: 15px;
            padding: 10px;
            background: #151515;
            border-radius: 4px;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            padding: 10px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            border: 1px solid #444;
            max-width: 200px;
            z-index: 1000;
        }

        .tooltip-line {
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>Modular Reduction Projection Explorer</h1>
            
            <h2>Modulus Configuration</h2>
            <div class="control-group">
                <label>
                    Modulus M
                    <span class="value-display" id="modulusValue">120</span>
                </label>
                <input type="range" id="modulusSlider" min="4" max="500" value="120">
                <input type="number" id="modulusInput" min="2" max="5000" value="120">
            </div>

            <div class="preset-buttons">
                <button class="preset-btn" onclick="setModulus(6)">6</button>
                <button class="preset-btn" onclick="setModulus(12)">12</button>
                <button class="preset-btn" onclick="setModulus(30)">30</button>
                <button class="preset-btn" onclick="setModulus(60)">60</button>
                <button class="preset-btn" onclick="setModulus(120)">120</button>
                <button class="preset-btn" onclick="setModulus(210)">210</button>
                <button class="preset-btn" onclick="setModulus(360)">360</button>
                <button class="preset-btn" onclick="setModulus(840)">840</button>
                <button class="preset-btn" onclick="setModulus(2310)">2310</button>
            </div>

            <h2>Visualization Options</h2>
            <div class="control-group">
                <label>
                    Color Scheme
                </label>
                <select id="colorScheme">
                    <option value="channel-type">Channel Type</option>
                    <option value="spf">Smallest Prime Factor</option>
                    <option value="lpf">Largest Prime Factor</option>
                    <option value="gcd">GCD Value</option>
                    <option value="depth">Channel Depth</option>
                </select>
            </div>

            <div class="control-group">
                <label>
                    Projection Line Opacity
                    <span class="value-display" id="opacityValue">0.30</span>
                </label>
                <input type="range" id="opacitySlider" min="0" max="100" value="30">
            </div>

            <div class="control-group">
                <label>
                    Point Size
                    <span class="value-display" id="pointSizeValue">5</span>
                </label>
                <input type="range" id="pointSizeSlider" min="3" max="12" value="5">
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showLabels" checked>
                <label for="showLabels">Show Channel Labels</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showMultiplicity" checked>
                <label for="showMultiplicity">Show Multiplicity</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showProjections" checked>
                <label for="showProjections">Show Projection Lines</label>
            </div>

            <h2>Statistics</h2>
            <div class="stats-panel" id="statsPanel">
                <div><strong>φ(M):</strong> <span id="phiValue">32</span></div>
                <div><strong>Irreducible:</strong> <span id="irreducibleCount">32</span></div>
                <div><strong>Reducible:</strong> <span id="reducibleCount">88</span></div>
                <div><strong>Reducibility:</strong> <span id="reducibilityRatio">73.3%</span></div>
                <div><strong>Farey Channels:</strong> <span id="channelCount">15</span></div>
                <div><strong>Prime Factorization:</strong> <span id="factorization">2³×3×5</span></div>
            </div>

            <div class="color-legend" id="colorLegend">
                <div class="color-legend-item">
                    <div class="color-box" style="background: #00ffff;"></div>
                    <span>Irreducible (gcd=1)</span>
                </div>
                <div class="color-legend-item">
                    <div class="color-box" style="background: #ff1493;"></div>
                    <span>Reducible (gcd>1)</span>
                </div>
                <div class="color-legend-item">
                    <div class="color-box" style="background: #ffd700;"></div>
                    <span>Farey Channels</span>
                </div>
            </div>

            <h2>Export</h2>
            <div class="control-group">
                <label>Resolution</label>
                <select id="exportResolution">
                    <option value="2800">4K (2800×2800)</option>
                    <option value="5600">8K (5600×5600)</option>
                    <option value="1400">HD (1400×1400)</option>
                </select>
            </div>

            <button class="export-btn" onclick="exportImage()">Export PNG</button>

            <div class="info-text">
                <strong>About:</strong> This tool visualizes the classical reduction of fractions r/M to lowest terms in modular arithmetic. It displays how residues project onto their reduced denominators (Farey sequence elements), showing the geometric structure of fraction reduction. Each reducible fraction r/M reduces to (r/d)/(M/d) where d = gcd(r,M).
                <br><br>
                <strong>Mathematics:</strong> All mathematical concepts are classical (Euclid's algorithm for GCD, Euler's totient function φ(M), Farey sequences). This visualization provides an interactive geometric perspective on well-established number theory.
                <br><br>
                <strong>Author:</strong> Wessen Getachew
            </div>
        </div>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="zoom-controls">
                    Zoom: <span id="zoomLevel">100%</span>
                </div>
                <div class="tooltip" id="tooltip"></div>
            </div>
        </div>
    </div>

    <script>
        // Mathematical utilities
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                const temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function phi(n) {
            let result = n;
            let p = 2;
            while (p * p <= n) {
                if (n % p === 0) {
                    while (n % p === 0) n /= p;
                    result -= result / p;
                }
                p++;
            }
            if (n > 1) result -= result / n;
            return Math.round(result);
        }

        function primeFactorization(n) {
            const factors = [];
            let d = 2;
            while (n > 1) {
                let count = 0;
                while (n % d === 0) {
                    count++;
                    n /= d;
                }
                if (count > 0) {
                    factors.push({ prime: d, power: count });
                }
                d++;
                if (d * d > n && n > 1) {
                    factors.push({ prime: n, power: 1 });
                    break;
                }
            }
            return factors;
        }

        function formatFactorization(factors) {
            return factors.map(f => {
                if (f.power === 1) return f.prime.toString();
                return `${f.prime}${toSuperscript(f.power)}`;
            }).join('×');
        }

        function toSuperscript(n) {
            const superscripts = '⁰¹²³⁴⁵⁶⁷⁸⁹';
            return n.toString().split('').map(d => superscripts[parseInt(d)]).join('');
        }

        function getDivisors(n) {
            const divisors = [];
            for (let i = 1; i <= Math.sqrt(n); i++) {
                if (n % i === 0) {
                    divisors.push(i);
                    if (i !== n / i) divisors.push(n / i);
                }
            }
            return divisors.sort((a, b) => a - b);
        }

        function smallestPrimeFactor(n) {
            if (n % 2 === 0) return 2;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return i;
            }
            return n;
        }

        function largestPrimeFactor(n) {
            let largest = -1;
            while (n % 2 === 0) {
                largest = 2;
                n /= 2;
            }
            for (let i = 3; i * i <= n; i += 2) {
                while (n % i === 0) {
                    largest = i;
                    n /= i;
                }
            }
            if (n > 2) largest = n;
            return largest;
        }

        // Visualization state
        let config = {
            modulus: 120,
            colorScheme: 'channel-type',
            opacity: 0.3,
            pointSize: 5,
            showLabels: true,
            showMultiplicity: true,
            showProjections: true,
            zoom: 1.0
        };

        let canvas, ctx;
        let points = [];
        let channels = [];
        let hoveredPoint = null;

        // Color schemes
        const colorSchemes = {
            'channel-type': {
                irreducible: '#00ffff',
                reducible: '#ff1493',
                channel: '#ffd700'
            },
            'spf': (spf) => {
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                return colors[(spf - 2) % colors.length] || '#ffffff';
            },
            'lpf': (lpf) => {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7'];
                return colors[(lpf - 2) % colors.length] || '#ffffff';
            },
            'gcd': (g) => {
                const intensity = Math.min(g / 10, 1);
                return `rgb(${255 * intensity}, ${100}, ${255 * (1 - intensity)})`;
            },
            'depth': (depth) => {
                const hue = (depth / 100) * 360;
                return `hsl(${hue}, 70%, 60%)`;
            }
        };

        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('click', handleClick);
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight) - 40;
            canvas.width = size;
            canvas.height = size;
            draw();
        }

        function calculatePoints() {
            const M = config.modulus;
            points = [];
            channels = new Map();

            // Calculate all points
            for (let r = 0; r < M; r++) {
                const g = gcd(r, M);
                const isOpen = g === 1;
                const reducedR = r / g;
                const reducedM = M / g;
                const angle = (2 * Math.PI * r) / M;
                const spf = isOpen ? 1 : smallestPrimeFactor(g);
                const lpf = isOpen ? 1 : largestPrimeFactor(g);

                points.push({
                    r, M, gcd: g, isOpen,
                    reducedR, reducedM,
                    angle, spf, lpf
                });

                // Track channels
                if (!channels.has(reducedM)) {
                    channels.set(reducedM, {
                        M_prime: reducedM,
                        multiplicity: M / reducedM,
                        residues: [],
                        count: 0
                    });
                }
                channels.get(reducedM).residues.push(r);
                channels.get(reducedM).count++;
            }

            updateStatistics();
        }

        function updateStatistics() {
            const M = config.modulus;
            const phiM = phi(M);
            const irreducible = points.filter(p => p.isOpen).length;
            const reducible = points.filter(p => !p.isOpen).length;
            const reducibilityRatio = ((reducible / M) * 100).toFixed(1);
            const channelCount = channels.size;
            const factors = primeFactorization(M);

            document.getElementById('phiValue').textContent = phiM;
            document.getElementById('irreducibleCount').textContent = irreducible;
            document.getElementById('reducibleCount').textContent = reducible;
            document.getElementById('reducibilityRatio').textContent = reducibilityRatio + '%';
            document.getElementById('channelCount').textContent = channelCount;
            document.getElementById('factorization').textContent = formatFactorization(factors);
        }

        function draw() {
            const size = canvas.width;
            const centerX = size / 2;
            const centerY = size / 2;
            const baseRadius = size * 0.4;

            ctx.clearRect(0, 0, size, size);
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(config.zoom, config.zoom);
            ctx.translate(-centerX, -centerY);

            // Draw projection lines
            if (config.showProjections) {
                ctx.globalAlpha = config.opacity;
                points.forEach(p => {
                    if (!p.isOpen) {
                        const outerX = centerX + baseRadius * Math.cos(p.angle - Math.PI / 2);
                        const outerY = centerY + baseRadius * Math.sin(p.angle - Math.PI / 2);
                        
                        const channelRadius = baseRadius * (p.reducedM / config.modulus);
                        const targetAngle = (2 * Math.PI * p.reducedR) / p.reducedM;
                        const innerX = centerX + channelRadius * Math.cos(targetAngle - Math.PI / 2);
                        const innerY = centerY + channelRadius * Math.sin(targetAngle - Math.PI / 2);

                        ctx.beginPath();
                        ctx.moveTo(outerX, outerY);
                        ctx.lineTo(innerX, innerY);
                        ctx.strokeStyle = '#ff1493';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }

            // Draw channel rings
            const divisors = getDivisors(config.modulus).filter(d => channels.has(d));
            divisors.forEach(d => {
                const radius = baseRadius * (d / config.modulus);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw channel label
                if (config.showLabels && d > 1) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '11px monospace';
                    ctx.fillText(`M' = ${d}`, centerX + radius + 5, centerY);
                }

                // Draw multiplicity
                if (config.showMultiplicity && channels.has(d)) {
                    const mult = channels.get(d).multiplicity;
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px monospace';
                    ctx.fillText(`d = ${mult}`, centerX - radius - 40, centerY);
                }
            });

            // Draw channel points (inner rings)
            channels.forEach((channel, M_prime) => {
                const radius = baseRadius * (M_prime / config.modulus);
                for (let r = 0; r < M_prime; r++) {
                    if (gcd(r, M_prime) === 1) {
                        const angle = (2 * Math.PI * r) / M_prime;
                        const x = centerX + radius * Math.cos(angle - Math.PI / 2);
                        const y = centerY + radius * Math.sin(angle - Math.PI / 2);

                        ctx.beginPath();
                        ctx.arc(x, y, config.pointSize * 0.7, 0, 2 * Math.PI);
                        ctx.fillStyle = '#ffd700';
                        ctx.fill();
                    }
                }
            });

            // Draw outer ring points
            points.forEach(p => {
                const x = centerX + baseRadius * Math.cos(p.angle - Math.PI / 2);
                const y = centerY + baseRadius * Math.sin(p.angle - Math.PI / 2);

                let color;
                if (config.colorScheme === 'channel-type') {
                    color = p.isOpen ? colorSchemes['channel-type'].irreducible : colorSchemes['channel-type'].reducible;
                } else if (config.colorScheme === 'spf') {
                    color = p.isOpen ? '#00ffff' : colorSchemes.spf(p.spf);
                } else if (config.colorScheme === 'lpf') {
                    color = p.isOpen ? '#00ffff' : colorSchemes.lpf(p.lpf);
                } else if (config.colorScheme === 'gcd') {
                    color = colorSchemes.gcd(p.gcd);
                } else if (config.colorScheme === 'depth') {
                    color = colorSchemes.depth(p.reducedM);
                }

                ctx.beginPath();
                ctx.arc(x, y, config.pointSize, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();

                // Highlight hovered point
                if (hoveredPoint && hoveredPoint.r === p.r) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Store screen coordinates for hit detection
                p.screenX = x;
                p.screenY = y;
            });

            ctx.restore();
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            // Find closest point
            let closest = null;
            let minDist = config.pointSize * 2;

            points.forEach(p => {
                const dx = x - p.screenX;
                const dy = y - p.screenY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    closest = p;
                }
            });

            if (closest !== hoveredPoint) {
                hoveredPoint = closest;
                draw();
                updateTooltip(e.clientX, e.clientY);
            }
        }

        function updateTooltip(x, y) {
            const tooltip = document.getElementById('tooltip');
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (x + 15) + 'px';
                tooltip.style.top = (y + 15) + 'px';
                
                const reduction = hoveredPoint.isOpen ? 
                    'Irreducible' : 
                    `${hoveredPoint.r}/${hoveredPoint.M} → ${hoveredPoint.reducedR}/${hoveredPoint.reducedM}`;
                
                tooltip.innerHTML = `
                    <div class="tooltip-line"><strong>r = ${hoveredPoint.r}</strong></div>
                    <div class="tooltip-line">gcd(${hoveredPoint.r}, ${hoveredPoint.M}) = ${hoveredPoint.gcd}</div>
                    <div class="tooltip-line">${reduction}</div>
                    ${!hoveredPoint.isOpen ? `<div class="tooltip-line">Channel M' = ${hoveredPoint.reducedM}</div>` : ''}
                `;
            } else {
                tooltip.style.display = 'none';
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            config.zoom = Math.max(0.5, Math.min(10, config.zoom * delta));
            document.getElementById('zoomLevel').textContent = Math.round(config.zoom * 100) + '%';
            draw();
        }

        function handleClick(e) {
            if (hoveredPoint) {
                console.log('Point details:', hoveredPoint);
            }
        }

        function setModulus(m) {
            config.modulus = m;
            document.getElementById('modulusSlider').value = Math.min(m, 500);
            document.getElementById('modulusInput').value = m;
            document.getElementById('modulusValue').textContent = m;
            calculatePoints();
            draw();
        }

        function exportImage() {
            const resolution = parseInt(document.getElementById('exportResolution').value);
            
            // Create high-resolution canvas
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            const totalWidth = resolution;
            const totalHeight = resolution;
            const vizSize = Math.floor(resolution * 0.7);
            const panelWidth = resolution - vizSize;
            
            exportCanvas.width = totalWidth;
            exportCanvas.height = totalHeight;
            
            // Fill background
            exportCtx.fillStyle = '#000';
            exportCtx.fillRect(0, 0, totalWidth, totalHeight);
            
            // Draw title
            exportCtx.fillStyle = '#fff';
            exportCtx.font = `${resolution / 30}px Arial`;
            exportCtx.textAlign = 'center';
            exportCtx.fillText(
                `Modular Reduction Projection: M = ${config.modulus}`,
                totalWidth / 2,
                resolution / 20
            );
            
            // Draw visualization
            const vizCenterX = vizSize / 2;
            const vizCenterY = totalHeight / 2;
            const baseRadius = vizSize * 0.42;
            
            // Draw subtitle
            exportCtx.font = `${resolution / 50}px Arial`;
            exportCtx.fillStyle = '#aaa';
            exportCtx.fillText(
                `Composite Modulus M = ${config.modulus}`,
                vizCenterX,
                resolution / 12
            );
            
            const scaleFactor = resolution / canvas.width;
            
            // Draw projection lines
            if (config.showProjections) {
                exportCtx.globalAlpha = config.opacity;
                points.forEach(p => {
                    if (!p.isOpen) {
                        const outerX = vizCenterX + baseRadius * Math.cos(p.angle - Math.PI / 2);
                        const outerY = vizCenterY + baseRadius * Math.sin(p.angle - Math.PI / 2);
                        
                        const channelRadius = baseRadius * (p.reducedM / config.modulus);
                        const targetAngle = (2 * Math.PI * p.reducedR) / p.reducedM;
                        const innerX = vizCenterX + channelRadius * Math.cos(targetAngle - Math.PI / 2);
                        const innerY = vizCenterY + channelRadius * Math.sin(targetAngle - Math.PI / 2);

                        exportCtx.beginPath();
                        exportCtx.moveTo(outerX, outerY);
                        exportCtx.lineTo(innerX, innerY);
                        exportCtx.strokeStyle = '#ff1493';
                        exportCtx.lineWidth = scaleFactor * 0.5;
                        exportCtx.stroke();
                    }
                });
                exportCtx.globalAlpha = 1.0;
            }
            
            // Draw channel rings
            const divisors = getDivisors(config.modulus).filter(d => channels.has(d));
            divisors.forEach(d => {
                const radius = baseRadius * (d / config.modulus);
                exportCtx.beginPath();
                exportCtx.arc(vizCenterX, vizCenterY, radius, 0, 2 * Math.PI);
                exportCtx.strokeStyle = '#ffd700';
                exportCtx.lineWidth = scaleFactor;
                exportCtx.stroke();

                if (config.showLabels && d > 1) {
                    exportCtx.fillStyle = '#ffd700';
                    exportCtx.font = `${resolution / 80}px monospace`;
                    exportCtx.textAlign = 'left';
                    exportCtx.fillText(`M' = ${d}`, vizCenterX + radius + 10, vizCenterY);
                }

                if (config.showMultiplicity && channels.has(d)) {
                    const mult = channels.get(d).multiplicity;
                    exportCtx.fillStyle = '#aaa';
                    exportCtx.font = `${resolution / 90}px monospace`;
                    exportCtx.textAlign = 'right';
                    exportCtx.fillText(`d = ${mult}`, vizCenterX - radius - 10, vizCenterY);
                }
            });
            
            // Draw channel points
            channels.forEach((channel, M_prime) => {
                const radius = baseRadius * (M_prime / config.modulus);
                for (let r = 0; r < M_prime; r++) {
                    if (gcd(r, M_prime) === 1) {
                        const angle = (2 * Math.PI * r) / M_prime;
                        const x = vizCenterX + radius * Math.cos(angle - Math.PI / 2);
                        const y = vizCenterY + radius * Math.sin(angle - Math.PI / 2);

                        exportCtx.beginPath();
                        exportCtx.arc(x, y, config.pointSize * scaleFactor * 0.7, 0, 2 * Math.PI);
                        exportCtx.fillStyle = '#ffd700';
                        exportCtx.fill();
                    }
                }
            });
            
            // Draw outer ring points
            points.forEach(p => {
                const x = vizCenterX + baseRadius * Math.cos(p.angle - Math.PI / 2);
                const y = vizCenterY + baseRadius * Math.sin(p.angle - Math.PI / 2);

                let color;
                if (config.colorScheme === 'channel-type') {
                    color = p.isOpen ? '#00ffff' : '#ff1493';
                } else if (config.colorScheme === 'spf') {
                    color = p.isOpen ? '#00ffff' : colorSchemes.spf(p.spf);
                } else if (config.colorScheme === 'lpf') {
                    color = p.isOpen ? '#00ffff' : colorSchemes.lpf(p.lpf);
                } else if (config.colorScheme === 'gcd') {
                    color = colorSchemes.gcd(p.gcd);
                } else if (config.colorScheme === 'depth') {
                    color = colorSchemes.depth(p.reducedM);
                }

                exportCtx.beginPath();
                exportCtx.arc(x, y, config.pointSize * scaleFactor, 0, 2 * Math.PI);
                exportCtx.fillStyle = color;
                exportCtx.fill();
            });
            
            // Draw info panel
            const panelX = vizSize + 20;
            let panelY = resolution / 8;
            const lineHeight = resolution / 40;
            const fontSize = resolution / 60;
            
            exportCtx.textAlign = 'left';
            
            // Configuration
            exportCtx.fillStyle = '#fff';
            exportCtx.font = `bold ${fontSize * 1.2}px Arial`;
            exportCtx.fillText('CONFIGURATION', panelX, panelY);
            panelY += lineHeight * 1.5;
            
            exportCtx.font = `${fontSize}px Arial`;
            exportCtx.fillStyle = '#ccc';
            exportCtx.fillText(`Modulus M = ${config.modulus}`, panelX, panelY);
            panelY += lineHeight;
            
            const factors = primeFactorization(config.modulus);
            exportCtx.fillText(`Prime Factorization: ${formatFactorization(factors)}`, panelX, panelY);
            panelY += lineHeight;
            
            exportCtx.fillText('Display Mode: Projection Lines', panelX, panelY);
            panelY += lineHeight;
            
            exportCtx.fillText(`Color Scheme: ${config.colorScheme}`, panelX, panelY);
            panelY += lineHeight * 2;
            
            // Statistics
            exportCtx.fillStyle = '#fff';
            exportCtx.font = `bold ${fontSize * 1.2}px Arial`;
            exportCtx.fillText('STATISTICS', panelX, panelY);
            panelY += lineHeight * 1.5;
            
            exportCtx.font = `${fontSize}px Arial`;
            exportCtx.fillStyle = '#ccc';
            const phiM = phi(config.modulus);
            exportCtx.fillText(`φ(M) = ${phiM}`, panelX, panelY);
            panelY += lineHeight;
            
            const irreducible = points.filter(p => p.isOpen).length;
            const reducible = points.filter(p => !p.isOpen).length;
            exportCtx.fillText(`Reducible Residues: ${reducible}`, panelX, panelY);
            panelY += lineHeight;
            
            const reducibilityRatio = ((reducible / config.modulus) * 100).toFixed(1);
            exportCtx.fillText(`Reducibility Ratio: ${reducibilityRatio}%`, panelX, panelY);
            panelY += lineHeight;
            
            exportCtx.fillText(`Farey Channels: ${channels.size}`, panelX, panelY);
            panelY += lineHeight * 2;
            
            // Color key
            exportCtx.fillStyle = '#fff';
            exportCtx.font = `bold ${fontSize * 1.2}px Arial`;
            exportCtx.fillText('COLOR KEY', panelX, panelY);
            panelY += lineHeight * 1.5;
            
            const boxSize = fontSize;
            exportCtx.fillStyle = '#00ffff';
            exportCtx.fillRect(panelX, panelY - boxSize * 0.7, boxSize, boxSize);
            exportCtx.fillStyle = '#ccc';
            exportCtx.font = `${fontSize}px Arial`;
            exportCtx.fillText('Cyan = Irreducible (gcd=1)', panelX + boxSize * 1.5, panelY);
            panelY += lineHeight * 1.2;
            
            exportCtx.fillStyle = '#ff1493';
            exportCtx.fillRect(panelX, panelY - boxSize * 0.7, boxSize, boxSize);
            exportCtx.fillStyle = '#ccc';
            exportCtx.fillText('Red = Reducible (gcd>1)', panelX + boxSize * 1.5, panelY);
            panelY += lineHeight * 1.2;
            
            exportCtx.fillStyle = '#ffd700';
            exportCtx.fillRect(panelX, panelY - boxSize * 0.7, boxSize, boxSize);
            exportCtx.fillStyle = '#ccc';
            exportCtx.fillText('Gold = Farey Channels', panelX + boxSize * 1.5, panelY);
            panelY += lineHeight * 2;
            
            // Observation
            exportCtx.fillStyle = '#fff';
            exportCtx.font = `bold ${fontSize * 1.2}px Arial`;
            exportCtx.fillText('OBSERVATION', panelX, panelY);
            panelY += lineHeight * 1.5;
            
            exportCtx.fillStyle = '#ccc';
            exportCtx.font = `${fontSize * 0.9}px Arial`;
            const maxWidth = panelWidth - 40;
            const text = "Reducible residues of composite M project onto their reduced denominators (Farey channels). By elementary counting, exactly d = M/M' residues reduce to each channel M', where d = gcd(r,M) for those residues.";
            wrapText(exportCtx, text, panelX, panelY, maxWidth, lineHeight * 0.9);
            panelY += lineHeight * 4;
            
            // Metadata
            exportCtx.fillStyle = '#fff';
            exportCtx.font = `bold ${fontSize * 1.2}px Arial`;
            exportCtx.fillText('METADATA', panelX, panelY);
            panelY += lineHeight * 1.5;
            
            exportCtx.fillStyle = '#ccc';
            exportCtx.font = `${fontSize * 0.85}px Arial`;
            const now = new Date();
            exportCtx.fillText(`Generated: ${now.toLocaleString()}`, panelX, panelY);
            panelY += lineHeight * 0.9;
            
            exportCtx.fillText('Author: Wessen Getachew', panelX, panelY);
            panelY += lineHeight * 0.9;
            
            exportCtx.fillText('Tool: Modular Reduction Explorer', panelX, panelY);
            panelY += lineHeight * 0.9;
            
            exportCtx.fillText(`Resolution: ${resolution}×${resolution}`, panelX, panelY);
            
            // Zoom indicator
            exportCtx.fillStyle = '#666';
            exportCtx.font = `${fontSize * 0.9}px Arial`;
            exportCtx.textAlign = 'right';
            exportCtx.fillText('Zoom: 100%', totalWidth - 20, totalHeight - 20);
            
            // Download
            const link = document.createElement('a');
            link.download = `modular-reduction-projection-M${config.modulus}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let yPos = y;

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && n > 0) {
                    ctx.fillText(line, x, yPos);
                    line = words[n] + ' ';
                    yPos += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, x, yPos);
        }

        // Event listeners
        document.getElementById('modulusSlider').addEventListener('input', (e) => {
            setModulus(parseInt(e.target.value));
        });

        document.getElementById('modulusInput').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            if (value >= 2 && value <= 5000) {
                setModulus(value);
            }
        });

        document.getElementById('colorScheme').addEventListener('change', (e) => {
            config.colorScheme = e.target.value;
            draw();
        });

        document.getElementById('opacitySlider').addEventListener('input', (e) => {
            config.opacity = parseInt(e.target.value) / 100;
            document.getElementById('opacityValue').textContent = config.opacity.toFixed(2);
            draw();
        });

        document.getElementById('pointSizeSlider').addEventListener('input', (e) => {
            config.pointSize = parseInt(e.target.value);
            document.getElementById('pointSizeValue').textContent = config.pointSize;
            draw();
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            config.showLabels = e.target.checked;
            draw();
        });

        document.getElementById('showMultiplicity').addEventListener('change', (e) => {
            config.showMultiplicity = e.target.checked;
            draw();
        });

        document.getElementById('showProjections').addEventListener('change', (e) => {
            config.showProjections = e.target.checked;
            draw();
        });

        // Initialize
        initCanvas();
        calculatePoints();
        draw();
    </script>
</body>
</html>
