
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Channel Projection | Pro Analysis Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --border: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --accent-dim: rgba(88, 166, 255, 0.15);
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text-primary);
            font-family: var(--font-ui);
            display: grid;
            grid-template-columns: 1fr 360px;
            height: 100vh;
            overflow: hidden;
        }

        /* LEFT: STAGE */
        #stage {
            position: relative;
            background: #050505; /* Deep black for contrast */
            overflow: hidden;
            cursor: default;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* Overlay UI on Stage */
        #overlay-header {
            position: absolute;
            top: 20px; left: 20px;
            pointer-events: none;
            text-shadow: 0 2px 4px #000;
        }
        h1 { margin: 0; font-size: 1.4rem; letter-spacing: -0.5px; }
        .subtitle { color: var(--text-secondary); font-family: var(--font-mono); font-size: 0.85rem; margin-top: 4px; }

        #zoom-controls {
            position: absolute;
            bottom: 20px; left: 20px;
            display: flex; gap: 5px;
            background: rgba(22, 27, 34, 0.8);
            padding: 5px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .icon-btn {
            background: transparent; border: none; color: var(--text-primary);
            width: 28px; height: 28px; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.2rem;
        }
        .icon-btn:hover { background: var(--border); }

        /* RIGHT: PANEL */
        #panel {
            background: var(--panel);
            border-left: 1px solid var(--border);
            display: flex; flex-direction: column;
            overflow-y: auto;
        }

        .section { padding: 15px 20px; border-bottom: 1px solid var(--border); }
        .section-title {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--text-secondary); margin-bottom: 12px; font-weight: 700;
        }

        /* Form Elements */
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .control-row label { font-size: 0.85rem; color: var(--text-secondary); }
        
        select, input[type="number"] {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-primary); padding: 4px 8px; border-radius: 4px;
            font-family: var(--font-mono); font-size: 0.85rem;
        }
        
        input[type="range"] { width: 100%; accent-color: var(--accent); margin: 10px 0; }

        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 8px; }
        .btn-pill {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text-secondary); padding: 6px; font-size: 0.75rem;
            border-radius: 4px; cursor: pointer; transition: 0.1s;
        }
        .btn-pill:hover { border-color: var(--text-primary); color: var(--text-primary); }
        .btn-pill.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }

        .action-btn {
            width: 100%; background: var(--bg); border: 1px solid var(--border);
            color: var(--text-primary); padding: 8px; border-radius: 4px;
            cursor: pointer; margin-bottom: 8px; font-size: 0.85rem;
        }
        .action-btn:hover { background: var(--border); }
        .action-btn.primary { background: #238636; border-color: #238636; color: white; font-weight: 600; }

        /* Data Tables */
        .stat-row { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 6px; }
        .stat-val { font-family: var(--font-mono); color: var(--accent); }

        /* Legend */
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; margin-bottom: 6px; color: var(--text-secondary); }
        .dot { width: 8px; height: 8px; border-radius: 50%; }

        #tooltip {
            position: absolute; pointer-events: none;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid var(--accent);
            padding: 8px 12px; border-radius: 4px;
            font-size: 0.8rem; display: none; z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<div id="stage">
    <canvas id="vizCanvas"></canvas>
    
    <div id="overlay-header">
        <h1 id="disp-title">M = 60</h1>
        <div id="disp-subtitle" class="subtitle">2² × 3 × 5</div>
        <div id="disp-zoom" class="subtitle" style="color:var(--accent); margin-top:2px;">Zoom: 100%</div>
    </div>

    <div id="zoom-controls">
        <button class="icon-btn" onclick="adjustZoom(-0.1)">-</button>
        <button class="icon-btn" onclick="resetView()">⟲</button>
        <button class="icon-btn" onclick="adjustZoom(0.1)">+</button>
    </div>

    <div id="tooltip"></div>
</div>

<div id="panel">
    <div class="section">
        <div class="section-title">Modulus Configuration</div>
        <div class="control-row">
            <input type="number" id="input-m" value="60" min="2" max="5000">
            <button class="btn-pill" style="width:auto; padding:4px 12px;" onclick="toggleAnim()" id="btn-anim">▶ Play Sequence</button>
        </div>
        <input type="range" id="slider-m" min="4" max="2520" value="60">
        <div class="btn-grid">
            <button class="btn-pill" onclick="setM(12)">12</button>
            <button class="btn-pill" onclick="setM(30)">30</button>
            <button class="btn-pill" onclick="setM(60)">60</button>
            <button class="btn-pill" onclick="setM(120)">120</button>
            <button class="btn-pill" onclick="setM(360)">360</button>
            <button class="btn-pill" onclick="setM(840)">840</button>
            <button class="btn-pill" onclick="setM(2520)">2520</button>
            <button class="btn-pill" onclick="setM(5040)">5k</button>
        </div>
    </div>

    <div class="section">
        <div class="section-title">Visualization Parameters</div>
        
        <div class="control-row">
            <label>Color Mode</label>
            <select id="sel-color" onchange="updateConfig()">
                <option value="spectral">Spectral Channels</option>
                <option value="type">Residue Type</option>
                <option value="gcd">Gradient by GCD</option>
            </select>
        </div>

        <div class="control-row">
            <label>Data Labels</label>
            <select id="sel-label" onchange="updateConfig()">
                <option value="none">None</option>
                <option value="gcd">Integer (GCD)</option>
                <option value="frac">Fraction (r'/M')</option>
                <option value="theta">Angle (θ)</option>
            </select>
        </div>

        <div class="control-row">
            <label>Opacity</label>
            <input type="range" style="width:80px" min="0.1" max="1" step="0.1" value="0.4" id="rng-opacity" oninput="updateConfig()">
        </div>

        <button class="action-btn" onclick="toggleView()" id="btn-view">Switch to Ring View</button>
    </div>

    <div class="section">
        <div class="section-title">Channel Analytics</div>
        <div class="stat-row"><span>Euler Totient φ(M)</span><span class="stat-val" id="val-phi">-</span></div>
        <div class="stat-row"><span>Active Channels</span><span class="stat-val" id="val-channels">-</span></div>
        <div class="stat-row"><span>Projection Depth</span><span class="stat-val" id="val-depth">-</span></div>
        <div style="margin-top:10px; font-size:0.75rem; color:#666;">
            Click any ring to isolate that specific Farey channel.
        </div>
    </div>

    <div class="section">
        <div class="section-title">Legend</div>
        <div id="legend-dynamic">
            </div>
    </div>

    <div class="section" style="border-bottom:none">
        <div class="section-title">Export Research Data</div>
        <div style="display:flex; gap:5px;">
            <button class="action-btn" onclick="exportPNG('2k')">PNG 2K</button>
            <button class="action-btn primary" onclick="exportPNG('4k')">PNG 4K</button>
        </div>
        <button class="action-btn" onclick="exportCSV()">Download Dataset (CSV)</button>
    </div>

    <div style="margin-top:auto; padding:20px; text-align:center; font-size:0.7rem; color:var(--text-secondary); border-top:1px solid var(--border);">
        <strong>Composite Channel Projection</strong><br>
        Analysis Tool by Wessen Getachew
    </div>
</div>

<script>
/**
 * ----------------------------------------
 * CORE LOGIC
 * ----------------------------------------
 */
const MathCore = {
    gcd: (a, b) => { while (b) [a, b] = [b, a % b]; return a; },
    phi: (n) => {
        let result = n;
        for (let i = 2; i * i <= n; i++) {
            if (n % i === 0) {
                while (n % i === 0) n /= i;
                result -= result / i;
            }
        }
        if (n > 1) result -= result / n;
        return result;
    },
    getFactors: (n) => {
        const f = new Set();
        let d = 2, temp = n;
        while (d * d <= temp) {
            if (temp % d === 0) { f.add(d); temp /= d; } else { d++; }
        }
        if (temp > 1) f.add(temp);
        return Array.from(f).join(" × ");
    }
};

/**
 * ----------------------------------------
 * APP STATE
 * ----------------------------------------
 */
const State = {
    M: 60,
    residues: [],
    channels: [],
    
    // View Config
    viewMode: 'projection',
    colorMode: 'spectral',
    labelMode: 'none',
    opacity: 0.4,
    
    // Camera / Navigation
    zoom: 1,
    panX: 0,
    panY: 0,
    isDragging: false,
    lastMouse: {x:0, y:0},
    
    // Interaction
    hovered: null,
    isolatedChannel: null,
    isAnimating: false,
    animTimer: null
};

/**
 * ----------------------------------------
 * DATA GENERATION
 * ----------------------------------------
 */
function computeData() {
    const M = State.M;
    State.residues = [];
    const channelMap = {};

    for (let r = 0; r < M; r++) {
        const effectiveR = r === 0 ? M : r;
        const d = MathCore.gcd(effectiveR, M);
        const m_prime = M / d;

        if (!channelMap[m_prime]) {
            channelMap[m_prime] = {
                val: m_prime,
                d: d,
                count: 0,
                color: null
            };
        }

        channelMap[m_prime].count++;

        State.residues.push({
            r: r,
            d: d,
            m_prime: m_prime,
            r_prime: effectiveR / d,
            angle: (r / M) * Math.PI * 2 - (Math.PI / 2),
            type: d === 1 ? 'coprime' : 'reducible'
        });
    }

    State.channels = Object.values(channelMap).sort((a,b) => a.val - b.val);

    // Assign Spectral Colors to Channels
    State.channels.forEach((ch, index) => {
        const hue = ((index * 0.618033988749895) % 1) * 360;
        ch.color = `hsl(${hue}, 75%, 60%)`;
    });

    updateStats();
    render();
}

/**
 * ----------------------------------------
 * RENDERING ENGINE (CANVAS 2D)
 * ----------------------------------------
 */
const canvas = document.getElementById('vizCanvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = document.getElementById('stage').clientWidth;
    canvas.height = document.getElementById('stage').clientHeight;
    render();
}
window.addEventListener('resize', resize);

function getPointColor(res) {
    if (State.colorMode === 'type') {
        if (res.d === 1) return '#58a6ff';
        if (res.m_prime === 1) return '#ffd700';
        return '#ff6b6b';
    }
    if (State.colorMode === 'gcd') {
        if (res.d === 1) return '#58a6ff';
        return `hsl(${(res.d * 15) % 360}, 70%, 60%)`;
    }
    // Spectral
    const ch = State.channels.find(c => c.val === res.m_prime);
    return ch ? ch.color : '#fff';
}

function render(exportCtx = null, exportSize = null) {
    const context = exportCtx || ctx;
    const width = exportSize ? exportSize.w : canvas.width;
    const height = exportSize ? exportSize.h : canvas.height;
    
    // Clear
    context.fillStyle = exportCtx ? '#0d1117' : '#050505';
    context.fillRect(0, 0, width, height);

    const centerX = width / 2;
    const centerY = height / 2;
    const minDim = Math.min(width, height);
    
    const baseRadius = exportCtx ? (minDim * 0.35) : (minDim * 0.4);
    
    const zoom = exportCtx ? 1 : State.zoom;
    const panX = exportCtx ? 0 : State.panX;
    const panY = exportCtx ? 0 : State.panY;

    // Apply Transform
    context.save();
    context.translate(centerX + panX, centerY + panY);
    context.scale(zoom, zoom);

    // 1. Draw Channel Rings
    State.channels.forEach((ch, i) => {
        if (State.isolatedChannel && State.isolatedChannel !== ch.val) return;

        const pct = (i + 1) / (State.channels.length + 1);
        let r = pct * baseRadius;
        if (ch.val === State.M) r = baseRadius;
        if (ch.val === 1) r = baseRadius * 0.05;
        
        ch.renderR = r; 

        context.beginPath();
        context.arc(0, 0, r, 0, Math.PI * 2);
        context.strokeStyle = State.isolatedChannel ? ch.color : '#30363d';
        context.lineWidth = exportCtx ? 2 : 1 / zoom;
        context.stroke();
    });

    // 2. Draw Data Points & Lines
    const pointSize = exportCtx ? 6 : (3 / Math.sqrt(zoom));
    const lineWidth = exportCtx ? 2 : (1 / zoom);

    State.residues.forEach(res => {
        if (State.isolatedChannel && State.isolatedChannel !== res.m_prime) return;

        const color = getPointColor(res);
        const ch = State.channels.find(c => c.val === res.m_prime);
        const destR = ch.renderR;
        
        const cos = Math.cos(res.angle);
        const sin = Math.sin(res.angle);

        const x1 = cos * baseRadius;
        const y1 = sin * baseRadius;
        const x2 = cos * destR;
        const y2 = sin * destR;

        if (State.viewMode === 'projection' && res.d > 1) {
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.strokeStyle = color;
            context.lineWidth = lineWidth;
            context.globalAlpha = State.opacity;
            context.stroke();
            context.globalAlpha = 1.0;
        }

        context.beginPath();
        context.arc(x2, y2, pointSize, 0, Math.PI * 2);
        context.fillStyle = color;
        context.fill();

        // 3. Draw Labels (Smart LOD)
        const showLabels = State.labelMode !== 'none';
        const densityCheck = (State.M < 50) || (zoom > 3);

        if (showLabels && densityCheck && !exportCtx) {
            let labelText = '';
            if (State.labelMode === 'gcd') labelText = res.d;
            if (State.labelMode === 'frac') labelText = `${res.r_prime}/${res.m_prime}`;
            if (State.labelMode === 'theta') labelText = (res.angle * 180 / Math.PI).toFixed(0) + '°';

            context.fillStyle = '#fff';
            context.font = `${10/zoom}px monospace`;
            
            const lx = x2 + cos * (15/zoom);
            const ly = y2 + sin * (15/zoom);
            
            context.fillText(labelText, lx, ly);
        }
    });

    context.restore();
}

/**
 * ----------------------------------------
 * INTERACTION & NAVIGATION
 * ----------------------------------------
 */
const stage = document.getElementById('stage');

stage.addEventListener('wheel', e => {
    e.preventDefault();
    const direction = e.deltaY > 0 ? -1 : 1;
    adjustZoom(direction * 0.1);
});

function adjustZoom(amount) {
    State.zoom += amount * State.zoom;
    if (State.zoom < 0.1) State.zoom = 0.1;
    if (State.zoom > 10) State.zoom = 10;
    
    document.getElementById('disp-zoom').innerText = `Zoom: ${(State.zoom*100).toFixed(0)}%`;
    render();
}

function resetView() {
    State.zoom = 1;
    State.panX = 0;
    State.panY = 0;
    State.isolatedChannel = null;
    document.getElementById('disp-zoom').innerText = `Zoom: 100%`;
    render();
}

canvas.addEventListener('mousedown', e => {
    State.isDragging = true;
    State.lastMouse = { x: e.clientX, y: e.clientY };
});

window.addEventListener('mouseup', () => State.isDragging = false);

window.addEventListener('mousemove', e => {
    if (State.isDragging) {
        const dx = e.clientX - State.lastMouse.x;
        const dy = e.clientY - State.lastMouse.y;
        State.panX += dx;
        State.panY += dy;
        State.lastMouse = { x: e.clientX, y: e.clientY };
        render();
    }
    handleHover(e);
});

canvas.addEventListener('click', e => {
    if (Math.abs(e.clientX - State.lastMouse.x) > 5) return;

    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2 + State.panX;
    const cy = rect.height/2 + State.panY;
    
    const mx = (e.clientX - rect.left - cx) / State.zoom;
    const my = (e.clientY - rect.top - cy) / State.zoom;
    const dist = Math.sqrt(mx*mx + my*my);
    
    const minDim = Math.min(canvas.width, canvas.height);
    const baseR = minDim * 0.4;
    
    let clickedCh = null;
    let minDiff = 10 / State.zoom;

    State.channels.forEach(ch => {
        if (Math.abs(ch.renderR - dist) < minDiff) {
            clickedCh = ch.val;
            minDiff = Math.abs(ch.renderR - dist);
        }
    });

    if (clickedCh) {
        if (State.isolatedChannel === clickedCh) State.isolatedChannel = null;
        else State.isolatedChannel = clickedCh;
        render();
    }
});

function handleHover(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2 + State.panX;
    const cy = rect.height/2 + State.panY;
    const mx = (e.clientX - rect.left - cx) / State.zoom;
    const my = (e.clientY - rect.top - cy) / State.zoom;

    let minD = 10 / State.zoom;
    let target = null;

    State.residues.forEach(res => {
        if (State.isolatedChannel && res.m_prime !== State.isolatedChannel) return;
        
        const ch = State.channels.find(c => c.val === res.m_prime);
        const px = Math.cos(res.angle) * ch.renderR;
        const py = Math.sin(res.angle) * ch.renderR;
        
        const dist = Math.sqrt((mx-px)**2 + (my-py)**2);
        if (dist < minD) {
            minD = dist;
            target = res;
        }
    });

    const tip = document.getElementById('tooltip');
    if (target) {
        tip.style.display = 'block';
        tip.style.left = (e.clientX + 15) + 'px';
        tip.style.top = (e.clientY + 15) + 'px';
        
        const color = getPointColor(target);
        
        tip.innerHTML = `
            <strong style="color:${color}">Residue ${target.r}</strong>
            <div style="margin-top:4px; color:#ccc">
            Type: ${target.type}<br>
            GCD: ${target.d}<br>
            Channel: M'=${target.m_prime}<br>
            Angle: ${(target.angle * 180 / Math.PI).toFixed(1)}°
            </div>
        `;
    } else {
        tip.style.display = 'none';
    }
}

/**
 * ----------------------------------------
 * UI UPDATES & EXPORT
 * ----------------------------------------
 */
function setM(m) {
    State.M = parseInt(m);
    document.getElementById('input-m').value = State.M;
    document.getElementById('slider-m').value = State.M;
    document.getElementById('disp-title').innerText = `M = ${State.M}`;
    document.getElementById('disp-subtitle').innerText = MathCore.getFactors(State.M);
    computeData();
    updateLegend();
}

function updateConfig() {
    State.colorMode = document.getElementById('sel-color').value;
    State.labelMode = document.getElementById('sel-label').value;
    State.opacity = parseFloat(document.getElementById('rng-opacity').value);
    render();
    updateLegend();
}

function toggleView() {
    State.viewMode = State.viewMode === 'projection' ? 'rings' : 'projection';
    document.getElementById('btn-view').innerText = State.viewMode === 'projection' ? 'Switch to Ring View' : 'Switch to Projection View';
    render();
}

function updateStats() {
    document.getElementById('val-phi').innerText = MathCore.phi(State.M);
    document.getElementById('val-channels').innerText = State.channels.length;
    document.getElementById('val-depth').innerText = State.channels[0].d;
}

function updateLegend() {
    const el = document.getElementById('legend-dynamic');
    el.innerHTML = '';
    
    if (State.colorMode === 'spectral') {
        el.innerHTML = '<div style="font-style:italic; font-size:0.75rem; margin-bottom:5px">Colors represent distinct Farey Channels (Moduli Rings)</div>';
        State.channels.slice(0, 5).forEach(ch => {
            el.innerHTML += `<div class="legend-item"><div class="dot" style="background:${ch.color}"></div>M' = ${ch.val}</div>`;
        });
        if (State.channels.length > 5) el.innerHTML += `<div class="legend-item">... (${State.channels.length - 5} more)</div>`;
    } else if (State.colorMode === 'type') {
        el.innerHTML += `<div class="legend-item"><div class="dot" style="background:#58a6ff"></div>Coprime (Irreducible)</div>`;
        el.innerHTML += `<div class="legend-item"><div class="dot" style="background:#ff6b6b"></div>Reducible</div>`;
        el.innerHTML += `<div class="legend-item"><div class="dot" style="background:#ffd700"></div>Center (M'=1)</div>`;
    }
}

function toggleAnim() {
    if (State.isAnimating) {
        clearInterval(State.animTimer);
        State.isAnimating = false;
        document.getElementById('btn-anim').classList.remove('active');
    } else {
        State.isAnimating = true;
        document.getElementById('btn-anim').classList.add('active');
        State.animTimer = setInterval(() => {
            let next = State.M + 1;
            if (next > 1000) next = 4;
            setM(next);
        }, 100);
    }
}

// FIXED EXPORT FUNCTION
function exportPNG(res) {
    const size = res === '4k' ? 4096 : 2048;
    const expCvs = document.createElement('canvas');
    expCvs.width = size;
    expCvs.height = size * 0.75;
    const eCtx = expCvs.getContext('2d');
    
    // Draw Scene (Full View)
    render(eCtx, {w: size * 0.75, h: size * 0.75}); 

    // Draw Legend/Meta on Right Strip
    // Safe Zone Calculations
    const margin = size * 0.03; 
    const sidebarX = size * 0.75;
    const sidebarW = size * 0.25;
    const textX = sidebarX + margin;
    const maxTextWidth = sidebarW - (margin * 2);
    
    eCtx.fillStyle = '#0d1117';
    eCtx.fillRect(sidebarX, 0, sidebarW, size * 0.75); // Sidebar BG
    
    // Text Config - Smaller fonts to fit
    eCtx.fillStyle = '#f0f6fc';
    eCtx.font = `bold ${size*0.025}px sans-serif`; // Reduced from 0.03
    eCtx.fillText(`M = ${State.M}`, textX, margin + size*0.05);
    
    eCtx.font = `${size*0.012}px monospace`; // Reduced from 0.015
    eCtx.fillStyle = '#8b949e';
    // Ensure Prime Factors doesn't overflow
    const factors = MathCore.getFactors(State.M);
    eCtx.fillText(factors, textX, margin + size*0.08, maxTextWidth);

    // Signature
    const bottomY = size * 0.75 - margin;
    eCtx.fillStyle = '#30363d';
    eCtx.fillRect(textX, bottomY - size*0.05, size*0.1, 2);
    
    eCtx.fillStyle = '#f0f6fc';
    eCtx.font = `bold ${size*0.015}px sans-serif`;
    eCtx.fillText("Wessen Getachew", textX, bottomY);
    
    eCtx.fillStyle = '#8b949e';
    eCtx.font = `${size*0.012}px sans-serif`;
    eCtx.fillText("Composite Channel Projection", textX, bottomY + size*0.02);

    const link = document.createElement('a');
    link.download = `Projection_M${State.M}_${res}.png`;
    link.href = expCvs.toDataURL();
    link.click();
}

function exportCSV() {
    let csv = "Residue,Modulus,GCD,Channel,Fraction,Angle_Deg,Color_Hex\n";
    State.residues.forEach(r => {
        const c = State.channels.find(ch => ch.val === r.m_prime);
        csv += `${r.r},${State.M},${r.d},${r.m_prime},${r.r_prime}/${r.m_prime},${(r.angle*180/Math.PI).toFixed(2)},${c.color}\n`;
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `data_m${State.M}.csv`;
    link.click();
}

// Init
document.getElementById('input-m').addEventListener('change', e=>setM(e.target.value));
document.getElementById('slider-m').addEventListener('input', e=>setM(e.target.value));
computeData();

</script>
</body>
</html>
